diff --git a/Makefile.am b/Makefile.am
index ca2c7ec..d00694d 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -327,9 +327,12 @@ scripts/northrend/crusaders_coliseum/trial_of_the_crusader/boss_twin_valkyr.cpp
 scripts/northrend/crusaders_coliseum/trial_of_the_crusader/instance_trial_of_the_crusader.cpp \
 scripts/northrend/crusaders_coliseum/trial_of_the_crusader/trial_of_the_crusader.cpp \
 scripts/northrend/crusaders_coliseum/trial_of_the_crusader/trial_of_the_crusader.h \
+scripts/northrend/draktharon_keep/boss_dred.cpp \
 scripts/northrend/draktharon_keep/boss_novos.cpp \
 scripts/northrend/draktharon_keep/boss_tharonja.cpp \
 scripts/northrend/draktharon_keep/boss_trollgore.cpp \
+scripts/northrend/draktharon_keep/draktharon_keep.h \
+scripts/northrend/draktharon_keep/instance_draktharon_keep.cpp \
 scripts/northrend/gundrak/boss_colossus.cpp \
 scripts/northrend/gundrak/boss_eck.cpp \
 scripts/northrend/gundrak/boss_galdarah.cpp \
diff --git a/VC90/90ScriptDev2.vcproj b/VC90/90ScriptDev2.vcproj
index 9128712..d01ee5a 100644
--- a/VC90/90ScriptDev2.vcproj
+++ b/VC90/90ScriptDev2.vcproj
@@ -1703,6 +1703,10 @@
 					Name="draktharon_keep"
 					>
 					<File
+						RelativePath="..\scripts\northrend\draktharon_keep\boss_dred.cpp"
+						>
+					</File>
+					<File
 						RelativePath="..\scripts\northrend\draktharon_keep\boss_novos.cpp"
 						>
 					</File>
@@ -1714,6 +1718,14 @@
 						RelativePath="..\scripts\northrend\draktharon_keep\boss_trollgore.cpp"
 						>
 					</File>
+					<File
+						RelativePath="..\scripts\northrend\draktharon_keep\draktharon_keep.h"
+						>
+					</File>
+					<File
+						RelativePath="..\scripts\northrend\draktharon_keep\instance_draktharon_keep.cpp"
+						>
+					</File>
 				</Filter>
 				<Filter
 					Name="gundrak"
diff --git a/scripts/northrend/draktharon_keep/boss_dred.cpp b/scripts/northrend/draktharon_keep/boss_dred.cpp
new file mode 100644
index 0000000..64f63b2
--- /dev/null
+++ b/scripts/northrend/draktharon_keep/boss_dred.cpp
@@ -0,0 +1,282 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: Boss_Tharonja
+SD%Complete: 80%
+SDComment: Timers
+SDCategory: Drak'Tharon Keep
+EndScriptData */
+
+#include "precompiled.h"
+#include "draktharon_keep.h"
+
+enum
+{
+    SAY_KING_DRED_TALON                = -1600020,
+    SAY_CALL_FOR_RAPTOR                = -1600021,
+
+    SPELL_BELLOWING_ROAR                = 22686,
+    SPELL_FEARSOME_ROAR                 = 48849,
+    H_SPELL_FEARSOME_ROAR               = 59422,
+    SPELL_GRIEVOUS_BITE                 = 48920,
+    SPELL_MANGLING_SLASH                = 48873,
+    SPELL_PIERCING_SLASH                = 48878,
+    SPELL_RAPTOR_CALL                   = 59416,            //not yet implemented
+
+    NPC_DRAKKARI_GUTRIPPER              = 26641,
+    NPC_DRAKKARI_SCYTHECLAW             = 26628,
+
+    SPELL_GUT_RIP                       = 49710,
+    SPELL_REND                          = 13738
+};
+
+enum eArchivements
+{
+    ACHIEV_BETTER_OFF_DRED                        = 2039
+};
+
+uint32 m_uiRaptorCounter;
+
+/*######
+## boss_dred
+######*/
+
+struct MANGOS_DLL_DECL boss_dredAI : public ScriptedAI
+{
+    boss_dredAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 FearsomeRoar_Timer;
+    uint32 ManglingSlash_Timer;
+    uint32 PiercingSlash_Timer;
+    uint32 GrievousBite_Timer;
+    uint32 BellowingRoar_Timer;
+    uint32 Check_Timer;
+    uint32 CallForRaptor_Timer;
+
+    void Reset()
+    {
+        FearsomeRoar_Timer = 15000;
+        ManglingSlash_Timer = urand(5000, 10000);
+        PiercingSlash_Timer = urand(10000, 15000);
+        GrievousBite_Timer = urand (15000, 20000);
+        BellowingRoar_Timer = 60000;
+        Check_Timer = 15000;
+        CallForRaptor_Timer = 25000;
+
+        m_uiRaptorCounter = 0;
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_DRED, NOT_STARTED);
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_DRED, IN_PROGRESS);
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_DRED, DONE);
+
+        if(!m_bIsRegularMode && m_uiRaptorCounter >= 6)
+        {
+            if(m_pInstance)
+                m_pInstance->DoCompleteAchievement(ACHIEV_BETTER_OFF_DRED);
+        }
+    }
+
+    Creature* SelectRandomRaptor(float fRange)
+    {
+        std::list<Creature* > lRapotrList;
+        switch (urand(0,1))
+        {
+        case 0:
+            GetCreatureListWithEntryInGrid(lRapotrList, m_creature, NPC_DRAKKARI_GUTRIPPER, fRange);
+            break;
+        case 1:
+            GetCreatureListWithEntryInGrid(lRapotrList, m_creature, NPC_DRAKKARI_SCYTHECLAW, fRange);
+            break;
+        }
+
+        if (lRapotrList.empty()){
+            CallForRaptor_Timer = 25000;
+            return NULL;
+        }
+
+        std::list<Creature* >::iterator iter = lRapotrList.begin();
+        advance(iter, urand(0, lRapotrList.size()-1));
+
+        return *iter;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        //Fearsome Roar
+        if (FearsomeRoar_Timer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_FEARSOME_ROAR : H_SPELL_FEARSOME_ROAR, true);
+            FearsomeRoar_Timer = 15000;
+        }else FearsomeRoar_Timer -= uiDiff;
+
+        //Piercing Slash
+        if (PiercingSlash_Timer < uiDiff)
+        {    
+            DoCast(m_creature->getVictim(), SPELL_PIERCING_SLASH, true);
+            PiercingSlash_Timer = urand(20000, 25000);
+        }else PiercingSlash_Timer -= uiDiff;
+
+        //Mangling Slash
+        if (ManglingSlash_Timer < uiDiff)
+        {    
+            DoCast(m_creature->getVictim(), SPELL_MANGLING_SLASH, true);
+            ManglingSlash_Timer = urand(20000, 25000);
+        }else ManglingSlash_Timer -= uiDiff;
+
+        //Mangling Slash
+        if (GrievousBite_Timer < uiDiff)
+        {    
+            DoCast(m_creature->getVictim(), SPELL_GRIEVOUS_BITE, true);
+            GrievousBite_Timer = urand(20000, 25000);
+        }else GrievousBite_Timer -= uiDiff;
+
+        //Grievous Bite remove
+        if (Check_Timer < uiDiff)
+        {
+            Unit* pPlayer = m_creature->getVictim();
+            if (pPlayer->GetHealth() == pPlayer->GetMaxHealth())
+                if (pPlayer->HasAura(SPELL_GRIEVOUS_BITE))
+                    pPlayer->RemoveAura(SPELL_GRIEVOUS_BITE, EFFECT_INDEX_0);
+            Check_Timer = 1000;
+        }else Check_Timer -= uiDiff;
+
+        //Bellowing Roar
+        if (BellowingRoar_Timer < uiDiff)
+        {    
+            DoCast(m_creature, SPELL_BELLOWING_ROAR);
+            BellowingRoar_Timer = 60000;
+        }else BellowingRoar_Timer -= uiDiff;
+
+        //Call For Raptor - spell
+        if (CallForRaptor_Timer < uiDiff)
+        {    
+            DoScriptText(SAY_CALL_FOR_RAPTOR, m_creature);
+            m_creature->CastSpell(m_creature, SAY_CALL_FOR_RAPTOR, true);
+            CallForRaptor_Timer = 25000;
+            if(Creature* pRaptor = SelectRandomRaptor(50.0f))
+                pRaptor->AI()->AttackStart(m_creature->getVictim());
+        }else CallForRaptor_Timer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL mob_dred_raptorAI : public ScriptedAI
+{
+    mob_dred_raptorAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 uiRendTimer;
+    uint32 GutRipTimer;
+    uint32 creatureEntry;
+
+    void Reset()
+    {
+        uiRendTimer = urand(10000, 15000);
+        GutRipTimer = urand(10000, 15000);
+        creatureEntry = m_creature->GetEntry();
+    }
+
+    void JustDied(Unit* killer)
+    {
+        if (m_pInstance)
+        {
+            if(!m_bIsRegularMode && m_pInstance->GetData(TYPE_DRED) == IN_PROGRESS)
+                ++m_uiRaptorCounter;
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        switch (creatureEntry)
+        {
+        case NPC_DRAKKARI_GUTRIPPER:
+            if (GutRipTimer < uiDiff)
+            {
+                DoCast(m_creature->getVictim(), SPELL_GUT_RIP);
+                GutRipTimer = urand(10000,15000);
+            }else GutRipTimer -=uiDiff;
+            break;
+        case NPC_DRAKKARI_SCYTHECLAW:
+            if (uiRendTimer < uiDiff)
+            {
+                DoCast(m_creature->getVictim(), SPELL_REND);
+                uiRendTimer = urand(10000, 15000);
+            }else uiRendTimer -=uiDiff;
+            break;
+        }
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_boss_dred(Creature* pCreature)
+{
+    return new boss_dredAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_dred_raptor(Creature* pCreature)
+{
+    return new mob_dred_raptorAI(pCreature);
+}
+
+void AddSC_boss_dred()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "boss_dred";
+    newscript->GetAI = &GetAI_boss_dred;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_dred_raptor";
+    newscript->GetAI = &GetAI_mob_dred_raptor;
+    newscript->RegisterSelf();
+}
\ No newline at end of file
diff --git a/scripts/northrend/draktharon_keep/boss_novos.cpp b/scripts/northrend/draktharon_keep/boss_novos.cpp
index 9485dfb..b665924 100644
--- a/scripts/northrend/draktharon_keep/boss_novos.cpp
+++ b/scripts/northrend/draktharon_keep/boss_novos.cpp
@@ -22,6 +22,7 @@ SDCategory: Drak'Tharon Keep
 EndScriptData */
 
 #include "precompiled.h"
+#include "draktharon_keep.h"
 
 enum
 {
@@ -32,9 +33,36 @@ enum
     SAY_BUBBLE_1                    = -1600009,
     SAY_BUBBLE_2                    = -1600010,
 
-    EMOTE_ASSISTANCE                = -1600011
+    EMOTE_ASSISTANCE                = -1600011,
+
+    POS                                 = 3,
+    
+    SPELL_ARCANE_FIELD                  = 47346,
+    SPELL_FROSTBOLT                     = 49037,
+    H_SPELL_FROSTBOLT                   = 59855,
+    SPELL_ARCANE_BLAST                  = 49198,
+    H_SPELL_ARCANE_BLAST                = 59909,
+    SPELL_BLIZZARD                      = 49034,
+    H_SPELL_BLIZZARD                    = 59854,
+    SPELL_WRATH_OF_MISERY               = 50089,
+    H_SPELL_WRATH_OF_MISERY             = 59856,
+
+    SPELL_RITUAL_CRYSTAL_KEY            = 51404,
+    SPELL_EFFECT                        = 52106,
+    SPELL_DEAD_EFFECT                   = 47336,
+
+    SPELL_SHADOW_BOLT                   = 51363,
+    H_SPELL_SHADOW_BOLT                 = 59016,
+
+    ACHIEV_OH_NOVOS                     = 2057,
 };
 
+const float AddSpawnPoint[3] = { -379.20f, -816.76f, 59.70f };
+const float CrystalHandlerSpawnPoint[3] = { -314.00f, -699.17f, 27.2914f };
+const float AddDestinyPoint[3] = { -379.314545f, -770.577637f, 28.58837f };
+
+bool m_bIsAchiev;   // needed for achiev
+
 /*######
 ## boss_novos
 ######*/
@@ -45,19 +73,73 @@ struct MANGOS_DLL_DECL boss_novosAI : public ScriptedAI
     {
         m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
         m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        SetCombatMovement(false);
         Reset();
     }
 
     ScriptedInstance* m_pInstance;
     bool m_bIsRegularMode;
 
+    bool Phase1;
+    bool Phase2;
+    uint32 Start_Check;
+    uint32 Handler_Spawn;
+    uint32 Handler_Count;
+    uint32 Cast_Timer;
+    uint32 ArcaneCount;
+    uint32 SpecialCast;
+    uint32 SummonMinion_Timer;
+    uint32 m_uiWaveTimer;
+
+    std::list<uint64> luiCrystals;
+
     void Reset()
     {
+        Start_Check = 1;
+        Handler_Spawn = 5000;
+        Handler_Count = 0;
+        ArcaneCount = 0;
+        SpecialCast = 0;
+        Phase1 = false;
+        Phase2 = false;
+
+        m_uiWaveTimer   = 1000;
+        m_bIsAchiev     = true;
+
+        luiCrystals.clear();
+
+        if(m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_NOVOS, NOT_STARTED);
+            luiCrystals.push_back(m_pInstance->GetData64(TYPE_CRYSTAL_1));
+            luiCrystals.push_back(m_pInstance->GetData64(TYPE_CRYSTAL_2));
+            luiCrystals.push_back(m_pInstance->GetData64(TYPE_CRYSTAL_3));
+            luiCrystals.push_back(m_pInstance->GetData64(TYPE_CRYSTAL_4));
+            for (std::list<uint64>::const_iterator itr = luiCrystals.begin(); itr != luiCrystals.end(); ++itr)
+            {
+                if (GameObject* pTemp = m_pInstance->instance->GetGameObject(*itr))
+                    pTemp->SetGoState(GO_STATE_READY);
+            }
+        }
     }
 
     void Aggro(Unit* pWho)
     {
         DoScriptText(SAY_AGGRO, m_creature);
+
+        if(m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_NOVOS, IN_PROGRESS);
+
+            for (std::list<uint64>::const_iterator itr = luiCrystals.begin(); itr != luiCrystals.end(); ++itr)
+            {
+                if (GameObject *pTemp = m_pInstance->instance->GetGameObject(*itr))
+                    pTemp->SetGoState(GO_STATE_ACTIVE);
+            }
+        }
+
+        m_creature->SummonCreature(NPC_CRYSTAL_CHANNEL_TARGET, -379.269f, -737.728f, 39.313f, 0 , TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 600000);
+        m_creature->CallForHelp(50.0f);
     }
 
     void KilledUnit(Unit* pVictim)
@@ -68,6 +150,254 @@ struct MANGOS_DLL_DECL boss_novosAI : public ScriptedAI
     void JustDied(Unit* pKiller)
     {
         DoScriptText(SAY_DEATH, m_creature);
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_NOVOS, DONE);
+
+        if(!m_bIsRegularMode && m_bIsAchiev)
+        {
+            if(m_pInstance)
+                m_pInstance->DoCompleteAchievement(ACHIEV_OH_NOVOS);
+        }
+    }
+
+    void EnterPhase1()
+    {
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        m_creature->SetInCombatWithZone();
+        Phase1 = true;
+    }
+
+    void EnterPhase2()
+    {
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        m_creature->InterruptSpell(CURRENT_CHANNELED_SPELL);
+        SummonMinion_Timer = urand (15000,20000);
+        Phase1 = false;
+        Phase2 = true;
+    }
+
+    void RemoveCrystal()
+    {
+        if (!luiCrystals.empty())
+        {
+            if (m_pInstance)
+                if (GameObject *pTemp = m_pInstance->instance->GetGameObject(luiCrystals.back()))
+                    pTemp->SetGoState(GO_STATE_READY);
+            luiCrystals.pop_back();
+        }
+        if (luiCrystals.empty())
+        {
+            m_creature->CastStop();
+            m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            EnterPhase2();
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (Phase2 == true)
+        {
+               if (Cast_Timer < uiDiff)
+            {     
+                if (ArcaneCount == 2)
+                {
+                    DoCast(SelectUnit(SELECT_TARGET_RANDOM, 0),  m_bIsRegularMode ? SPELL_ARCANE_BLAST : H_SPELL_ARCANE_BLAST);
+                    ArcaneCount = 0;
+                }
+
+                if (ArcaneCount < 2)
+                {
+                    if (SpecialCast == 3)
+                    {
+                        switch(urand(0, 1))
+                        {
+                            case 0: 
+                                DoCast(SelectUnit(SELECT_TARGET_RANDOM, 0),  m_bIsRegularMode ? SPELL_WRATH_OF_MISERY : H_SPELL_WRATH_OF_MISERY);
+                            case 1: 
+                                DoCast(SelectUnit(SELECT_TARGET_RANDOM, 0),  m_bIsRegularMode ? SPELL_BLIZZARD : H_SPELL_BLIZZARD);
+                        }
+                        SpecialCast = 0;
+                    }
+                    if (SpecialCast < 3)
+                    {
+                        DoCast(SelectUnit(SELECT_TARGET_RANDOM, 0),  m_bIsRegularMode ? SPELL_FROSTBOLT : H_SPELL_FROSTBOLT);
+                        SpecialCast ++;
+                    }
+                    ArcaneCount ++;
+                }
+                Cast_Timer = 1000;
+            }else Cast_Timer -= uiDiff;
+        }
+
+        if ( m_creature->getVictim() && Start_Check == 1)
+        {
+            EnterPhase1();
+            DoCast(m_creature, SPELL_ARCANE_FIELD);
+            Start_Check = 0;
+        }
+        
+        if(!m_bIsRegularMode)
+            if (SummonMinion_Timer < uiDiff )
+            {    
+                for(uint8 i = 0; i < 5; i++)
+                {
+                    if (Creature* pAdd = m_creature->SummonCreature(NPC_FETID_TROLL_CORPSE, m_creature->GetPositionX() + urand(0, 3), m_creature->GetPositionY() + urand(0, 3),m_creature->GetPositionZ(),0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                        pAdd->AI()->AttackStart(m_creature->getVictim());
+                }
+                SummonMinion_Timer = urand (25000,30000);
+            }else SummonMinion_Timer -= uiDiff;
+        
+        if (Handler_Spawn < uiDiff && Phase1 == true)
+        {    
+            Handler_Count ++;
+            if(Handler_Count < 5)
+            {
+                if(Creature* pAdd = m_creature->SummonCreature(NPC_CRYSTAL_HANDLER, CrystalHandlerSpawnPoint[0],CrystalHandlerSpawnPoint[1],CrystalHandlerSpawnPoint[2],0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                    pAdd->GetMotionMaster()->MovePoint(0, AddDestinyPoint[0], AddDestinyPoint[1], AddDestinyPoint[2]);
+                Handler_Spawn = urand(20000, 30000);
+            }
+            if(Handler_Count == 5)
+            {            
+                EnterPhase2();
+                if (Creature* pTrigger = GetClosestCreatureWithEntry(m_creature, NPC_CRYSTAL_CHANNEL, 85.0f))
+                    pTrigger->ForcedDespawn();
+                Phase2 = true;
+                Cast_Timer = 500;
+            }
+        }else Handler_Spawn -= uiDiff;
+
+        if (m_uiWaveTimer < uiDiff && Phase1 == true)
+        {
+            uint32 m_uiSummonEntry = 0;
+            switch (urand(0, 2))
+            {
+                case 0:
+                    m_uiSummonEntry = NPC_HULKING_CORPSE;
+                    break;
+                case 1:
+                    m_uiSummonEntry = NPC_RISEN_SHADOWCASTER;
+                    break;
+                case 2:
+                    m_uiSummonEntry = NPC_FETID_TROLL_CORPSE;
+                    break;
+            }
+            if (Creature* pAdd = m_creature->SummonCreature(m_uiSummonEntry, AddSpawnPoint[0],AddSpawnPoint[1],AddSpawnPoint[2],0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                pAdd->GetMotionMaster()->MovePoint(0, AddDestinyPoint[0], AddDestinyPoint[1], AddDestinyPoint[2]);
+
+            m_uiWaveTimer = 3000;
+        }else m_uiWaveTimer -= uiDiff;
+    }
+};
+
+enum CrystalHandlerSpells
+{
+    SPELL_FLASH_OF_DARKNESS                       = 49668,
+    H_SPELL_FLASH_OF_DARKNESS                     = 59004
+};
+
+struct MANGOS_DLL_DECL crystal_handlerAI : public ScriptedAI
+{
+    crystal_handlerAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    uint32 uiFlashOfDarknessTimer;
+
+    void Reset()
+    {
+        uiFlashOfDarknessTimer = 5000;
+    }
+
+    void MoveInLineOfSight(Unit* who)
+    {
+        if (Unit* pNovos = GetClosestCreatureWithEntry(m_creature, NPC_NOVOS, 85.0f))
+            m_creature->AI()->AttackStart(pNovos->getVictim());
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (uiFlashOfDarknessTimer <= diff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_FLASH_OF_DARKNESS : H_SPELL_FLASH_OF_DARKNESS);
+            uiFlashOfDarknessTimer = 5000;
+        } else uiFlashOfDarknessTimer -= diff;
+    }
+
+    void JustDied()
+    {
+        if (Creature* pDeadTrigger = m_creature->SummonCreature(NPC_TRIGGER_TARGET,0,0,0,0,TEMPSUMMON_TIMED_OR_DEAD_DESPAWN,10000))
+        {
+            if (Unit* pTarget = GetClosestCreatureWithEntry(m_creature, NPC_CRYSTAL_CHANNEL, 85.0f))
+            {
+                pDeadTrigger->CastSpell(pTarget, SPELL_DEAD_EFFECT, true);
+            }
+        }
+        if (Creature* pTrigger = GetClosestCreatureWithEntry(m_creature, NPC_CRYSTAL_CHANNEL, 85.0f))
+            pTrigger->ForcedDespawn();
+
+        if (Creature* pNovos = GetClosestCreatureWithEntry(m_creature, NPC_NOVOS, 85.0f))
+            ((boss_novosAI*)pNovos->AI())->RemoveCrystal();
+    }
+};
+
+struct MANGOS_DLL_DECL crystal_channelAI : public ScriptedAI
+{
+    crystal_channelAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        Reset();
+    }
+
+    uint32 Check_Timer;
+
+    void Reset()
+    {
+        Check_Timer = 1000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (Check_Timer < uiDiff)
+        {
+            Creature* pNovos =  GetClosestCreatureWithEntry(m_creature, NPC_NOVOS, 85.0f);
+            if (Creature* pTarget = GetClosestCreatureWithEntry(m_creature, NPC_CRYSTAL_CHANNEL_TARGET , 85.0f))
+                if (((boss_novosAI*)pNovos->AI())->Phase1 == true)
+                    DoCast(pTarget, SPELL_EFFECT, true);
+                else
+                    pTarget->ForcedDespawn();
+            Check_Timer = 1000;
+        }else Check_Timer -= uiDiff;
+    }
+};
+
+struct MANGOS_DLL_DECL mob_novos_minionAI : public ScriptedAI
+{
+    mob_novos_minionAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+    
+    uint32 Check_Timer;
+    uint32 creatureEntry;
+
+    void Reset()
+    {
+        Check_Timer = 1000;
+        creatureEntry = m_creature->GetEntry();
     }
 
     void UpdateAI(const uint32 uiDiff)
@@ -75,7 +405,24 @@ struct MANGOS_DLL_DECL boss_novosAI : public ScriptedAI
         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
             return;
 
-        DoMeleeAttackIfReady();
+        // achiev check
+        if (Creature* pNovos = GetClosestCreatureWithEntry(m_creature, NPC_NOVOS, 85.0f))
+            if(((boss_novosAI*)pNovos->AI())->Phase1 == true && ((boss_novosAI*)pNovos->AI())->Phase2 == false)
+                if(m_bIsAchiev && m_creature->GetPositionY() > -770.0f)
+                    m_bIsAchiev = false;
+
+        switch (creatureEntry)
+        {
+        case NPC_RISEN_SHADOWCASTER:
+            if (Check_Timer < uiDiff)
+            {
+                DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_SHADOW_BOLT : H_SPELL_SHADOW_BOLT);
+                Check_Timer = 1000;
+            }else Check_Timer -= uiDiff;
+            break;
+        default:
+            DoMeleeAttackIfReady();
+        }
     }
 };
 
@@ -84,6 +431,21 @@ CreatureAI* GetAI_boss_novos(Creature* pCreature)
     return new boss_novosAI(pCreature);
 }
 
+CreatureAI* GetAI_mob_novos_minionAI(Creature* pCreature)
+{
+    return new mob_novos_minionAI(pCreature);
+}
+
+CreatureAI* GetAI_crystal_handler(Creature* pCreature)
+{
+    return new crystal_handlerAI(pCreature);
+}
+
+CreatureAI* GetAI_crystal_channel(Creature* pCreature)
+{
+    return new crystal_channelAI(pCreature);
+}
+
 void AddSC_boss_novos()
 {
     Script *newscript;
@@ -92,4 +454,19 @@ void AddSC_boss_novos()
     newscript->Name = "boss_novos";
     newscript->GetAI = &GetAI_boss_novos;
     newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "crystal_handler";
+    newscript->GetAI = &GetAI_crystal_handler;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "crystal_channel";
+    newscript->GetAI = &GetAI_crystal_channel;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_novos_minionAI";
+    newscript->GetAI = &GetAI_mob_novos_minionAI;
+    newscript->RegisterSelf();
 }
diff --git a/scripts/northrend/draktharon_keep/boss_tharonja.cpp b/scripts/northrend/draktharon_keep/boss_tharonja.cpp
index 4ab7b8a..6ee1720 100644
--- a/scripts/northrend/draktharon_keep/boss_tharonja.cpp
+++ b/scripts/northrend/draktharon_keep/boss_tharonja.cpp
@@ -22,6 +22,7 @@ SDCategory: Drak'Tharon Keep
 EndScriptData */
 
 #include "precompiled.h"
+#include "draktharon_keep.h"
 
 enum
 {
@@ -32,7 +33,53 @@ enum
     SAY_FLESH_2                     = -1600016,
     SAY_SKELETON_1                  = -1600017,
     SAY_SKELETON_2                  = -1600018,
-    SAY_DEATH                       = -1600019
+    SAY_DEATH                       = -1600019,
+
+    //Phase 1 (Skeleton) Spells
+    SPELL_CURSE_OF_LIFE                 = 49527,
+    H_SPELL_CURSE_OF_LIFE               = 59972,
+
+    SPELL_SHADOW_VOLLEY                 = 49528,
+    H_SPELL_SHADOW_VOLLEY               = 59973,
+    SPELL_RAIN_OF_FIRE                  = 49518,
+    H_SPELL_RAIN_OF_FIRE                = 59971,
+    
+    SPELL_DECAY_FLESH                   = 49356,            //not working
+
+    //Phase 2 (Flesh) Spells
+    SPELL_GIFT_OF_THARONJA              = 52509,
+
+    SPELL_LIGHTNING_BREATH              = 49537,
+    H_SPELL_LIGHTNING_BREATH            = 59936,
+    SPELL_EYE_BEAM                      = 49544,
+    H_SPELL_EYE_BEAM                    = 59965,
+
+    SPELL_POISON_CLOUD                  = 49548,
+    H_SPELL_POSION_CLOUD                = 59969,
+    
+    SPELL_RETURN_FLESH                  = 53463,                //not working
+
+    NPC_DRAKURU                         = 28016,
+    NPC_LICH_KING                       = 28498,
+
+    ACHIEV_DTK_H                        = 493,
+    ACHIEV_DTK                          = 482,
+};
+
+//Phasses
+enum Phase
+{
+    PHASE_SKELETON                      =   0,
+    PHASE_INTOFLESH                     =   1,
+    PHASE_FLESH                         =   2,
+    PHASE_INTOSKELETON                  =   3,
+};
+
+enum PhaseChangeTimer
+{
+    PHASE_CHANGE_SKELETON               = 12000,
+    PHASE_CHANGE_REAL                   = 6000,
+    PHASE_CHANGE_FLESH                  = 20000
 };
 
 /*######
@@ -51,13 +98,30 @@ struct MANGOS_DLL_DECL boss_tharonjaAI : public ScriptedAI
     ScriptedInstance* m_pInstance;
     bool m_bIsRegularMode;
 
+    uint32 PhaseChangeTimer;
+    uint32 Phase;
+    uint32 CurseOfLife_Timer;
+    uint32 SkeletonSpells_Timer;
+    uint32 PoisonCloud_Timer;
+    uint32 FleshSpells_Timer;
+
     void Reset()
     {
+        PhaseChangeTimer = PHASE_CHANGE_SKELETON;
+        Phase = PHASE_SKELETON;
+        SkeletonSpells_Timer = urand (5000, 10000);
+        CurseOfLife_Timer = urand (5000, 10000);
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_THARONJA, NOT_STARTED);
     }
 
     void Aggro(Unit* pWho)
     {
         DoScriptText(SAY_AGGRO, m_creature);
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_THARONJA, IN_PROGRESS);
     }
 
     void KilledUnit(Unit* pVictim)
@@ -68,6 +132,14 @@ struct MANGOS_DLL_DECL boss_tharonjaAI : public ScriptedAI
     void JustDied(Unit* pKiller)
     {
         DoScriptText(SAY_DEATH, m_creature);
+
+        if (m_pInstance && m_pInstance->GetData(TYPE_DRED) == DONE && m_pInstance->GetData(TYPE_NOVOS) == DONE)
+        {
+            m_pInstance->SetData(TYPE_THARONJA, DONE);
+
+            // Complete achiev for Tharonja
+            m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_DTK : ACHIEV_DTK_H);
+        }
     }
 
     void UpdateAI(const uint32 uiDiff)
@@ -75,6 +147,92 @@ struct MANGOS_DLL_DECL boss_tharonjaAI : public ScriptedAI
         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
             return;
 
+        if (Phase == PHASE_SKELETON)
+        {
+            if (CurseOfLife_Timer < uiDiff)
+            {
+                DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_CURSE_OF_LIFE : H_SPELL_CURSE_OF_LIFE);
+                CurseOfLife_Timer = urand (5000, 10000);
+            }else CurseOfLife_Timer -= uiDiff;
+
+            if (SkeletonSpells_Timer < uiDiff)
+            {     
+                switch(urand(0, 1))
+                {
+                    case 0: 
+                        DoCast(m_creature->getVictim(),  m_bIsRegularMode ? SPELL_SHADOW_VOLLEY : H_SPELL_SHADOW_VOLLEY);
+                    case 1: 
+                        DoCast(m_creature->getVictim(),  m_bIsRegularMode ? SPELL_RAIN_OF_FIRE : H_SPELL_RAIN_OF_FIRE);
+                }
+                SkeletonSpells_Timer = urand (5000, 10000);
+            }else SkeletonSpells_Timer -= uiDiff;
+
+            if (PhaseChangeTimer < uiDiff)
+            {
+                m_creature->CastSpell(m_creature, SPELL_DECAY_FLESH, true);
+                PhaseChangeTimer = PHASE_CHANGE_REAL;
+                Phase = PHASE_INTOFLESH;
+            }else PhaseChangeTimer -= uiDiff;
+            
+            DoMeleeAttackIfReady();
+        }
+        
+        if (Phase == PHASE_INTOFLESH)
+        {
+            if (PhaseChangeTimer < uiDiff)
+            {
+                m_creature->CastSpell(m_creature, SPELL_GIFT_OF_THARONJA, true);
+                m_creature->SetDisplayId(27073);
+                PhaseChangeTimer = PHASE_CHANGE_FLESH;
+                Phase = PHASE_FLESH;
+                FleshSpells_Timer = 1500;
+                PoisonCloud_Timer = 10000;
+            }else PhaseChangeTimer -= uiDiff;
+        }
+        
+        if (Phase == PHASE_FLESH)
+        {
+            if (PhaseChangeTimer < uiDiff)
+            {
+                DoCast(m_creature, SPELL_RETURN_FLESH);
+                PhaseChangeTimer = PHASE_CHANGE_REAL;
+                Phase = PHASE_INTOSKELETON;
+            }else PhaseChangeTimer -= uiDiff;
+
+            if (PoisonCloud_Timer < uiDiff)
+            {
+                DoCast(SelectUnit(SELECT_TARGET_RANDOM, 0),  m_bIsRegularMode ? SPELL_POISON_CLOUD : H_SPELL_POSION_CLOUD);
+                PoisonCloud_Timer = 10000;
+            }else PoisonCloud_Timer -= uiDiff;
+
+            if (FleshSpells_Timer < uiDiff)
+            {     
+                switch(urand(0, 3))
+                {
+                    case 0:
+                    case 1:
+                    case 2:
+                        DoCast(SelectUnit(SELECT_TARGET_RANDOM, 0),  m_bIsRegularMode ? SPELL_LIGHTNING_BREATH : H_SPELL_LIGHTNING_BREATH);
+                    case 3: 
+                        DoCast(SelectUnit(SELECT_TARGET_RANDOM, 0),  m_bIsRegularMode ? SPELL_EYE_BEAM : SPELL_EYE_BEAM);
+                }
+                FleshSpells_Timer = 1500;
+            }else FleshSpells_Timer -= uiDiff;
+        }
+        
+        if (Phase == PHASE_INTOSKELETON)
+        {
+            if (PhaseChangeTimer < uiDiff)
+            {
+                DoCast(m_creature, SPELL_DECAY_FLESH);
+                m_creature->SetDisplayId(27072);
+                PhaseChangeTimer = PHASE_CHANGE_SKELETON;
+                Phase = PHASE_SKELETON;
+                SkeletonSpells_Timer = urand (5000, 10000);
+                CurseOfLife_Timer = urand (5000, 10000);
+            }else PhaseChangeTimer -= uiDiff;
+        }
+
         DoMeleeAttackIfReady();
     }
 };
diff --git a/scripts/northrend/draktharon_keep/boss_trollgore.cpp b/scripts/northrend/draktharon_keep/boss_trollgore.cpp
index ff65e4e..28d7e33 100644
--- a/scripts/northrend/draktharon_keep/boss_trollgore.cpp
+++ b/scripts/northrend/draktharon_keep/boss_trollgore.cpp
@@ -22,6 +22,7 @@ SDCategory: Drak'Tharon Keep
 EndScriptData */
 
 #include "precompiled.h"
+#include "draktharon_keep.h"
 
 enum
 {
@@ -29,9 +30,30 @@ enum
     SAY_CONSUME                     = -1600001,
     SAY_DEATH                       = -1600002,
     SAY_EXPLODE                     = -1600003,
-    SAY_KILL                        = -1600004
+    SAY_KILL                        = -1600004,
+
+    SPELL_CRUSH                         = 49639,
+    SPELL_INFECTED_WOUND                = 49367,
+    SPELL_CORPSE_EXPLODE                = 49555,
+    H_SPELL_CORPSE_EXPLODE              = 59087,
+    SPELL_CONSUME                       = 49380,
+    H_SPELL_CONSUME                     = 59803,
+    SPELL_CONSUME_BUFF                  = 49381,
+    H_SPELL_CONSUME_BUFF                = 59805,
+
+    SPELL_CORPSE_EXPLODE_PROC           = 49618,
+    H_SPELL_CORPSE_EXPLODE_PROC         = 59809,
+
+    NPC_DRAKKARI_INVADER                = 27753,
+    NPC_TROLLGORE                       = 26630,
+
+    ACHIEV_CONSUMPTION_JUNCTION         = 2151,
 };
 
+const float PosSummon1[3] = {-259.59f, -652.49f, 26.52f};
+const float PosSummon2[3] = {-261.60f, -658.71f, 26.51f};
+const float PosSummon3[3] = {-262.05f, -665.71f, 26.49f};
+
 /*######
 ## boss_trollgore
 ######*/
@@ -48,13 +70,35 @@ struct MANGOS_DLL_DECL boss_trollgoreAI : public ScriptedAI
     ScriptedInstance* m_pInstance;
     bool m_bIsRegularMode;
 
+    uint32 Consume_Timer;
+    uint32 Crush_Timer;
+    uint32 InfectedWound_Timer;
+    uint32 Wave_Timer;
+    uint32 CorpseExplode_Timer;
+    bool bAchiev;
+
     void Reset()
     {
+        CorpseExplode_Timer = 10000;
+        Consume_Timer = 5000;
+        Crush_Timer = 10000;
+        InfectedWound_Timer = 30000;
+        Wave_Timer = 2000;
+        bAchiev = true;
+
+        if (m_creature->HasAura(m_bIsRegularMode ? SPELL_CONSUME : H_SPELL_CONSUME))
+            m_creature->RemoveAurasDueToSpell(m_bIsRegularMode ? SPELL_CONSUME : H_SPELL_CONSUME);
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_TROLLGORE, NOT_STARTED);
     }
 
     void Aggro(Unit* pWho)
     {
         DoScriptText(SAY_AGGRO, m_creature);
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_TROLLGORE, IN_PROGRESS);
     }
 
     void KilledUnit(Unit* pVictim)
@@ -66,6 +110,25 @@ struct MANGOS_DLL_DECL boss_trollgoreAI : public ScriptedAI
     void JustDied(Unit* pKiller)
     {
         DoScriptText(SAY_DEATH, m_creature);
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_TROLLGORE, DONE);
+
+        if (bAchiev && !m_bIsRegularMode)
+        {
+            if(m_pInstance)
+                m_pInstance->DoCompleteAchievement(ACHIEV_CONSUMPTION_JUNCTION);
+        }
+    }
+
+    void SummonWaves()
+    {
+        if (Creature* pInvader1 = m_creature->SummonCreature(NPC_DRAKKARI_INVADER,PosSummon1[0],PosSummon1[1],PosSummon1[2],0, TEMPSUMMON_TIMED_DESPAWN, 15000))
+            pInvader1->AI()->AttackStart(m_creature);
+        if (Creature* pInvader2 = m_creature->SummonCreature(NPC_DRAKKARI_INVADER,PosSummon2[0],PosSummon2[1],PosSummon2[2],0, TEMPSUMMON_TIMED_DESPAWN, 15000))
+            pInvader2->AI()->AttackStart(m_creature);
+        if (Creature* pInvader3 = m_creature->SummonCreature(NPC_DRAKKARI_INVADER,PosSummon3[0],PosSummon3[1],PosSummon3[2],0, TEMPSUMMON_TIMED_DESPAWN, 15000))
+            pInvader3->AI()->AttackStart(m_creature);
     }
 
     void UpdateAI(const uint32 uiDiff)
@@ -73,6 +136,70 @@ struct MANGOS_DLL_DECL boss_trollgoreAI : public ScriptedAI
         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
             return;
 
+        // Crush
+        if (Crush_Timer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_CRUSH);
+            Crush_Timer = 10000;
+        }else Crush_Timer -= uiDiff;
+
+        // Infected Wound
+        if (InfectedWound_Timer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_CRUSH);
+            InfectedWound_Timer = 30000;
+        }else InfectedWound_Timer -= uiDiff;
+
+        // Summon npcs
+        if (Wave_Timer < uiDiff)
+        {
+            SummonWaves();
+            Wave_Timer = 15000;
+        }else Wave_Timer -= uiDiff;
+
+        // Consume
+        if (Consume_Timer < uiDiff)
+        {
+            m_creature->CastSpell(m_creature->getVictim(),  m_bIsRegularMode ? SPELL_CONSUME : H_SPELL_CONSUME, true);
+            m_creature->CastSpell(m_creature, m_bIsRegularMode ? SPELL_CONSUME_BUFF : H_SPELL_CONSUME_BUFF, true);
+            Consume_Timer = 15000;
+        }else Consume_Timer -= uiDiff;
+
+        //Corpse Explosion
+        if (CorpseExplode_Timer < uiDiff)
+        {
+            //DoCast(m_creature->getVictim(),  m_bIsRegularMode ? SPELL_CORPSE_EXPLODE : H_SPELL_CORPSE_EXPLODE);
+
+            if (Creature* pCorpse = GetClosestCreatureWithEntry(m_creature, NPC_DRAKKARI_INVADER, 85.0f))
+            {
+                if (!pCorpse->isAlive())
+                {                    
+                    Map *map = pCorpse->GetMap();
+                    if (map->IsDungeon())
+                    {            
+                        Map::PlayerList const &PlayerList = map->GetPlayers();
+
+                        if (PlayerList.isEmpty())
+                            return;
+
+                        for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                        {
+                            if (i->getSource()->isAlive() && pCorpse->GetDistance2d(i->getSource()->GetPositionX(), i->getSource()->GetPositionY()) <= 5)
+                                m_creature->DealDamage(i->getSource(), (m_bIsRegularMode ? urand(3770, 4230) : urand(9425, 10575)), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NATURE, NULL, false);
+                        }
+                    }
+                }
+            }
+            CorpseExplode_Timer = 15000;
+        }else CorpseExplode_Timer -= uiDiff;
+
+        if (bAchiev)
+        {
+            Aura *pConsumeAura = m_creature->GetAura(m_bIsRegularMode ? SPELL_CONSUME_BUFF : H_SPELL_CONSUME_BUFF, EFFECT_INDEX_0);
+            if (pConsumeAura && pConsumeAura->GetStackAmount() > 9)
+                bAchiev = false;
+        }
+
         DoMeleeAttackIfReady();
     }
 };
diff --git a/scripts/northrend/draktharon_keep/draktharon_keep.h b/scripts/northrend/draktharon_keep/draktharon_keep.h
new file mode 100644
index 0000000..9e83d75
--- /dev/null
+++ b/scripts/northrend/draktharon_keep/draktharon_keep.h
@@ -0,0 +1,40 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software licensed under GPL version 2
+ * Please see the included DOCS/LICENSE.TXT for more information */
+
+#ifndef DEF_DRAKTHARON_H
+#define DEF_DRAKTHARON_H
+
+enum
+{
+    MAX_ENCOUNTER                 = 5,
+
+    TYPE_TROLLGORE              = 1,
+    TYPE_NOVOS                  = 2,
+    TYPE_DRED                   = 3,
+    TYPE_THARONJA               = 4,
+
+    DATA_TROLLGORE                = 1,
+    DATA_NOVOS                    = 2,
+    DATA_DRED                     = 3,
+    DATA_THARONJA                 = 4,
+
+    TYPE_CRYSTAL_1                = 5,
+    TYPE_CRYSTAL_2                = 6,
+    TYPE_CRYSTAL_3                = 7,
+    TYPE_CRYSTAL_4                = 8,
+    TYPE_NOVOS_PHASE2_CHECK       = 9,
+    TYPE_NOVOS_EVENT              = 10,
+
+    NPC_CRYSTAL_CHANNEL_TARGET    = 26710,
+    NPC_CRYSTAL_CHANNEL           = 26712,
+    NPC_TRIGGER_TARGET            = 26714,
+    NPC_NOVOS                     = 26631,
+    
+    NPC_CRYSTAL_HANDLER           = 26627,
+    NPC_HULKING_CORPSE            = 27597,
+    NPC_FETID_TROLL_CORPSE        = 27598,
+    NPC_RISEN_SHADOWCASTER        = 27600
+};
+
+#endif
\ No newline at end of file
diff --git a/scripts/northrend/draktharon_keep/instance_draktharon_keep.cpp b/scripts/northrend/draktharon_keep/instance_draktharon_keep.cpp
new file mode 100644
index 0000000..2cdeaa6
--- /dev/null
+++ b/scripts/northrend/draktharon_keep/instance_draktharon_keep.cpp
@@ -0,0 +1,233 @@
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "precompiled.h"
+#include "draktharon_keep.h"
+
+#define MAX_ENCOUNTER     4
+
+/* Drak'Tharon Keep encounters:
+0 - Trollgore
+1 - Novos
+2 - King Dred
+3 - Tharon Ja
+*/
+
+enum Creatures
+{
+    NPC_TROLLGORE                                          = 26630,
+    NPC_KING_DRED                                          = 27483,
+    NPC_THARON_JA                                          = 26632
+};
+enum GameObjects
+{
+    GO_NOVOS_CRYSTAL_1                                     = 189299,
+    GO_NOVOS_CRYSTAL_2                                     = 189300,
+    GO_NOVOS_CRYSTAL_3                                     = 189301,
+    GO_NOVOS_CRYSTAL_4                                     = 189302
+};
+
+struct MANGOS_DLL_DECL instance_draktharon : public ScriptedInstance
+{
+    instance_draktharon(Map* pMap) : ScriptedInstance(pMap) {Initialize();};
+
+    uint8 uiDredAchievCounter;
+
+    uint64 uiTrollgore;
+    uint64 uiNovos;
+    uint64 uiDred;
+    uint64 uiTharonJa;
+
+    uint64 uiNovosCrystal1;
+    uint64 uiNovosCrystal2;
+    uint64 uiNovosCrystal3;
+    uint64 uiNovosCrystal4;
+
+    uint8 m_auiEncounter[MAX_ENCOUNTER];
+
+    std::string str_data;
+
+    void Initialize()
+    {
+        uiTrollgore = 0;
+        uiNovos = 0;
+        uiDred = 0;
+        uiTharonJa = 0;
+        uiNovosCrystal1 = 0;
+        uiNovosCrystal2 = 0;
+        uiNovosCrystal3 = 0;
+        uiNovosCrystal4 = 0;
+        uiDredAchievCounter = 0;
+    }
+
+    bool IsEncounterInProgress() const
+    {
+        for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+            if (m_auiEncounter[i] == IN_PROGRESS) return true;
+
+        return false;
+    }
+
+    void OnGameObjectCreate(GameObject* pGo, bool add)
+    {
+        switch(pGo->GetEntry())
+        {
+            case GO_NOVOS_CRYSTAL_1:
+                uiNovosCrystal1 = pGo->GetGUID();
+                break;
+            case GO_NOVOS_CRYSTAL_2:
+                uiNovosCrystal2 = pGo->GetGUID();
+                break;
+            case GO_NOVOS_CRYSTAL_3:
+                uiNovosCrystal3 = pGo->GetGUID();
+                break;
+            case GO_NOVOS_CRYSTAL_4:
+                uiNovosCrystal4 = pGo->GetGUID();
+                break;
+        }
+    }
+
+    void OnCreatureCreate(Creature* pCreature, bool add)
+    {
+        switch(pCreature->GetEntry())
+        {
+            case NPC_TROLLGORE:
+                uiTrollgore = pCreature->GetGUID();
+                break;
+            case NPC_NOVOS:
+                uiNovos = pCreature->GetGUID();
+                break;
+            case NPC_KING_DRED:
+                uiDred = pCreature->GetGUID();
+                break;
+            case NPC_THARON_JA:
+                uiTharonJa = pCreature->GetGUID();
+                break;
+        }
+    }
+
+    void SetData(uint32 type, uint32 data)
+    {
+        switch(type)
+        {
+            case TYPE_TROLLGORE:
+                m_auiEncounter[0] = data;
+                break;
+            case TYPE_NOVOS:
+                m_auiEncounter[1] = data;
+                break;
+            case TYPE_DRED:
+                m_auiEncounter[2] = data;
+                break;
+            case TYPE_THARONJA:
+                m_auiEncounter[3] = data;
+                break;
+        }
+
+        if (data == DONE)
+        {
+            SaveToDB();
+        }
+    }
+
+    uint32 GetData(uint32 type)
+    {
+        switch (type)
+        {
+            case TYPE_TROLLGORE:    return m_auiEncounter[0];
+            case TYPE_NOVOS:        return m_auiEncounter[1];
+            case TYPE_DRED:         return m_auiEncounter[2];
+            case TYPE_THARONJA:     return m_auiEncounter[3];
+        }
+        return 0;
+    }
+
+    uint64 GetData64(uint32 identifier)
+    {
+        switch(identifier)
+        {
+            case TYPE_CRYSTAL_1:    return uiNovosCrystal1;
+            case TYPE_CRYSTAL_2:    return uiNovosCrystal2;
+            case TYPE_CRYSTAL_3:    return uiNovosCrystal3;
+            case TYPE_CRYSTAL_4:    return uiNovosCrystal4;
+        }
+
+        return 0;
+    }
+
+    std::string GetSaveData()
+    {
+        OUT_SAVE_INST_DATA;
+
+        std::string str_data;
+
+        std::ostringstream saveStream;
+        saveStream << "D K " << m_auiEncounter[0] << " " << m_auiEncounter[1] << " "
+            << m_auiEncounter[2] << " " << m_auiEncounter[3];
+
+        str_data = saveStream.str();
+
+        OUT_SAVE_INST_DATA_COMPLETE;
+        return str_data;
+    }
+
+    void Load(const char* in)
+    {
+        if (!in)
+        {
+            OUT_LOAD_INST_DATA_FAIL;
+            return;
+        }
+
+        OUT_LOAD_INST_DATA(in);
+
+        char dataHead1, dataHead2;
+        uint16 data0,data1,data2,data3;
+
+        std::istringstream loadStream(in);
+        loadStream >> dataHead1 >> dataHead2 >> data0 >> data1 >> data2 >> data3;
+
+        if (dataHead1 == 'D' && dataHead2 == 'K')
+        {
+            m_auiEncounter[0] = data0;
+            m_auiEncounter[1] = data1;
+            m_auiEncounter[2] = data2;
+            m_auiEncounter[3] = data3;
+
+            for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+                if (m_auiEncounter[i] == IN_PROGRESS)
+                    m_auiEncounter[i] = NOT_STARTED;
+        } else OUT_LOAD_INST_DATA_FAIL;
+
+        OUT_LOAD_INST_DATA_COMPLETE;
+    }
+};
+
+InstanceData* GetInstanceData_instance_draktharon(Map* pMap)
+{
+    return new instance_draktharon(pMap);
+}
+
+void AddSC_instance_draktharon()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "instance_draktharon";
+    newscript->GetInstanceData = &GetInstanceData_instance_draktharon;
+    newscript->RegisterSelf();
+}
diff --git a/sql/Custom_Updates/Mangos/Northrend/DraktharonKeep_Mangos.sql b/sql/Custom_Updates/Mangos/Northrend/DraktharonKeep_Mangos.sql
new file mode 100644
index 0000000..95d6079
--- /dev/null
+++ b/sql/Custom_Updates/Mangos/Northrend/DraktharonKeep_Mangos.sql
@@ -0,0 +1,7 @@
+/* DRAKTHARON KEEP */
+update instance_template set script = 'instance_draktharon' where map = 600;
+UPDATE creature_template SET ScriptName = "boss_dred" WHERE entry = 27483;
+UPDATE creature_template SET ScriptName = "mob_dred_raptor" WHERE entry in (26641, 26628);
+UPDATE creature_template SET ScriptName = "mob_novos_minionAI" WHERE entry in (27597, 27598, 27600);
+UPDATE creature_template SET ScriptName = "crystal_handler" WHERE entry = 26627;
+UPDATE creature_template SET ScriptName = "crystal_channel" WHERE entry = 26712;
\ No newline at end of file
diff --git a/system/ScriptLoader.cpp b/system/ScriptLoader.cpp
index c041f93..cf036ee 100644
--- a/system/ScriptLoader.cpp
+++ b/system/ScriptLoader.cpp
@@ -267,9 +267,11 @@ extern void AddSC_boss_jaraxxus();
 extern void AddSC_boss_anubarak_trial();
 extern void AddSC_twin_valkyr();
 extern void AddSC_instance_trial_of_the_crusader();
-extern void AddSC_boss_novos();                             //draktharon_keep
+extern void AddSC_boss_dred();                              //draktharon_keep
+extern void AddSC_boss_novos();                             
 extern void AddSC_boss_tharonja();
 extern void AddSC_boss_trollgore();
+extern void AddSC_instance_draktharon();
 extern void AddSC_boss_colossus();                          //gundrak
 extern void AddSC_boss_eck();
 extern void AddSC_boss_galdarah();
@@ -703,9 +705,11 @@ void AddScripts()
     AddSC_boss_anubarak_trial();
     AddSC_twin_valkyr();
     AddSC_instance_trial_of_the_crusader();
-    AddSC_boss_novos();                                     //draktharon_keep
+    AddSC_boss_dred();                                      //draktharon_keep
+    AddSC_boss_novos();                                      
     AddSC_boss_tharonja();
     AddSC_boss_trollgore();
+    AddSC_instance_draktharon();
     AddSC_boss_colossus();                                  //gundrak
     AddSC_boss_eck();
     AddSC_boss_galdarah();
