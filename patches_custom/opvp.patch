
<!-- saved from url=(0086)https://github.com/xfurry/Mangos/commit/011d70984e81a66ba371672b36a2ce8fb37f4ae6.patch -->
<html><body><pre style="word-wrap: break-word; white-space: pre-wrap;">From 011d70984e81a66ba371672b36a2ce8fb37f4ae6 Mon Sep 17 00:00:00 2001
From: Xfurry &lt;radu_cantor@yahoo.com&gt;
Date: Thu, 18 Nov 2010 20:53:59 +0200
Subject: [PATCH] Outdoor PvP for Mangos 10731

Based on the work of Balrok and UnkleNuke
---
 sql/custom_updates/outdoor_pvp.sql |  120 ++++++
 src/game/Creature.cpp              |   19 +
 src/game/Creature.h                |    2 +
 src/game/GameObject.cpp            |   59 +++-
 src/game/GameObject.h              |   23 +-
 src/game/GossipDef.h               |    2 +
 src/game/Language.h                |   67 ++++
 src/game/Makefile.am               |   20 +-
 src/game/MiscHandler.cpp           |    7 +
 src/game/Object.cpp                |   14 +-
 src/game/Object.h                  |    5 +
 src/game/ObjectMgr.cpp             |  151 +++++++
 src/game/ObjectMgr.h               |    3 +
 src/game/OutdoorPvP.cpp            |  683 ++++++++++++++++++++++++++++++++
 src/game/OutdoorPvP.h              |  261 ++++++++++++
 src/game/OutdoorPvPEP.cpp          |  764 ++++++++++++++++++++++++++++++++++++
 src/game/OutdoorPvPEP.h            |  279 +++++++++++++
 src/game/OutdoorPvPGH.cpp          |  234 +++++++++++
 src/game/OutdoorPvPGH.h            |  190 +++++++++
 src/game/OutdoorPvPHP.cpp          |  332 ++++++++++++++++
 src/game/OutdoorPvPHP.h            |  117 ++++++
 src/game/OutdoorPvPImpl.h          |   28 ++
 src/game/OutdoorPvPMgr.cpp         |  272 +++++++++++++
 src/game/OutdoorPvPMgr.h           |   84 ++++
 src/game/OutdoorPvPNA.cpp          |  666 +++++++++++++++++++++++++++++++
 src/game/OutdoorPvPNA.h            |  296 ++++++++++++++
 src/game/OutdoorPvPSI.cpp          |  226 +++++++++++
 src/game/OutdoorPvPSI.h            |   74 ++++
 src/game/OutdoorPvPTF.cpp          |  311 +++++++++++++++
 src/game/OutdoorPvPTF.h            |  116 ++++++
 src/game/OutdoorPvPZM.cpp          |  430 ++++++++++++++++++++
 src/game/OutdoorPvPZM.h            |  218 ++++++++++
 src/game/Player.cpp                |  250 +++++++++---
 src/game/Player.h                  |   10 +
 src/game/SharedDefines.h           |   11 +-
 src/game/SpellAuras.cpp            |    3 +
 src/game/SpellEffects.cpp          |    8 +
 src/game/Unit.cpp                  |    5 +
 src/game/Unit.h                    |    3 +-
 src/game/World.cpp                 |    7 +
 src/game/ZoneScript.h              |   51 +++
 win/VC90/game.vcproj               |   80 ++++
 42 files changed, 6426 insertions(+), 75 deletions(-)
 create mode 100644 sql/custom_updates/outdoor_pvp.sql
 create mode 100644 src/game/OutdoorPvP.cpp
 create mode 100644 src/game/OutdoorPvP.h
 create mode 100644 src/game/OutdoorPvPEP.cpp
 create mode 100644 src/game/OutdoorPvPEP.h
 create mode 100644 src/game/OutdoorPvPGH.cpp
 create mode 100644 src/game/OutdoorPvPGH.h
 create mode 100644 src/game/OutdoorPvPHP.cpp
 create mode 100644 src/game/OutdoorPvPHP.h
 create mode 100644 src/game/OutdoorPvPImpl.h
 create mode 100644 src/game/OutdoorPvPMgr.cpp
 create mode 100644 src/game/OutdoorPvPMgr.h
 create mode 100644 src/game/OutdoorPvPNA.cpp
 create mode 100644 src/game/OutdoorPvPNA.h
 create mode 100644 src/game/OutdoorPvPSI.cpp
 create mode 100644 src/game/OutdoorPvPSI.h
 create mode 100644 src/game/OutdoorPvPTF.cpp
 create mode 100644 src/game/OutdoorPvPTF.h
 create mode 100644 src/game/OutdoorPvPZM.cpp
 create mode 100644 src/game/OutdoorPvPZM.h
 create mode 100644 src/game/ZoneScript.h

diff --git a/sql/custom_updates/outdoor_pvp.sql b/sql/custom_updates/outdoor_pvp.sql
new file mode 100644
index 0000000..5cbe700
--- /dev/null
+++ b/sql/custom_updates/outdoor_pvp.sql
@@ -0,0 +1,120 @@
+/*
+-- Outdoor PvP SQL data for UDB. Import into 'mangos' database. --
+*/
+
+-- del GOs
+-- DELETE FROM gameobject_respawn WHERE guid IN (SELECT guid FROM gameobject WHERE id IN (182267, 182280,182281,182282,182222,182272,182273,182274,182266,182275,182276,182277,182301,182302,182303,182304,182305,182306,182307,182308,182297,182298,182299,182300));
+DELETE FROM gameobject WHERE id IN (182267, 182280,182281,182282,182222,182272,182273,182274,182266,182275,182276,182277,182301,182302,182303,182304,182305,182306,182307,182308,182297,182298,182299,182300);
+
+-- del NPCs
+DELETE FROM creature_addon WHERE guid IN (select guid from creature WHERE id IN (18816,18821,21474,21484,21483,18192,18817,18822,21485,21487,21488,18256));
+-- DELETE FROM creature_respawn WHERE guid IN (select guid from creature WHERE id IN (18816,18821,21474,21484,21483,18192,18817,18822,21485,21487,21488,18256));
+DELETE FROM creature WHERE id IN (18816,18821,21474,21484,21483,18192,18817,18822,21485,21487,21488,18256);
+DELETE FROM creature where id in (27748, 27708, 29253, 27730, 29251, 27758, 27759, 29252,27760, 29250);
+
+-- creature template changes
+-- guards don't regen health
+UPDATE creature_template SET RegenHealth = 0 WHERE entry IN (18192,18256);
+--
+UPDATE creature_template SET faction_A = 1630, faction_H = 1630, ScriptName = 'mob_eventai' WHERE entry = 18225;
+
+-- pvp flag
+UPDATE creature_template SET unit_flags = unit_flags | 0x1000 WHERE entry IN (18816,18821,21474,21484,21483,18192,18817,18822,21485,21487,21488,18256);
+
+-- faction changes
+-- (destroyed) wyvern posts
+UPDATE gameobject_template SET faction = 84, flags = 0 WHERE entry IN (182266,182267,182275,182276,182277,182280,182281,182282);
+UPDATE gameobject_template SET faction = 83, flags = 0 WHERE entry IN (182297, 182298, 182299, 182300, 182301, 182302, 182303, 182304);
+-- bomb wagons
+UPDATE gameobject_template SET faction = 83, flags = 0 WHERE entry IN (182222, 182272, 182273, 182274); -- horde friendly
+UPDATE gameobject_template SET faction = 84, flags = 0 WHERE entry IN (182305, 182306, 182307, 182308); -- ally friendly
+
+UPDATE gameobject_template SET data0 = 0 WHERE entry IN (181598, 181597); -- without this, the client sends a spellcast packet on go use instead of use go packet
+UPDATE gameobject_template SET data0 = 0 WHERE entry = 181682;
+
+DELETE from gameobject WHERE id = 181682; -- DELETE the go that is spawned by the opvp
+DELETE from creature WHERE id = 17209; -- DELETE the flight master that is spawned by the opvp
+
+UPDATE creature_template SET faction_a = 83, faction_h = 83 WHERE entry = 17995; -- horde guards faction
+UPDATE creature_template SET faction_a = 83, faction_h = 83 WHERE entry = 17996;
+UPDATE creature_template SET faction_a = 84, faction_h = 84 WHERE entry = 17635; -- ally guards faction
+UPDATE creature_template SET faction_a = 84, faction_h = 84 WHERE entry = 17647;
+UPDATE creature_template SET faction_a = 84, faction_h = 83 WHERE entry = 17209; -- flight master
+UPDATE creature_template SET AIName = 'OutdoorPvPObjectiveAI', ScriptName = '' WHERE entry = 12999;
+UPDATE creature_template SET npcflag = npcflag | 536870912 WHERE entry IN (18564, 18581);
+
+DELETE FROM game_graveyard_zone WHERE id IN (969, 927, 993); -- DELETE na, za, epl pvp graveyard associations, they should only be available to the controlling faction
+
+UPDATE quest_template SET ReqSpellCast1 = 0, ReqSpellCast2 = 0, ReqSpellCast3 = 0, ReqSpellCast4 = 0 WHERE entry IN (9665, 9664); -- fix quests IN epl
+UPDATE quest_template SET reqspellcast1 = 0, reqspellcast2 = 0, reqspellcast3 = 0, reqspellcast4 = 0 WHERE entry in(9664,9665);
+
+DELETE FROM gameobject WHERE id IN (181899, 182096, 182097, 182173, 182174, 182175, 182210, 182522, 182523, 183104, 183411, 183412, 183413, 183414, 182098);
+DELETE FROM creature WHERE id IN (18564, 18581);
+
+-- DELETE FROM npc_option WHERE id = 51;
+-- INSERT INTO npc_option(id, gossip_id, npcflag, icon, action, option_text) VALUES (51,0,536870912,0,18,"UNIT_NPC_FLAG_OUTDOORPVP");
+
+
+DELETE FROM `mangos_string` WHERE `entry` BETWEEN 10001 AND 10055;
+INSERT INTO `mangos_string` (`entry`, `content_default`) VALUES
+-- hellfire peninsula
+(10001,'The Horde has taken The Overlook!'),
+(10002,'The Alliance has taken The Overlook!'),
+(10003,'The Horde has taken The Stadium!'),
+(10004,'The Alliance has taken The Stadium!'),
+(10005,'The Horde has taken Broken Hill!'),
+(10006,'The Alliance has taken Broken Hill!'),
+(10007,'The Horde lost The Overlook!'),
+(10008,'The Alliance lost The Overlook!'),
+(10009,'The Horde lost The Stadium!'),
+(10010,'The Alliance lost The Stadium!'),
+(10011,'The Horde lost Broken Hill!'),
+(10012,'The Alliance lost Broken Hill!'),
+-- zangarmarsh
+(10013,'The Horde has taken the West Beacon!'),
+(10014,'The Alliance has taken the West Beacon!'),
+(10015,'The Horde has taken the East Beacon!'),
+(10016,'The Alliance has taken the East Beacon!'),
+(10017,'The Horde has captured the Twin Spire Graveyard!'),
+(10018,'The Alliance has captured the Twin Spire Graveyard!'),
+(10019,'The Horde lost the West Beacon!'),
+(10020,'The Alliance lost the West Beacon!'),
+(10021,'The Horde lost the East Beacon!'),
+(10022,'The Alliance lost the East Beacon!'),
+(10023,'The Horde lost the Twin Spire Graveyard!'),
+(10024,'The Alliance lost the Twin Spire Graveyard!'),
+-- nagrand
+(10025,'The Horde has captured Halaa!'),
+(10026,'The Alliance has captured Halaa!'),
+(10027,'The Horde lost Halaa!'),
+(10028,'The Alliance lost Halaa!'),
+-- terokkar forest
+(10029,'The Horde has taken a Spirit Tower!'),
+(10030,'The Alliance has taken a Spirit Tower!'),
+(10031,'The Horde lost a Spirit Tower!'),
+(10032,'The Alliance lost a Spirit Tower!'),
+-- eastern plaguelands
+(10033,'The Horde has taken the Northpass Tower!'),
+(10034,'The Alliance has taken the Northpass Tower!'),
+(10035,'The Horde has taken the Eastwall Tower!'),
+(10036,'The Alliance has taken the Eastwall Tower!'),
+(10037,'The Horde has taken the Crown Guard Tower!'),
+(10038,'The Alliance has taken the Crown Guard Tower!'),
+(10039,'The Horde has taken the Plaguewood Tower!'),
+(10040,'The Alliance has taken the Plaguewood Tower!'),
+(10041,'The Horde lost the Northpass Tower!'),
+(10042,'The Alliance lost the Northpass Tower!'),
+(10043,'The Horde lost the Eastwall Tower!'),
+(10044,'The Alliance lost the Eastwall Tower!'),
+(10045,'The Horde lost the Crown Guard Tower!'),
+(10046,'The Alliance lost the Crown Guard Tower!'),
+(10047,'The Horde lost the Plaguewood Tower!'),
+(10048,'The Alliance lost the Plaguewood Tower!'),
+-- silithus
+(10049,'The Horde has collected 200 silithyst!'),
+(10050,'The Alliance has collected 200 silithyst!'),
+-- grizzly
+(10051, 'The Horde has taken the Venture Bay Lighthouse!'),
+(10052, 'The Alliance has taken the Venture Bay Lighthouse!'),
+(10053, 'The Horde lost the Venture Bay Lighthouse!'),
+(10054, 'The Alliance lost the Venture Bay Lighthouse!');
\ No newline at end of file
diff --git a/src/game/Creature.cpp b/src/game/Creature.cpp
index db43f90..ec7809c 100644
--- a/src/game/Creature.cpp
+++ b/src/game/Creature.cpp
@@ -37,6 +37,7 @@
 #include "WaypointMovementGenerator.h"
 #include "InstanceData.h"
 #include "BattleGroundMgr.h"
+#include "OutdoorPvPMgr.h"
 #include "Spell.h"
 #include "Util.h"
 #include "GridNotifiers.h"
@@ -152,7 +153,12 @@ void Creature::AddToWorld()
 {
     ///- Register the creature for guid lookup
     if(!IsInWorld() &amp;&amp; GetObjectGuid().GetHigh() == HIGHGUID_UNIT)
+    {
+        if(m_zoneScript)
+            m_zoneScript-&gt;OnCreatureCreate(this, true);
+
         GetMap()-&gt;GetObjectsStore().insert&lt;Creature&gt;(GetGUID(), (Creature*)this);
+    }
 
     Unit::AddToWorld();
 }
@@ -161,7 +167,12 @@ void Creature::RemoveFromWorld()
 {
     ///- Remove the creature from the accessor
     if(IsInWorld() &amp;&amp; GetObjectGuid().GetHigh() == HIGHGUID_UNIT)
+    {
+        if(m_zoneScript)
+            m_zoneScript-&gt;OnCreatureCreate(this, false);
+
         GetMap()-&gt;GetObjectsStore().erase&lt;Creature&gt;(GetGUID(), (Creature*)NULL);
+    }
 
     Unit::RemoveFromWorld();
 }
@@ -1174,6 +1185,14 @@ float Creature::GetSpellDamageMod(int32 Rank)
 
 bool Creature::CreateFromProto(uint32 guidlow, uint32 Entry, uint32 team, const CreatureData *data)
 {
+    SetZoneScript();
+    if(m_zoneScript &amp;&amp; data)
+    {
+        Entry = m_zoneScript-&gt;GetCreatureEntry(guidlow, data);
+        if(!Entry)
+            return false;
+    }
+
     CreatureInfo const *cinfo = ObjectMgr::GetCreatureTemplate(Entry);
     if(!cinfo)
     {
diff --git a/src/game/Creature.h b/src/game/Creature.h
index a357269..588ad49 100644
--- a/src/game/Creature.h
+++ b/src/game/Creature.h
@@ -171,6 +171,7 @@ struct EquipmentInfo
 // from `creature` table
 struct CreatureData
 {
+    explicit CreatureData() : dbData(true) {}
     uint32 id;                                              // entry in creature_template
     uint16 mapid;
     uint16 phaseMask;
@@ -188,6 +189,7 @@ struct CreatureData
     bool  is_dead;
     uint8 movementType;
     uint8 spawnMask;
+    bool dbData;
 };
 
 struct CreatureDataAddonAura
diff --git a/src/game/GameObject.cpp b/src/game/GameObject.cpp
index 6a693e8..667fd72 100644
--- a/src/game/GameObject.cpp
+++ b/src/game/GameObject.cpp
@@ -34,10 +34,11 @@
 #include "InstanceData.h"
 #include "BattleGround.h"
 #include "BattleGroundAV.h"
+#include "OutdoorPvPMgr.h"
 #include "Util.h"
 #include "ScriptCalls.h"
 
-GameObject::GameObject() : WorldObject()
+GameObject::GameObject() : WorldObject(), m_goValue(new GameObjectValue)
 {
     m_objectType |= TYPEMASK_GAMEOBJECT;
     m_objectTypeId = TYPEID_GAMEOBJECT;
@@ -53,6 +54,7 @@ GameObject::GameObject() : WorldObject()
     m_spellId = 0;
     m_cooldownTime = 0;
     m_goInfo = NULL;
+    m_goData = NULL;
 
     m_DBTableGuid = 0;
     m_rotation = 0;
@@ -60,13 +62,19 @@ GameObject::GameObject() : WorldObject()
 
 GameObject::~GameObject()
 {
+    delete m_goValue;
 }
 
 void GameObject::AddToWorld()
 {
     ///- Register the gameobject for guid lookup
     if(!IsInWorld())
+    {
+        if(m_zoneScript)
+            m_zoneScript-&gt;OnGameObjectCreate(this, true);
+
         GetMap()-&gt;GetObjectsStore().insert&lt;GameObject&gt;(GetGUID(), (GameObject*)this);
+    }
 
     Object::AddToWorld();
 }
@@ -76,6 +84,9 @@ void GameObject::RemoveFromWorld()
     ///- Remove the gameobject from the accessor
     if(IsInWorld())
     {
+        if(m_zoneScript)
+            m_zoneScript-&gt;OnGameObjectCreate(this, false);
+
         // Remove GO from owner
         ObjectGuid owner_guid = GetOwnerGUID();
         if (!owner_guid.IsEmpty())
@@ -95,7 +106,7 @@ void GameObject::RemoveFromWorld()
     Object::RemoveFromWorld();
 }
 
-bool GameObject::Create(uint32 guidlow, uint32 name_id, Map *map, uint32 phaseMask, float x, float y, float z, float ang, float rotation0, float rotation1, float rotation2, float rotation3, uint8 animprogress, GOState go_state)
+bool GameObject::Create(uint32 guidlow, uint32 name_id, Map *map, uint32 phaseMask, float x, float y, float z, float ang, float rotation0, float rotation1, float rotation2, float rotation3, uint8 animprogress, GOState go_state, uint32 artKit)
 {
     MANGOS_ASSERT(map);
     Relocate(x,y,z,ang);
@@ -148,6 +159,11 @@ bool GameObject::Create(uint32 guidlow, uint32 name_id, Map *map, uint32 phaseMa
     SetGoArtKit(0);                                         // unknown what this is
     SetGoAnimProgress(animprogress);
 
+    SetByteValue(GAMEOBJECT_BYTES_1, 2, artKit);
+
+    if (goinfo-&gt;type == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+        m_goValue-&gt;destructibleBuilding.health = goinfo-&gt;destructibleBuilding.intactNumHits + goinfo-&gt;destructibleBuilding.damagedNumHits;
+
     //Notify the map's instance data.
     //Only works if you create the object in it, not if it is moves to that map.
     //Normally non-players do not teleport to other maps.
@@ -156,6 +172,8 @@ bool GameObject::Create(uint32 guidlow, uint32 name_id, Map *map, uint32 phaseMa
         ((InstanceMap*)map)-&gt;GetInstanceData()-&gt;OnObjectCreate(this);
     }
 
+    SetZoneScript();
+
     return true;
 }
 
@@ -615,6 +633,8 @@ bool GameObject::LoadFromDB(uint32 guid, Map *map)
         }
     }
 
+    m_goData = data;
+
     return true;
 }
 
@@ -627,11 +647,6 @@ void GameObject::DeleteFromDB()
     WorldDatabase.PExecuteLog("DELETE FROM gameobject_battleground WHERE guid = '%u'", m_DBTableGuid);
 }
 
-GameObjectInfo const *GameObject::GetGOInfo() const
-{
-    return m_goInfo;
-}
-
 /*********************************************************/
 /***                    QUEST SYSTEM                   ***/
 /*********************************************************/
@@ -672,7 +687,7 @@ Unit* GameObject::GetOwner() const
 
 void GameObject::SaveRespawnTime()
 {
-    if(m_respawnTime &gt; time(NULL) &amp;&amp; m_spawnedByDefault)
+    if(m_goData &amp;&amp; m_goData-&gt;dbData &amp;&amp; m_respawnTime &gt; time(NULL) &amp;&amp; m_spawnedByDefault)
         sObjectMgr.SaveGORespawnTime(m_DBTableGuid,GetInstanceId(),m_respawnTime);
 }
 
@@ -891,6 +906,29 @@ void GameObject::UseDoorOrButton(uint32 time_to_restore, bool alternative /* = f
     m_cooldownTime = time(NULL) + time_to_restore;
 }
 
+void GameObject::SetGoArtKit(uint8 kit)
+{
+    SetByteValue(GAMEOBJECT_BYTES_1, 2, kit);
+    GameObjectData *data = const_cast&lt;GameObjectData*&gt;(sObjectMgr.GetGOData(m_DBTableGuid));
+    if(data)
+        data-&gt;artKit = kit;
+}
+
+void GameObject::SetGoArtKit(uint8 artkit, GameObject *go, uint32 lowguid)
+{
+    const GameObjectData *data = NULL;
+    if(go)
+    {
+        go-&gt;SetGoArtKit(artkit);
+        data = go-&gt;GetGOData();
+    }
+    else if(lowguid)
+        data = sObjectMgr.GetGOData(lowguid);
+
+    if(data)
+        const_cast&lt;GameObjectData*&gt;(data)-&gt;artKit = artkit;
+}
+
 void GameObject::SwitchDoorOrButton(bool activate, bool alternative /* = false */)
 {
     if(activate)
@@ -1472,7 +1510,10 @@ void GameObject::Use(Unit* user)
     SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
     if (!spellInfo)
     {
-        sLog.outError("WORLD: unknown spell id %u at use action for gameobject (Entry: %u GoType: %u )", spellId,GetEntry(),GetGoType());
+        if(user-&gt;GetTypeId() != TYPEID_PLAYER || !sOutdoorPvPMgr.HandleCustomSpell((Player*)user,spellId,this))
+            sLog.outError("WORLD: unknown spell id %u at use action for gameobject (Entry: %u GoType: %u )", spellId,GetEntry(),GetGoType());
+        else
+            sLog.outDebug("WORLD: %u non-dbc spell was handled by OutdoorPvP", spellId);
         return;
     }
 
diff --git a/src/game/GameObject.h b/src/game/GameObject.h
index f09e749..c9e568f 100644
--- a/src/game/GameObject.h
+++ b/src/game/GameObject.h
@@ -516,6 +516,15 @@ struct GameObjectInfo
     }
 };
 
+union GameObjectValue
+{
+    //33 GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING
+    struct
+    {
+        uint32 health;
+    }destructibleBuilding;
+};
+
 // GCC have alternative #pragma pack() syntax and old gcc version not support pack(pop), also any gcc version not support it at some platform
 #if defined( __GNUC__ )
 #pragma pack()
@@ -542,6 +551,7 @@ enum GOState
 // from `gameobject`
 struct GameObjectData
 {
+    explicit GameObjectData() : dbData(true) {}
     uint32 id;                                              // entry in gamobject_template
     uint16 mapid;
     uint16 phaseMask;
@@ -557,6 +567,8 @@ struct GameObjectData
     uint32 animprogress;
     GOState go_state;
     uint8 spawnMask;
+    uint8 artKit;
+    bool dbData;
 };
 
 // For containers:  [GO_NOT_READY]-&gt;GO_READY (close)-&gt;GO_ACTIVATED (open) -&gt;GO_JUST_DEACTIVATED-&gt;GO_READY        -&gt; ...
@@ -587,9 +599,11 @@ class MANGOS_DLL_SPEC GameObject : public WorldObject
         void AddToWorld();
         void RemoveFromWorld();
 
-        bool Create(uint32 guidlow, uint32 name_id, Map *map, uint32 phaseMask, float x, float y, float z, float ang, float rotation0, float rotation1, float rotation2, float rotation3, uint8 animprogress, GOState go_state);
+        bool Create(uint32 guidlow, uint32 name_id, Map *map, uint32 phaseMask, float x, float y, float z, float ang, float rotation0, float rotation1, float rotation2, float rotation3, uint8 animprogress, GOState go_state, uint32 artKit = 0);
         void Update(uint32 p_time);
-        GameObjectInfo const* GetGOInfo() const;
+        GameObjectInfo const* GetGOInfo() const { return m_goInfo; }
+        GameObjectData const* GetGOData() const { return m_goData; }
+        GameObjectValue * GetGOValue() const { return m_goValue; }
 
         bool IsTransport() const;
 
@@ -658,7 +672,8 @@ class MANGOS_DLL_SPEC GameObject : public WorldObject
         GOState GetGoState() const { return GOState(GetByteValue(GAMEOBJECT_BYTES_1, 0)); }
         void SetGoState(GOState state) { SetByteValue(GAMEOBJECT_BYTES_1, 0, state); }
         uint8 GetGoArtKit() const { return GetByteValue(GAMEOBJECT_BYTES_1, 2); }
-        void SetGoArtKit(uint8 artkit) { SetByteValue(GAMEOBJECT_BYTES_1, 2, artkit); }
+        void SetGoArtKit(uint8 artkit);
+        static void SetGoArtKit(uint8 artkit, GameObject *go, uint32 lowguid = 0);
         uint8 GetGoAnimProgress() const { return GetByteValue(GAMEOBJECT_BYTES_1, 3); }
         void SetGoAnimProgress(uint8 animprogress) { SetByteValue(GAMEOBJECT_BYTES_1, 3, animprogress); }
 
@@ -731,6 +746,8 @@ class MANGOS_DLL_SPEC GameObject : public WorldObject
 
         uint32 m_DBTableGuid;                               ///&lt; For new or temporary gameobjects is 0 for saved it is lowguid
         GameObjectInfo const* m_goInfo;
+        GameObjectData const* m_goData;
+        GameObjectValue * const m_goValue;
         uint64 m_rotation;
     private:
         void SwitchDoorOrButton(bool activate, bool alternative = false);
diff --git a/src/game/GossipDef.h b/src/game/GossipDef.h
index c466673..b2e8c74 100644
--- a/src/game/GossipDef.h
+++ b/src/game/GossipDef.h
@@ -49,6 +49,8 @@ enum Gossip_Option
     GOSSIP_OPTION_ARMORER           = 15,                   //UNIT_NPC_FLAG_ARMORER             (4096)
     GOSSIP_OPTION_UNLEARNTALENTS    = 16,                   //UNIT_NPC_FLAG_TRAINER             (16) (bonus option for GOSSIP_OPTION_TRAINER)
     GOSSIP_OPTION_UNLEARNPETSKILLS  = 17,                   //UNIT_NPC_FLAG_TRAINER             (16) (bonus option for GOSSIP_OPTION_TRAINER)
+    GOSSIP_OPTION_LEARNDUALSPEC     = 18,                   //UNIT_NPC_FLAG_TRAINER             (bonus option for GOSSIP_OPTION_TRAINER)
+    GOSSIP_OPTION_OUTDOORPVP        = 19,                   //added by code (option for outdoor pvp creatures)
     GOSSIP_OPTION_MAX
 };
 
diff --git a/src/game/Language.h b/src/game/Language.h
index 32c6dc3..d985667 100644
--- a/src/game/Language.h
+++ b/src/game/Language.h
@@ -900,6 +900,73 @@ enum MangosStrings
 
     // Use for not-in-offcial-sources patches
     //                                    10000-10999
+    // opvp hp
+    LANG_OPVP_HP_CAPTURE_OVERLOOK_H     = 10001,
+    LANG_OPVP_HP_CAPTURE_OVERLOOK_A     = 10002,
+    LANG_OPVP_HP_CAPTURE_STADIUM_H      = 10003,
+    LANG_OPVP_HP_CAPTURE_STADIUM_A      = 10004,
+    LANG_OPVP_HP_CAPTURE_BROKENHILL_H   = 10005,
+    LANG_OPVP_HP_CAPTURE_BROKENHILL_A   = 10006,
+    LANG_OPVP_HP_LOOSE_OVERLOOK_H       = 10007,
+    LANG_OPVP_HP_LOOSE_OVERLOOK_A       = 10008,
+    LANG_OPVP_HP_LOOSE_STADIUM_H        = 10009,
+    LANG_OPVP_HP_LOOSE_STADIUM_A        = 10010,
+    LANG_OPVP_HP_LOOSE_BROKENHILL_H     = 10011,
+    LANG_OPVP_HP_LOOSE_BROKENHILL_A     = 10012,
+    // opvp zm
+    LANG_OPVP_ZM_CAPTURE_WEST_H         = 10013,
+    LANG_OPVP_ZM_CAPTURE_WEST_A         = 10014,
+    LANG_OPVP_ZM_CAPTURE_EAST_H         = 10015,
+    LANG_OPVP_ZM_CAPTURE_EAST_A         = 10016,
+    LANG_OPVP_ZM_CAPTURE_GY_H           = 10017,
+    LANG_OPVP_ZM_CAPTURE_GY_A           = 10018,
+    LANG_OPVP_ZM_LOOSE_WEST_H           = 10019,
+    LANG_OPVP_ZM_LOOSE_WEST_A           = 10020,
+    LANG_OPVP_ZM_LOOSE_EAST_H           = 10021,
+    LANG_OPVP_ZM_LOOSE_EAST_A           = 10022,
+    LANG_OPVP_ZM_LOOSE_GY_H             = 10023,
+    LANG_OPVP_ZM_LOOSE_GY_A             = 10024,
+    // opvp na
+    LANG_OPVP_NA_CAPTURE_H              = 10025,
+    LANG_OPVP_NA_CAPTURE_A              = 10026,
+    LANG_OPVP_NA_LOOSE_H                = 10027,
+    LANG_OPVP_NA_LOOSE_A                = 10028,
+    // opvp tf
+    LANG_OPVP_TF_CAPTURE_H              = 10029,
+    LANG_OPVP_TF_CAPTURE_A              = 10030,
+    LANG_OPVP_TF_LOOSE_H                = 10031,
+    LANG_OPVP_TF_LOOSE_A                = 10032,
+    // opvp ep
+    LANG_OPVP_EP_CAPTURE_NPT_H          = 10033,
+    LANG_OPVP_EP_CAPTURE_NPT_A          = 10034,
+    LANG_OPVP_EP_CAPTURE_EWT_H          = 10035,
+    LANG_OPVP_EP_CAPTURE_EWT_A          = 10036,
+    LANG_OPVP_EP_CAPTURE_CGT_H          = 10037,
+    LANG_OPVP_EP_CAPTURE_CGT_A          = 10038,
+    LANG_OPVP_EP_CAPTURE_PWT_H          = 10039,
+    LANG_OPVP_EP_CAPTURE_PWT_A          = 10040,
+    LANG_OPVP_EP_LOOSE_NPT_H            = 10041,
+    LANG_OPVP_EP_LOOSE_NPT_A            = 10042,
+    LANG_OPVP_EP_LOOSE_EWT_H            = 10043,
+    LANG_OPVP_EP_LOOSE_EWT_A            = 10044,
+    LANG_OPVP_EP_LOOSE_CGT_H            = 10045,
+    LANG_OPVP_EP_LOOSE_CGT_A            = 10046,
+    LANG_OPVP_EP_LOOSE_PWT_H            = 10047,
+    LANG_OPVP_EP_LOOSE_PWT_A            = 10048,
+    // opvp si
+    LANG_OPVP_SI_CAPTURE_H              = 10049,
+    LANG_OPVP_SI_CAPTURE_A              = 10050,
+    // opvp gh
+    LANG_OPVP_GH_CAPTURE_H              = 10051,
+    LANG_OPVP_GH_CAPTURE_A              = 10052,
+    LANG_OPVP_GH_LOOSE_H                = 10053,
+    LANG_OPVP_GH_LOOSE_A                = 10054,
+    // opvp gossips
+    LANG_OPVP_EP_FLIGHT_NPT             = 10056,
+    LANG_OPVP_EP_FLIGHT_EWT             = 10057,
+    LANG_OPVP_EP_FLIGHT_CGT             = 10058,
+    LANG_OPVP_ZM_GOSSIP_ALLIANCE        = 10059,
+    LANG_OPVP_ZM_GOSSIP_HORDE           = 10060,
 
     // Use for custom patches             11000-11999
 
diff --git a/src/game/Makefile.am b/src/game/Makefile.am
index 3e9b847..bf35831 100644
--- a/src/game/Makefile.am
+++ b/src/game/Makefile.am
@@ -207,6 +207,23 @@ libmangosgame_a_SOURCES = \
 	ObjectPosSelector.h \
 	Opcodes.cpp \
 	Opcodes.h \
+	OutdoorPvP.cpp \
+	OutdoorPvP.h \
+	OutdoorPvPEP.cpp \
+	OutdoorPvPEP.h \
+	OutdoorPvPHP.cpp \
+	OutdoorPvPHP.h \
+	OutdoorPvPImpl.h \
+	OutdoorPvPMgr.cpp \
+	OutdoorPvPMgr.h \
+	OutdoorPvPNA.cpp \
+	OutdoorPvPNA.h \
+	OutdoorPvPSI.cpp \
+	OutdoorPvPSI.h \
+	OutdoorPvPTF.cpp \
+	OutdoorPvPTF.h \
+	OutdoorPvPZM.cpp \
+	OutdoorPvPZM.h \
 	Path.h \
 	PetAI.cpp \
 	PetAI.h \
@@ -297,7 +314,8 @@ libmangosgame_a_SOURCES = \
 	FollowerRefManager.h \
 	GroupReference.cpp \
 	GroupReference.h \
-	GroupRefManager.h
+	GroupRefManager.h \
+	ZoneScript.h
 
 ## Additional files to include when running 'make dist'
 #  Precompiled Headers for WIN
diff --git a/src/game/MiscHandler.cpp b/src/game/MiscHandler.cpp
index f4909fa..27a1460 100644
--- a/src/game/MiscHandler.cpp
+++ b/src/game/MiscHandler.cpp
@@ -37,6 +37,7 @@
 #include "ObjectAccessor.h"
 #include "Object.h"
 #include "BattleGround.h"
+#include "OutdoorPvP.h"
 #include "Pet.h"
 #include "SocialMgr.h"
 #include "DBCEnums.h"
@@ -739,6 +740,12 @@ void WorldSession::HandleAreaTriggerOpcode(WorldPacket &amp; recv_data)
         return;
     }
 
+    if(OutdoorPvP * pvp = GetPlayer()-&gt;GetOutdoorPvP())
+    {
+        if(pvp-&gt;HandleAreaTrigger(_player, Trigger_ID))
+            return;
+    }
+
     // NULL if all values default (non teleport trigger)
     AreaTrigger const* at = sObjectMgr.GetAreaTrigger(Trigger_ID);
     if(!at)
diff --git a/src/game/Object.cpp b/src/game/Object.cpp
index 8f7fd99..b43264e 100644
--- a/src/game/Object.cpp
+++ b/src/game/Object.cpp
@@ -43,6 +43,7 @@
 #include "ObjectPosSelector.h"
 
 #include "TemporarySummon.h"
+#include "OutdoorPvPMgr.h"
 
 Object::Object( )
 {
@@ -580,7 +581,7 @@ void Object::BuildValuesUpdate(uint8 updatetype, ByteBuffer * data, UpdateMask *
                 if (index == UNIT_NPC_FLAGS)
                 {
                     // remove custom flag before sending
-                    uint32 appendValue = m_uint32Values[index] &amp; ~UNIT_NPC_FLAG_GUARD;
+                    uint32 appendValue = m_uint32Values[index] &amp; ~(UNIT_NPC_FLAG_GUARD + UNIT_NPC_FLAG_OUTDOORPVP);
 
                     if (GetTypeId() == TYPEID_UNIT)
                     {
@@ -1122,7 +1123,7 @@ void Object::BuildUpdateData( UpdateDataMapType&amp; /*update_players */)
 
 WorldObject::WorldObject()
     : m_isActiveObject(false), m_currMap(NULL), m_mapId(0), m_InstanceId(0), m_phaseMask(PHASEMASK_NORMAL),
-    m_positionX(0.0f), m_positionY(0.0f), m_positionZ(0.0f), m_orientation(0.0f)
+    m_zoneScript(NULL), m_positionX(0.0f), m_positionY(0.0f), m_positionZ(0.0f), m_orientation(0.0f)
 {
 }
 
@@ -1724,6 +1725,15 @@ void WorldObject::AddObjectToRemoveList()
     GetMap()-&gt;AddObjectToRemoveList(this);
 }
 
+void WorldObject::SetZoneScript()
+{
+    if(Map *map = GetMap())
+    {
+        if(!map-&gt;IsBattleGroundOrArena() &amp;&amp; !map-&gt;IsDungeon())
+            m_zoneScript = sOutdoorPvPMgr.GetZoneScript(GetZoneId());
+    }
+}
+
 Creature* WorldObject::SummonCreature(uint32 id, float x, float y, float z, float ang,TempSummonType spwtype,uint32 despwtime, bool asActiveObject)
 {
     TemporarySummon* pCreature = new TemporarySummon(GetObjectGuid());
diff --git a/src/game/Object.h b/src/game/Object.h
index 795d21d..411fa11 100644
--- a/src/game/Object.h
+++ b/src/game/Object.h
@@ -70,6 +70,7 @@ class Map;
 class UpdateMask;
 class InstanceData;
 class TerrainInfo;
+class ZoneScript;
 
 typedef UNORDERED_MAP&lt;Player*, UpdateData&gt; UpdateDataMapType;
 
@@ -484,6 +485,9 @@ class MANGOS_DLL_SPEC WorldObject : public Object
         //obtain terrain data for map where this object belong...
         TerrainInfo const* GetTerrain() const;
 
+        void SetZoneScript();
+        ZoneScript * GetZoneScript() const { return m_zoneScript; }
+
         void AddToClientUpdateList();
         void RemoveFromClientUpdateList();
         void BuildUpdateData(UpdateDataMapType &amp;);
@@ -502,6 +506,7 @@ class MANGOS_DLL_SPEC WorldObject : public Object
         void SetLocationMapId(uint32 _mapId) { m_mapId = _mapId; }
         void SetLocationInstanceId(uint32 _instanceId) { m_InstanceId = _instanceId; }
 
+        ZoneScript *m_zoneScript;
         std::string m_name;
 
         bool m_isActiveObject;
diff --git a/src/game/ObjectMgr.cpp b/src/game/ObjectMgr.cpp
index 0368c40..d9ac0e9 100644
--- a/src/game/ObjectMgr.cpp
+++ b/src/game/ObjectMgr.cpp
@@ -1420,6 +1420,110 @@ void ObjectMgr::RemoveCreatureFromGrid(uint32 guid, CreatureData const* data)
     }
 }
 
+uint32 ObjectMgr::AddGOData(uint32 entry, uint32 mapId, float x, float y, float z, float o, uint32 spawntimedelay, float rotation0, float rotation1, float rotation2, float rotation3)
+{
+    GameObjectInfo const* goinfo = GetGameObjectInfo(entry);
+    if (!goinfo)
+        return 0;
+
+    Map * map = const_cast&lt;Map*&gt;(sMapMgr.FindMap(mapId));
+    if(!map)
+        return 0;
+
+    uint32 guid = GenerateLowGuid(HIGHGUID_GAMEOBJECT);
+    GameObjectData&amp; data = NewGOData(guid);
+    data.id             = entry;
+    data.mapid          = mapId;
+    data.posX           = x;
+    data.posY           = y;
+    data.posZ           = z;
+    data.orientation    = o;
+    data.rotation0      = rotation0;
+    data.rotation1      = rotation1;
+    data.rotation2      = rotation2;
+    data.rotation3      = rotation3;
+    data.spawntimesecs  = spawntimedelay;
+    data.animprogress   = 100;
+    data.spawnMask      = 1;
+    data.go_state       = GO_STATE_READY;
+    data.phaseMask      = PHASEMASK_NORMAL;
+    data.artKit         = goinfo-&gt;type == GAMEOBJECT_TYPE_CAPTURE_POINT ? 21 : 0;
+    data.dbData = false;
+
+    AddGameobjectToGrid(guid, &amp;data);
+
+    // Spawn if necessary (loaded grids only)
+    // We use spawn coords to spawn
+    if(!map-&gt;Instanceable() &amp;&amp; map-&gt;IsLoaded(x, y))
+    {
+        GameObject *go = new GameObject;
+        if (!go-&gt;LoadFromDB(guid, map))
+        {
+            sLog.outError("AddGOData: cannot add gameobject entry %u to map", entry);
+            delete go;
+            return 0;
+        }
+        map-&gt;Add(go);
+    }
+
+    sLog.outDebug("AddGOData: dbguid %u entry %u map %u x %f y %f z %f o %f", guid, entry, mapId, x, y, z, o);
+
+    return guid;
+}
+
+uint32 ObjectMgr::AddCreData(uint32 entry, uint32 team, uint32 mapId, float x, float y, float z, float o, uint32 spawntimedelay)
+{
+    CreatureInfo const *cInfo = GetCreatureTemplate(entry);
+    if(!cInfo)
+        return 0;
+
+    uint32 level = cInfo-&gt;minlevel == cInfo-&gt;maxlevel ? cInfo-&gt;minlevel : urand(cInfo-&gt;minlevel, cInfo-&gt;maxlevel); // Only used for extracting creature base stats
+    //CreatureBaseStats const* stats = objmgr.GetCreatureBaseStats(level, cInfo-&gt;unit_class);
+
+    uint32 guid = GenerateLowGuid(HIGHGUID_UNIT);
+    CreatureData&amp; data = NewOrExistCreatureData(guid);
+    data.id = entry;
+    data.mapid = mapId;
+    data.modelid_override = 0;
+    data.equipmentId = cInfo-&gt;equipmentId;
+    data.posX = x;
+    data.posY = y;
+    data.posZ = z;
+    data.orientation = o;
+    data.spawntimesecs = spawntimedelay;
+    data.spawndist = 0;
+    data.currentwaypoint = 0;
+    data.curhealth = 1;
+    data.curmana = 1;
+    data.is_dead = false;
+    data.movementType = cInfo-&gt;MovementType;
+    data.spawnMask = 1;
+    data.phaseMask = PHASEMASK_NORMAL;
+    data.dbData = false;
+
+    AddCreatureToGrid(guid, &amp;data);
+
+    // Spawn if necessary (loaded grids only)
+    //if(Map* map = const_cast&lt;Map*&gt;(MapManager::Instance().CreateBaseMap(mapId)))
+    if(Map * map = const_cast&lt;Map*&gt;(sMapMgr.FindMap(mapId)))
+    {
+        // We use spawn coords to spawn
+        if(!map-&gt;Instanceable() &amp;&amp; !map-&gt;IsRemovalGrid(x, y))
+        {
+            Creature* creature = new Creature;
+            if(!creature-&gt;LoadFromDB(guid, map))
+            {
+                sLog.outError("AddCreature: cannot add creature entry %u to map", entry);
+                delete creature;
+                return 0;
+            }
+            map-&gt;Add(creature);
+        }
+    }
+
+    return guid;
+}
+
 void ObjectMgr::LoadGameobjects()
 {
     uint32 count = 0;
@@ -6087,6 +6191,53 @@ bool ObjectMgr::AddGraveYardLink(uint32 id, uint32 zoneId, uint32 team, bool inD
     return true;
 }
 
+void ObjectMgr::RemoveGraveYardLink(uint32 id, uint32 zoneId, uint32 team, bool inDB)
+{
+    GraveYardMap::iterator graveLow  = mGraveYardMap.lower_bound(zoneId);
+    GraveYardMap::iterator graveUp   = mGraveYardMap.upper_bound(zoneId);
+    if(graveLow==graveUp)
+    {
+        //sLog.outErrorDb("Table `game_graveyard_zone` incomplete: Zone %u Team %u does not have a linked graveyard.",zoneId,team);
+        return;
+    }
+
+    bool found = false;
+
+    GraveYardMap::iterator itr;
+
+    for (itr = graveLow; itr != graveUp; ++itr)
+    {
+        GraveYardData &amp; data = itr-&gt;second;
+
+        // skip not matching safezone id
+        if(data.safeLocId != id)
+            continue;
+
+        // skip enemy faction graveyard at same map (normal area, city, or battleground)
+        // team == 0 case can be at call from .neargrave
+        if(data.team != 0 &amp;&amp; team != 0 &amp;&amp; data.team != team)
+            continue;
+
+        found = true;
+        break;
+    }
+
+    // no match, return
+    if(!found)
+        return;
+
+    // remove from links
+    mGraveYardMap.erase(itr);
+
+    // remove link from DB
+    if(inDB)
+    {
+        WorldDatabase.PExecute("DELETE FROM game_graveyard_zone WHERE id = '%u' AND ghost_zone = '%u' AND faction = '%u'",id,zoneId,team);
+    }
+
+    return;
+}
+
 void ObjectMgr::LoadAreaTriggerTeleports()
 {
     mAreaTriggers.clear();                                  // need for reload case
diff --git a/src/game/ObjectMgr.h b/src/game/ObjectMgr.h
index 1740d80..42fab31 100644
--- a/src/game/ObjectMgr.h
+++ b/src/game/ObjectMgr.h
@@ -835,6 +835,7 @@ class ObjectMgr
 
         WorldSafeLocsEntry const *GetClosestGraveYard(float x, float y, float z, uint32 MapId, uint32 team);
         bool AddGraveYardLink(uint32 id, uint32 zone, uint32 team, bool inDB = true);
+        void RemoveGraveYardLink(uint32 id, uint32 zone, uint32 team, bool inDB = false);
         void LoadGraveyardZones();
         GraveYardData const* FindGraveYardData(uint32 id, uint32 zone) const;
 
@@ -1165,6 +1166,8 @@ class ObjectMgr
         void RemoveCreatureFromGrid(uint32 guid, CreatureData const* data);
         void AddGameobjectToGrid(uint32 guid, GameObjectData const* data);
         void RemoveGameobjectFromGrid(uint32 guid, GameObjectData const* data);
+        uint32 AddGOData(uint32 entry, uint32 map, float x, float y, float z, float o, uint32 spawntimedelay = 0, float rotation0 = 0, float rotation1 = 0, float rotation2 = 0, float rotation3 = 0);
+        uint32 AddCreData(uint32 entry, uint32 team, uint32 map, float x, float y, float z, float o, uint32 spawntimedelay = 0);
 
         // reserved names
         void LoadReservedPlayersNames();
diff --git a/src/game/OutdoorPvP.cpp b/src/game/OutdoorPvP.cpp
new file mode 100644
index 0000000..195304f
--- /dev/null
+++ b/src/game/OutdoorPvP.cpp
@@ -0,0 +1,683 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS &lt;http://www.MaNGOScore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvP.h"
+#include "OutdoorPvPImpl.h"
+#include "OutdoorPvPMgr.h"
+#include "ObjectAccessor.h"
+#include "ObjectGuid.h"
+#include "ObjectMgr.h"
+#include "Map.h"
+#include "MapManager.h"
+#include "Group.h"
+#include "WorldPacket.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "CellImpl.h"
+
+#include "Database/DatabaseEnv.h"
+#include "World.h"
+#include "Player.h"
+#include "Opcodes.h"
+#include "Chat.h"
+#include "ObjectAccessor.h"
+#include "Language.h"
+#include "AccountMgr.h"
+#include "SystemConfig.h"
+#include "revision.h"
+#include "revision_nr.h"
+#include "Util.h"
+
+OPvPCapturePoint::OPvPCapturePoint(OutdoorPvP * pvp)
+: m_PvP(pvp), m_value(0), m_maxValue(0), m_team(TEAM_NEUTRAL),
+m_State(OBJECTIVESTATE_NEUTRAL), m_OldState(OBJECTIVESTATE_NEUTRAL), m_capturePointGUID(0), m_neutralValuePct(0),
+m_maxSpeed(0), m_capturePoint(NULL)
+{
+}
+
+bool OPvPCapturePoint::HandlePlayerEnter(Player * plr)
+{
+    if(m_capturePoint)
+    {
+        plr-&gt;SendUpdateWorldState(m_capturePoint-&gt;GetGOInfo()-&gt;capturePoint.worldState1, 1);
+        plr-&gt;SendUpdateWorldState(m_capturePoint-&gt;GetGOInfo()-&gt;capturePoint.worldstate2, (uint32)ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f));
+        plr-&gt;SendUpdateWorldState(m_capturePoint-&gt;GetGOInfo()-&gt;capturePoint.worldstate3, m_neutralValuePct);
+    }
+    return m_activePlayers[plr-&gt;GetTeamId()].insert(plr).second;
+}
+
+void OPvPCapturePoint::HandlePlayerLeave(Player * plr)
+{
+    if(m_capturePoint)
+        plr-&gt;SendUpdateWorldState(m_capturePoint-&gt;GetGOInfo()-&gt;capturePoint.worldState1, 0);
+    m_activePlayers[plr-&gt;GetTeamId()].erase(plr);
+}
+
+void OPvPCapturePoint::SendChangePhase()
+{
+    if(!m_capturePoint)
+        return;
+
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(m_capturePoint-&gt;GetGOInfo()-&gt;capturePoint.worldState1, 1);
+    // send these updates to only the ones in this objective
+    SendUpdateWorldState(m_capturePoint-&gt;GetGOInfo()-&gt;capturePoint.worldstate2, (uint32)ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f));
+    // send this too, sometimes it resets :S
+    SendUpdateWorldState(m_capturePoint-&gt;GetGOInfo()-&gt;capturePoint.worldstate3, m_neutralValuePct);
+}
+
+void OPvPCapturePoint::AddGO(uint32 type, uint64 guid, uint32 entry)
+{
+    if(!entry)
+    {
+        const GameObjectData *data = sObjectMgr.GetGOData(guid);
+        if(!data)
+            return;
+        entry = data-&gt;id;
+    }
+    ObjectGuid object_data = ObjectGuid(HIGHGUID_GAMEOBJECT, guid, entry);
+    m_Objects[type] = object_data.GetHigh();
+    m_ObjectTypes[m_Objects[type]]=type;
+}
+
+void OPvPCapturePoint::AddCre(uint32 type, uint64 guid, uint32 entry)
+{
+    if(!entry)
+    {
+        const CreatureData *data = sObjectMgr.GetCreatureData(guid);
+        if(!data)
+            return;
+        entry = data-&gt;id;
+    }
+    ObjectGuid creature_data = ObjectGuid(HIGHGUID_UNIT, guid, entry);
+    m_Creatures[type] = creature_data.GetHigh();
+    m_CreatureTypes[m_Creatures[type]] = type;
+}
+
+bool OPvPCapturePoint::AddObject(uint32 type, uint32 entry, uint32 mapId, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3)
+{
+    GameObjectInfo const* goinfo = sObjectMgr.GetGameObjectInfo(entry);
+    if (!goinfo)
+        return 0;
+
+    uint32 guid = sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT);
+    GameObjectData&amp; data = sObjectMgr.NewGOData(guid);
+    data.id             = entry;
+    data.mapid          = mapId;
+    data.posX           = x;
+    data.posY           = y;
+    data.posZ           = z;
+    data.orientation    = o;
+    data.rotation0      = rotation0;
+    data.rotation1      = rotation1;
+    data.rotation2      = rotation2;
+    data.rotation3      = rotation3;
+    data.spawntimesecs  = 0;
+    data.animprogress   = 100;
+    data.spawnMask      = 1;
+    data.go_state       = GO_STATE_READY;
+    data.phaseMask      = PHASEMASK_NORMAL;
+    data.artKit         = goinfo-&gt;type == GAMEOBJECT_TYPE_CAPTURE_POINT ? 21 : 0;
+    data.dbData = false;
+
+    Map * map = const_cast&lt;Map*&gt;(sMapMgr.FindMap(mapId));
+    if(!map)
+    {
+        sLog.outError("Map (Id: %i) for AddObject cannot be initialized.", mapId);
+        return false;
+    }
+
+    sObjectMgr.AddGameobjectToGrid(guid, &amp;data);
+
+    // Spawn if necessary (loaded grids only)
+    // We use spawn coords to spawn
+    if(!map-&gt;Instanceable() &amp;&amp; map-&gt;IsLoaded(x, y))
+    {
+        GameObject *go = new GameObject;
+        if (!go-&gt;LoadFromDB(guid, map))
+        {
+            sLog.outError("AddGOData: cannot add gameobject entry %u to map", entry);
+            delete go;
+            return 0;
+        }
+        map-&gt;Add(go);
+    }
+
+    sLog.outDebug("AddGOData: dbguid %u entry %u map %u x %f y %f z %f o %f", guid, entry, mapId, x, y, z, o);
+
+    return guid;
+
+    if(guid)
+    {
+        AddGO(type, guid, entry);
+        return true;
+    }
+
+    return false;
+}
+
+bool OPvPCapturePoint::AddCreature(uint32 type, uint32 entry, uint32 team, uint32 map, float x, float y, float z, float o, uint32 spawntimedelay)
+{
+    if(uint32 guid = sObjectMgr.AddCreData(entry, team, map, x, y, z, o, spawntimedelay))
+    {
+        AddCre(type, guid, entry);
+        return true;
+    }
+
+    return false;
+}
+
+
+bool OPvPCapturePoint::SetCapturePointData(uint32 entry, uint32 map, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3)
+{
+    sLog.outDebug("Creating capture point %u", entry);
+
+    // check info existence
+    GameObjectInfo const* goinfo = sObjectMgr.GetGameObjectInfo(entry);
+    if(!goinfo || goinfo-&gt;type != GAMEOBJECT_TYPE_CAPTURE_POINT)
+    {
+        sLog.outError("OutdoorPvP: GO %u is not capture point!", entry);
+        return false;
+    }
+
+    m_capturePointGUID = sObjectMgr.AddGOData(entry, map, x, y, z, o, 0, rotation0, rotation1, rotation2, rotation3);
+    if(!m_capturePointGUID)
+        return false;
+
+    // get the needed values from goinfo
+    m_maxValue = goinfo-&gt;capturePoint.maxTime;
+    m_maxSpeed = m_maxValue / (goinfo-&gt;capturePoint.minTime ? goinfo-&gt;capturePoint.minTime : 60);
+    m_neutralValuePct = goinfo-&gt;capturePoint.neutralPercent;
+    m_minValue = m_maxValue * goinfo-&gt;capturePoint.neutralPercent / 100;
+
+    return true;
+}
+
+bool OPvPCapturePoint::DelCreature(uint32 type)
+{
+    if(!m_Creatures[type])
+    {
+        sLog.outDebug("opvp creature type %u was already deleted",type);
+        return false;
+    }
+
+    Creature * cr = ObjectAccessor::GetCreatureInWorld(m_Creatures[type]);
+    if(!cr)
+    {
+        // can happen when closing the core
+        m_Creatures[type] = 0;
+        return false;
+    }
+    sLog.outDebug("deleting opvp creature type %u",type);
+    uint32 guid = cr-&gt;GetDBTableGUIDLow();
+    // Don't save respawn time
+    cr-&gt;SetRespawnTime(0);
+    cr-&gt;RemoveCorpse();
+    // explicit removal from map
+    // beats me why this is needed, but with the recent removal "cleanup" some creatures stay in the map if "properly" deleted
+    // so this is a big fat workaround, if AddObjectToRemoveList and DoDelayedMovesAndRemoves worked correctly, this wouldn't be needed
+    if(Map * map = MapManager::Instance().FindMap(cr-&gt;GetMapId()))
+        map-&gt;Remove(cr,false);
+    // delete respawn time for this creature
+    WorldDatabase.PExecute("DELETE FROM creature_respawn WHERE guid = '%u'", guid);
+    cr-&gt;AddObjectToRemoveList();
+    sObjectMgr.DeleteCreatureData(guid);
+    m_CreatureTypes[m_Creatures[type]] = 0;
+    m_Creatures[type] = 0;
+    return true;
+}
+
+bool OPvPCapturePoint::DelObject(uint32 type)
+{
+    if(!m_Objects[type])
+        return false;
+
+    GameObject * obj = ObjectAccessor::GetGameObjectInWorld(m_Objects[type]);
+    if(!obj)
+    {
+        m_Objects[type] = 0;
+        return false;
+    }
+    uint32 guid = obj-&gt;GetDBTableGUIDLow();
+    obj-&gt;SetRespawnTime(0);                                 // not save respawn time
+    obj-&gt;Delete();
+    sObjectMgr.DeleteGOData(guid);
+    m_ObjectTypes[m_Objects[type]] = 0;
+    m_Objects[type] = 0;
+    return true;
+}
+
+bool OPvPCapturePoint::DelCapturePoint()
+{
+    sObjectMgr.DeleteGOData(m_capturePointGUID);
+    m_capturePointGUID = 0;
+
+    if(m_capturePoint)
+    {
+        m_capturePoint-&gt;SetRespawnTime(0);                                 // not save respawn time
+        m_capturePoint-&gt;Delete();
+    }
+
+    return true;
+}
+
+void OPvPCapturePoint::DeleteSpawns()
+{
+    for (std::map&lt;uint32,uint64&gt;::iterator i = m_Objects.begin(); i != m_Objects.end(); ++i)
+        DelObject(i-&gt;first);
+    for (std::map&lt;uint32,uint64&gt;::iterator i = m_Creatures.begin(); i != m_Creatures.end(); ++i)
+        DelCreature(i-&gt;first);
+    DelCapturePoint();
+}
+
+void OutdoorPvP::DeleteSpawns()
+{
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        itr-&gt;second-&gt;DeleteSpawns();
+}
+
+OutdoorPvP::OutdoorPvP() : m_sendUpdate(true)
+{
+}
+
+OutdoorPvP::~OutdoorPvP()
+{
+    DeleteSpawns();
+}
+
+void OutdoorPvP::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    m_players[plr-&gt;GetTeamId()].insert(plr);
+}
+
+void OutdoorPvP::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // inform the objectives of the leaving
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        itr-&gt;second-&gt;HandlePlayerLeave(plr);
+    // remove the world state information from the player (we can't keep everyone up to date, so leave out those who are not in the concerning zones)
+    if(!plr-&gt;GetSession()-&gt;PlayerLogout())
+        SendRemoveWorldStates(plr);
+    m_players[plr-&gt;GetTeamId()].erase(plr);
+    sLog.outDebug("Player %s left an outdoorpvp zone", plr-&gt;GetName());
+}
+
+void OutdoorPvP::HandlePlayerResurrects(Player * plr, uint32 zone)
+{
+}
+
+bool OutdoorPvP::Update(uint32 diff)
+{
+    bool objective_changed = false;
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+    {
+        if(itr-&gt;second-&gt;Update(diff))
+            objective_changed = true;
+    }
+    return objective_changed;
+}
+
+bool OPvPCapturePoint::Update(uint32 diff)
+{
+    if(!m_capturePoint)
+        return false;
+
+    float radius = m_capturePoint-&gt;GetGOInfo()-&gt;capturePoint.radius;
+
+    for (uint32 team = 0; team &lt; 2; ++team)
+    {
+        for (PlayerSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end();)
+        {
+            Player *player = *itr;
+            ++itr;
+            if(!m_capturePoint-&gt;IsWithinDistInMap(player, radius) || !player-&gt;IsOutdoorPvPActive())
+                HandlePlayerLeave(player);
+        }
+    }
+
+    std::list&lt;Player*&gt; players;
+    std::list&lt;Unit *&gt; targets;
+
+    CellPair p(MaNGOS::ComputeCellPair(m_capturePoint-&gt;GetPositionX(), m_capturePoint-&gt;GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    {
+    MaNGOS::AnyUnitInObjectRangeCheck u_check(m_capturePoint, radius);
+    MaNGOS::UnitListSearcher&lt;MaNGOS::AnyUnitInObjectRangeCheck&gt; searcher(targets, u_check);
+
+    TypeContainerVisitor&lt;MaNGOS::UnitListSearcher&lt;MaNGOS::AnyUnitInObjectRangeCheck&gt;, WorldTypeMapContainer &gt; world_unit_searcher(searcher);
+    TypeContainerVisitor&lt;MaNGOS::UnitListSearcher&lt;MaNGOS::AnyUnitInObjectRangeCheck&gt;, GridTypeMapContainer &gt;  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *m_capturePoint-&gt;GetMap(), *m_capturePoint, radius);
+    cell.Visit(p, grid_unit_searcher, *m_capturePoint-&gt;GetMap(), *m_capturePoint, radius);
+    }
+
+    for( std::list&lt;Unit *&gt;::iterator itr = targets.begin(); itr != targets.end(); ++itr )
+        if( (*itr)-&gt;GetTypeId() == TYPEID_PLAYER )
+                    players.push_back((Player*)(*itr));
+
+    for (std::list&lt;Player*&gt;::iterator itr = players.begin(); itr != players.end(); ++itr)
+    {
+        if((*itr)-&gt;IsOutdoorPvPActive())
+        {
+            if(m_activePlayers[(*itr)-&gt;GetTeamId()].insert(*itr).second)
+                HandlePlayerEnter(*itr);
+        }
+    }
+
+    // get the difference of numbers
+    float fact_diff = ((float)m_activePlayers[0].size() - (float)m_activePlayers[1].size()) * diff / OUTDOORPVP_OBJECTIVE_UPDATE_INTERVAL;
+    if(!fact_diff)
+        return false;
+
+    uint32 Challenger = 0;
+    float maxDiff = m_maxSpeed * diff;
+
+    if(fact_diff &lt; 0)
+    {
+        // horde is in majority, but it's already horde-controlled -&gt; no change
+        if(m_State == OBJECTIVESTATE_HORDE &amp;&amp; m_value &lt;= -m_maxValue)
+            return false;
+
+        if(fact_diff &lt; -maxDiff)
+            fact_diff = -maxDiff;
+
+        Challenger = HORDE;
+    }
+    else
+    {
+        // ally is in majority, but it's already ally-controlled -&gt; no change
+        if(m_State == OBJECTIVESTATE_ALLIANCE &amp;&amp; m_value &gt;= m_maxValue)
+            return false;
+
+        if(fact_diff &gt; maxDiff)
+            fact_diff = maxDiff;
+
+        Challenger = ALLIANCE;
+    }
+
+    float oldValue = m_value;
+    TeamId oldTeam = m_team;
+
+    m_OldState = m_State;
+
+    m_value += fact_diff;
+
+    if(m_value &lt; -m_minValue) // red
+    {
+        if(m_value &lt; -m_maxValue)
+            m_value = -m_maxValue;
+        m_State = OBJECTIVESTATE_HORDE;
+        m_team = TEAM_HORDE;
+    }
+    else if(m_value &gt; m_minValue) // blue
+    {
+        if(m_value &gt; m_maxValue)
+            m_value = m_maxValue;
+        m_State = OBJECTIVESTATE_ALLIANCE;
+        m_team = TEAM_ALLIANCE;
+    }
+    else if(oldValue * m_value &lt;= 0) // grey, go through mid point
+    {
+        // if challenger is ally, then n-&gt;a challenge
+        if(Challenger == ALLIANCE)
+            m_State = OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE;
+        // if challenger is horde, then n-&gt;h challenge
+        else if(Challenger == HORDE)
+            m_State = OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE;
+        m_team = TEAM_NEUTRAL;
+    }
+    else // grey, did not go through mid point
+    {
+        // old phase and current are on the same side, so one team challenges the other
+        if(Challenger == ALLIANCE &amp;&amp; (m_OldState == OBJECTIVESTATE_HORDE || m_OldState == OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE))
+            m_State = OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE;
+        else if(Challenger == HORDE &amp;&amp; (m_OldState == OBJECTIVESTATE_ALLIANCE || m_OldState == OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE))
+            m_State = OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE;
+        m_team = TEAM_NEUTRAL;
+    }
+
+    if(m_value != oldValue)
+        SendChangePhase();
+
+    if(m_OldState != m_State)
+    {
+        //sLog.outError("%u-&gt;%u", m_OldState, m_State);
+        if(oldTeam != m_team)
+            ChangeTeam(oldTeam);
+        ChangeState();
+        return true;
+    }
+
+    return false;
+}
+
+void OutdoorPvP::SendUpdateWorldState(uint32 field, uint32 value)
+{
+    if(m_sendUpdate)
+        for (int i = 0; i &lt; 2; ++i)
+            for (PlayerSet::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
+                (*itr)-&gt;SendUpdateWorldState(field, value);
+}
+
+void OPvPCapturePoint::SendUpdateWorldState(uint32 field, uint32 value)
+{
+    for (uint32 team = 0; team &lt; 2; ++team)
+    {
+        // send to all players present in the area
+        for (PlayerSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
+        {
+            (*itr)-&gt;SendUpdateWorldState(field,value);
+        }
+    }
+}
+
+void OPvPCapturePoint::SendObjectiveComplete(uint32 id,uint64 guid)
+{
+    uint32 team;
+    switch(m_State)
+    {
+    case OBJECTIVESTATE_ALLIANCE:
+        team = 0;
+        break;
+    case OBJECTIVESTATE_HORDE:
+        team = 1;
+        break;
+    default:
+        return;
+    }
+
+    // send to all players present in the area
+    for (PlayerSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
+        (*itr)-&gt;KilledMonsterCredit(id, guid);
+}
+
+void OutdoorPvP::HandleKill(Player *killer, Unit * killed)
+{
+    if(Group * pGroup = killer-&gt;GetGroup())
+    {
+        for (GroupReference *itr = pGroup-&gt;GetFirstMember(); itr != NULL; itr = itr-&gt;next())
+        {
+            Player *pGroupGuy = itr-&gt;getSource();
+
+            if(!pGroupGuy)
+                continue;
+
+            // skip if too far away
+            if(!pGroupGuy-&gt;IsAtGroupRewardDistance(killed))
+                continue;
+
+            // creature kills must be notified, even if not inside objective / not outdoor pvp active
+            // player kills only count if active and inside objective
+            if(( pGroupGuy-&gt;IsOutdoorPvPActive() &amp;&amp; IsInsideObjective(pGroupGuy) ) || killed-&gt;GetTypeId() == TYPEID_UNIT)
+            {
+                HandleKillImpl(pGroupGuy, killed);
+            }
+        }
+    }
+    else
+    {
+        // creature kills must be notified, even if not inside objective / not outdoor pvp active
+        if(killer &amp;&amp; (( killer-&gt;IsOutdoorPvPActive() &amp;&amp; IsInsideObjective(killer) ) || killed-&gt;GetTypeId() == TYPEID_UNIT))
+        {
+            HandleKillImpl(killer, killed);
+        }
+    }
+}
+
+bool OutdoorPvP::IsInsideObjective(Player *plr) const
+{
+    for (OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if(itr-&gt;second-&gt;IsInsideObjective(plr))
+            return true;
+
+    return false;
+}
+
+bool OPvPCapturePoint::IsInsideObjective(Player *plr) const
+{
+    return m_activePlayers[plr-&gt;GetTeamId()].find(plr) != m_activePlayers[plr-&gt;GetTeamId()].end();
+}
+
+bool OutdoorPvP::HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go)
+{
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if(itr-&gt;second-&gt;HandleCustomSpell(plr,spellId,go))
+            return true;
+
+    return false;
+}
+
+bool OPvPCapturePoint::HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go)
+{
+    if(!plr-&gt;IsOutdoorPvPActive())
+        return false;
+    return false;
+}
+
+bool OutdoorPvP::HandleOpenGo(Player *plr, uint64 guid)
+{
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if(itr-&gt;second-&gt;HandleOpenGo(plr,guid) &gt;= 0)
+            return true;
+
+    return false;
+}
+
+bool OutdoorPvP::HandleGossipOption(Player * plr, uint64 guid, uint32 id)
+{
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if(itr-&gt;second-&gt;HandleGossipOption(plr, guid, id))
+            return true;
+
+    return false;
+}
+
+bool OutdoorPvP::CanTalkTo(Player * plr, Creature * c, GossipMenuItems gso)
+{
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if(itr-&gt;second-&gt;CanTalkTo(plr, c, gso))
+            return true;
+
+    return false;
+}
+
+bool OutdoorPvP::HandleDropFlag(Player * plr, uint32 id)
+{
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if(itr-&gt;second-&gt;HandleDropFlag(plr, id))
+            return true;
+
+    return false;
+}
+
+bool OPvPCapturePoint::HandleGossipOption(Player * plr, uint64 guid, uint32 id)
+{
+    return false;
+}
+
+bool OPvPCapturePoint::CanTalkTo(Player * plr, Creature * c, GossipMenuItems gso)
+{
+    return false;
+}
+
+bool OPvPCapturePoint::HandleDropFlag(Player * plr, uint32 id)
+{
+    return false;
+}
+
+int32 OPvPCapturePoint::HandleOpenGo(Player *plr, uint64 guid)
+{
+    std::map&lt;uint64,uint32&gt;::iterator itr = m_ObjectTypes.find(guid);
+    if(itr != m_ObjectTypes.end())
+    {
+        return itr-&gt;second;
+    }
+    return -1;
+}
+
+bool OutdoorPvP::HandleAreaTrigger(Player *plr, uint32 trigger)
+{
+    return false;
+}
+
+void OutdoorPvP::BroadcastPacket(WorldPacket &amp;data) const
+{
+    // This is faster than sWorld.SendZoneMessage
+    for (uint32 team = 0; team &lt; 2; ++team)
+        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            (*itr)-&gt;GetSession()-&gt;SendPacket(&amp;data);
+}
+
+void OutdoorPvP::RegisterZone(uint32 zoneId)
+{
+    sOutdoorPvPMgr.AddZone(zoneId, this);
+}
+
+bool OutdoorPvP::HasPlayer(Player *plr) const
+{
+    return m_players[plr-&gt;GetTeamId()].find(plr) != m_players[plr-&gt;GetTeamId()].end();
+}
+
+void OutdoorPvP::TeamCastSpell(TeamId team, int32 spellId)
+{
+    if(spellId &gt; 0)
+        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            (*itr)-&gt;CastSpell(*itr, (uint32)spellId, true);
+    else
+        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            (*itr)-&gt;RemoveAurasDueToSpell((uint32)-spellId); // by stack?
+}
+
+void OutdoorPvP::TeamApplyBuff(TeamId team, uint32 spellId, uint32 spellId2)
+{
+    TeamCastSpell(team, spellId);
+    TeamCastSpell(OTHER_TEAM(team), spellId2 ? -(int32)spellId2 : -(int32)spellId);
+}
+
+void OutdoorPvP::OnGameObjectCreate(GameObject *go, bool add)
+{
+    if(go-&gt;GetGoType() != GAMEOBJECT_TYPE_CAPTURE_POINT)
+        return;
+
+    if(OPvPCapturePoint *cp = GetCapturePoint(go-&gt;GetDBTableGUIDLow()))
+        cp-&gt;m_capturePoint = add ? go : NULL;
+}
\ No newline at end of file
diff --git a/src/game/OutdoorPvP.h b/src/game/OutdoorPvP.h
new file mode 100644
index 0000000..9f019e3
--- /dev/null
+++ b/src/game/OutdoorPvP.h
@@ -0,0 +1,261 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS &lt;http://www.MaNGOScore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef OUTDOOR_PVP_H_
+#define OUTDOOR_PVP_H_
+
+#include "Util.h"
+#include "SharedDefines.h"
+#include "ZoneScript.h"
+#include "Map.h"
+#include "ByteBuffer.h"
+#include "BattleGround.h"
+
+class GameObject;
+
+enum OutdoorPvPTypes
+{
+    OUTDOOR_PVP_HP = 1,
+    OUTDOOR_PVP_NA,
+    OUTDOOR_PVP_TF,
+    OUTDOOR_PVP_ZM,
+    OUTDOOR_PVP_SI,
+    OUTDOOR_PVP_EP,
+    OUTDOOR_PVP_GH,
+};
+
+const uint8 CapturePointArtKit[3] = {2, 1, 21};
+
+enum ObjectiveStates
+{
+    OBJECTIVESTATE_NEUTRAL = 0,
+    OBJECTIVESTATE_ALLIANCE,
+    OBJECTIVESTATE_HORDE,
+    OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE,
+    OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE,
+    OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE,
+    OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE,
+};
+
+// struct for go spawning
+struct go_type{
+    uint32 entry;
+    uint32 map;
+    float x;
+    float y;
+    float z;
+    float o;
+    float rot0;
+    float rot1;
+    float rot2;
+    float rot3;
+};
+
+// struct for creature spawning
+struct creature_type{
+    uint32 entry;
+    uint32 teamval;
+    uint32 map;
+    float x;
+    float y;
+    float z;
+    float o;
+};
+
+// some class predefs
+class Player;
+class GameObject;
+class WorldPacket;
+class Creature;
+class Unit;
+struct GossipMenuItems;
+
+typedef std::set&lt;Player*&gt; PlayerSet;
+
+class OutdoorPvP;
+class OPvPCapturePoint
+{
+public:
+    OPvPCapturePoint(OutdoorPvP * pvp);
+
+    virtual void FillInitialWorldStates(WorldPacket&amp; /*data*/, uint32&amp; /*count*/) {}
+
+    // send world state update to all players present
+    void SendUpdateWorldState(uint32 field, uint32 value);
+    // send kill notify to players in the controlling faction
+    void SendObjectiveComplete(uint32 id, uint64 guid);
+
+    // used when player is activated/inactivated in the area
+    virtual bool HandlePlayerEnter(Player * plr);
+    virtual void HandlePlayerLeave(Player * plr);
+    //virtual void HandlePlayerActivityChanged(Player * plr);
+
+    // checks if player is in range of a capture credit marker
+    bool IsInsideObjective(Player * plr) const;
+
+    virtual bool HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go);
+    virtual int32 HandleOpenGo(Player *plr, uint64 guid);
+
+    // returns true if the state of the objective has changed, in this case, the OutdoorPvP must send a world state ui update.
+    virtual bool Update(uint32 diff);
+    virtual void ChangeState() = 0;
+    virtual void ChangeTeam(TeamId oldTeam) {}
+    virtual void SendChangePhase();
+
+    virtual bool HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid);
+
+    virtual bool CanTalkTo(Player * plr, Creature * c, GossipMenuItems gso);
+
+    virtual bool HandleDropFlag(Player * plr, uint32 spellId);
+
+    virtual void DeleteSpawns();
+
+    uint32 m_capturePointGUID;
+    GameObject *m_capturePoint;
+
+    void AddGO(uint32 type, uint64 guid, uint32 entry = 0);
+    void AddCre(uint32 type, uint64 guid, uint32 entry = 0);
+    bool SetCapturePointData(uint32 entry, uint32 map, float x, float y, float z, float o = 0, float rotation0 = 0, float rotation1 = 0, float rotation2 = 0, float rotation3 = 0);
+
+protected:
+
+    bool AddObject(uint32 type, uint32 entry, uint32 map, float x, float y, float z, float o, float rotation0, float rotation1, float rotation2, float rotation3);
+    bool AddCreature(uint32 type, uint32 entry, uint32 teamval, uint32 map, float x, float y, float z, float o, uint32 spawntimedelay = 0);
+
+    bool DelCreature(uint32 type);
+    bool DelObject(uint32 type);
+    bool DelCapturePoint();
+
+protected:
+    // active players in the area of the objective, 0 - alliance, 1 - horde
+    PlayerSet m_activePlayers[2];
+    // total shift needed to capture the objective
+    float m_maxValue;
+    float m_minValue;
+    // maximum speed of capture
+    float m_maxSpeed;
+    // the status of the objective
+    float m_value;
+    TeamId m_team;
+    // objective states
+    ObjectiveStates m_OldState;
+    ObjectiveStates m_State;
+    // neutral value on capture bar
+    uint32 m_neutralValuePct;
+
+    // pointer to the OutdoorPvP this objective belongs to
+    OutdoorPvP* m_PvP;
+
+    // map to store the various gameobjects and creatures spawned by the objective
+    //        type , guid
+    std::map&lt;uint32,uint64&gt; m_Objects;
+    std::map&lt;uint32,uint64&gt; m_Creatures;
+    std::map&lt;uint64,uint32&gt; m_ObjectTypes;
+    std::map&lt;uint64,uint32&gt; m_CreatureTypes;
+};
+
+// base class for specific outdoor pvp handlers
+class OutdoorPvP : public ZoneScript
+{
+    friend class OutdoorPvPMgr;
+public:
+    // ctor
+    OutdoorPvP();
+    // dtor
+    ~OutdoorPvP();
+    // deletes all gos/creatures spawned by the pvp
+    void DeleteSpawns();
+
+    typedef std::map&lt;uint32/*lowguid*/, OPvPCapturePoint*&gt; OPvPCapturePointMap;
+
+    virtual void FillInitialWorldStates(WorldPacket&amp; /*data*/, uint32&amp; /*count*/) {}
+    // called when a player triggers an areatrigger
+    virtual bool HandleAreaTrigger(Player * plr, uint32 trigger);
+    // called on custom spell
+    virtual bool HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go);
+    // called on go use
+    virtual bool HandleOpenGo(Player *plr, uint64 guid);
+
+    // setup stuff
+    virtual bool SetupOutdoorPvP() {return true;}
+
+    void OnGameObjectCreate(GameObject *go, bool add);
+    void OnCreatureCreate(Creature *, bool add) {}
+
+    // send world state update to all players present
+    void SendUpdateWorldState(uint32 field, uint32 value);
+
+    // called by OutdoorPvPMgr, updates the objectives and if needed, sends new worldstateui information
+    virtual bool Update(uint32 diff);
+
+    // handle npc/player kill
+    virtual void HandleKill(Player * killer, Unit * killed);
+    virtual void HandleKillImpl(Player * killer, Unit * killed) {}
+
+    // checks if player is in range of a capture credit marker
+    bool IsInsideObjective(Player * plr) const;
+
+    // awards rewards for player kill
+    virtual void AwardKillBonus(Player * plr) {}
+
+    uint32 GetTypeId() {return m_TypeId;}
+
+    virtual bool HandleDropFlag(Player * plr, uint32 spellId);
+
+    virtual bool HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid);
+
+    virtual bool CanTalkTo(Player * plr, Creature * c, GossipMenuItems gso);
+
+    void TeamApplyBuff(TeamId team, uint32 spellId, uint32 spellId2 = 0);
+protected:
+    // the map of the objectives belonging to this outdoorpvp
+    OPvPCapturePointMap m_capturePoints;
+
+    PlayerSet m_players[2];
+    uint32 m_TypeId;
+
+    bool m_sendUpdate;
+
+    // world state stuff
+    virtual void SendRemoveWorldStates(Player * plr) {}
+
+    void BroadcastPacket(WorldPacket &amp; data) const;
+
+    virtual void HandlePlayerEnterZone(Player * plr, uint32 zone);
+    virtual void HandlePlayerLeaveZone(Player * plr, uint32 zone);
+    virtual void HandlePlayerResurrects(Player * plr, uint32 zone);
+
+    void AddCapturePoint(OPvPCapturePoint* cp)
+    {
+        m_capturePoints[cp-&gt;m_capturePointGUID] = cp;
+    }
+
+    OPvPCapturePoint * GetCapturePoint(uint32 lowguid) const
+    {
+        OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.find(lowguid);
+        if(itr != m_capturePoints.end())
+            return itr-&gt;second;
+        return NULL;
+    }
+
+    void RegisterZone(uint32 zoneid);
+    bool HasPlayer(Player *plr) const;
+    void TeamCastSpell(TeamId team, int32 spellId);
+};
+
+#endif /*OUTDOOR_PVP_H_*/
\ No newline at end of file
diff --git a/src/game/OutdoorPvPEP.cpp b/src/game/OutdoorPvPEP.cpp
new file mode 100644
index 0000000..b0f56ff
--- /dev/null
+++ b/src/game/OutdoorPvPEP.cpp
@@ -0,0 +1,764 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS &lt;http://www.MaNGOScore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvPEP.h"
+#include "WorldPacket.h"
+#include "Player.h"
+#include "GameObject.h"
+#include "ObjectMgr.h"
+#include "ObjectAccessor.h"
+#include "OutdoorPvPMgr.h"
+#include "Creature.h"
+#include "Language.h"
+#include "World.h"
+#include "GossipDef.h"
+
+OPvPCapturePointEP_EWT::OPvPCapturePointEP_EWT(OutdoorPvP *pvp)
+: OPvPCapturePoint(pvp), m_TowerState(EP_TS_N), m_UnitsSummonedSide(0)
+{
+    SetCapturePointData(EPCapturePoints[EP_EWT].entry,EPCapturePoints[EP_EWT].map,EPCapturePoints[EP_EWT].x,EPCapturePoints[EP_EWT].y,EPCapturePoints[EP_EWT].z,EPCapturePoints[EP_EWT].o,EPCapturePoints[EP_EWT].rot0,EPCapturePoints[EP_EWT].rot1,EPCapturePoints[EP_EWT].rot2,EPCapturePoints[EP_EWT].rot3);
+    AddObject(EP_EWT_FLAGS,EPTowerFlags[EP_EWT].entry,EPTowerFlags[EP_EWT].map,EPTowerFlags[EP_EWT].x,EPTowerFlags[EP_EWT].y,EPTowerFlags[EP_EWT].z,EPTowerFlags[EP_EWT].o,EPTowerFlags[EP_EWT].rot0,EPTowerFlags[EP_EWT].rot1,EPTowerFlags[EP_EWT].rot2,EPTowerFlags[EP_EWT].rot3);
+}
+
+void OPvPCapturePointEP_EWT::ChangeState()
+{
+    if(fabs(m_value) == m_maxValue)  // state won't change, only phase when maxed out!
+    {
+        // if changing from controlling alliance to horde or vice versa
+        if( m_OldState == OBJECTIVESTATE_ALLIANCE &amp;&amp; m_OldState != m_State )
+        {
+            sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_LOOSE_EWT_A));
+            ((OutdoorPvPEP*)m_PvP)-&gt;EP_Controls[EP_EWT] = 0;
+        }
+        else if ( m_OldState == OBJECTIVESTATE_HORDE &amp;&amp; m_OldState != m_State )
+        {
+            sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_LOOSE_EWT_H));
+            ((OutdoorPvPEP*)m_PvP)-&gt;EP_Controls[EP_EWT] = 0;
+        }
+
+        uint32 artkit = 21;
+
+        switch(m_State)
+        {
+        case OBJECTIVESTATE_ALLIANCE:
+            if(m_value == m_maxValue)
+                m_TowerState = EP_TS_A;
+            else
+                m_TowerState = EP_TS_A_P;
+            artkit = 2;
+            SummonSupportUnitAtNorthpassTower(ALLIANCE);
+            ((OutdoorPvPEP*)m_PvP)-&gt;EP_Controls[EP_EWT] = ALLIANCE;
+            if(m_OldState != m_State) sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_CAPTURE_EWT_A));
+            break;
+        case OBJECTIVESTATE_HORDE:
+            if(m_value == -m_maxValue)
+                m_TowerState = EP_TS_H;
+            else
+                m_TowerState = EP_TS_H_P;
+            artkit = 1;
+            SummonSupportUnitAtNorthpassTower(HORDE);
+            ((OutdoorPvPEP*)m_PvP)-&gt;EP_Controls[EP_EWT] = HORDE;
+            if(m_OldState != m_State) sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_CAPTURE_EWT_H));
+            break;
+        case OBJECTIVESTATE_NEUTRAL:
+            m_TowerState = EP_TS_N;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+            m_TowerState = EP_TS_N_A;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+            m_TowerState = EP_TS_N_H;
+            break;
+        }
+
+        GameObject* flag = ObjectAccessor::GetGameObjectInWorld(ObjectGuid(HIGHGUID_GAMEOBJECT, m_capturePointGUID));
+        GameObject * flag2 = ObjectAccessor::GetGameObjectInWorld(ObjectGuid(HIGHGUID_GAMEOBJECT, m_Objects[EP_EWT_FLAGS]));
+        if(flag)
+        {
+            flag-&gt;SetGoArtKit(artkit);
+        }
+        if(flag2)
+        {
+            flag2-&gt;SetGoArtKit(artkit);
+        }
+
+        UpdateTowerState();
+
+        // complete quest objective
+        if(m_TowerState == EP_TS_A || m_TowerState == EP_TS_H)
+            SendObjectiveComplete(EP_EWT_CM, 0);
+    }
+}
+
+void OPvPCapturePointEP_EWT::SendChangePhase()
+{
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+    // send these updates to only the ones in this objective
+    uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+    // send this too, sometimes it resets :S
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+}
+
+void OPvPCapturePointEP_EWT::FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count)
+{
+    FillInitialWorldState(data, count, EP_EWT_A,   bool(m_TowerState &amp; EP_TS_A));
+    FillInitialWorldState(data, count, EP_EWT_H,   bool(m_TowerState &amp; EP_TS_H));
+    FillInitialWorldState(data, count, EP_EWT_A_P, bool(m_TowerState &amp; EP_TS_A_P));
+    FillInitialWorldState(data, count, EP_EWT_H_P, bool(m_TowerState &amp; EP_TS_H_P));
+    FillInitialWorldState(data, count, EP_EWT_N_A, bool(m_TowerState &amp; EP_TS_N_A));
+    FillInitialWorldState(data, count, EP_EWT_N_H, bool(m_TowerState &amp; EP_TS_N_H));
+    FillInitialWorldState(data, count, EP_EWT_N,   bool(m_TowerState &amp; EP_TS_N));
+}
+
+void OPvPCapturePointEP_EWT::UpdateTowerState()
+{
+    m_PvP-&gt;SendUpdateWorldState(EP_EWT_A , bool(m_TowerState &amp; EP_TS_A));
+    m_PvP-&gt;SendUpdateWorldState(EP_EWT_H , bool(m_TowerState &amp; EP_TS_H));
+    m_PvP-&gt;SendUpdateWorldState(EP_EWT_A_P , bool(m_TowerState &amp; EP_TS_A_P));
+    m_PvP-&gt;SendUpdateWorldState(EP_EWT_H_P , bool(m_TowerState &amp; EP_TS_H_P));
+    m_PvP-&gt;SendUpdateWorldState(EP_EWT_N_A , bool(m_TowerState &amp; EP_TS_N_A));
+    m_PvP-&gt;SendUpdateWorldState(EP_EWT_N_H , bool(m_TowerState &amp; EP_TS_N_H));
+    m_PvP-&gt;SendUpdateWorldState(EP_EWT_N , bool(m_TowerState &amp; EP_TS_N));
+}
+
+bool OPvPCapturePointEP_EWT::HandlePlayerEnter(Player *plr)
+{
+    if(OPvPCapturePoint::HandlePlayerEnter(plr))
+    {
+        plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+        plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+        plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+        return true;
+    }
+    return false;
+}
+
+void OPvPCapturePointEP_EWT::HandlePlayerLeave(Player *plr)
+{
+    plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OPvPCapturePoint::HandlePlayerLeave(plr);
+}
+
+void OPvPCapturePointEP_EWT::SummonSupportUnitAtNorthpassTower(uint32 team)
+{
+    if(m_UnitsSummonedSide != team)
+    {
+        m_UnitsSummonedSide = team;
+        const creature_type * ct = NULL;
+        if(team == ALLIANCE)
+            ct=EP_EWT_Summons_A;
+        else
+            ct=EP_EWT_Summons_H;
+
+        for (int i = 0; i &lt; EP_EWT_NUM_CREATURES; ++i)
+        {
+            DelCreature(i);
+            AddCreature(i,ct[i].entry,ct[i].teamval,ct[i].map,ct[i].x,ct[i].y,ct[i].z,ct[i].o,1000000);
+        }
+    }
+}
+
+// NPT
+OPvPCapturePointEP_NPT::OPvPCapturePointEP_NPT(OutdoorPvP *pvp)
+: OPvPCapturePoint(pvp), m_TowerState(EP_TS_N), m_SummonedGOSide(0)
+{
+    SetCapturePointData(EPCapturePoints[EP_NPT].entry,EPCapturePoints[EP_NPT].map,EPCapturePoints[EP_NPT].x,EPCapturePoints[EP_NPT].y,EPCapturePoints[EP_NPT].z,EPCapturePoints[EP_NPT].o,EPCapturePoints[EP_NPT].rot0,EPCapturePoints[EP_NPT].rot1,EPCapturePoints[EP_NPT].rot2,EPCapturePoints[EP_NPT].rot3);
+    AddObject(EP_NPT_FLAGS,EPTowerFlags[EP_NPT].entry,EPTowerFlags[EP_NPT].map,EPTowerFlags[EP_NPT].x,EPTowerFlags[EP_NPT].y,EPTowerFlags[EP_NPT].z,EPTowerFlags[EP_NPT].o,EPTowerFlags[EP_NPT].rot0,EPTowerFlags[EP_NPT].rot1,EPTowerFlags[EP_NPT].rot2,EPTowerFlags[EP_NPT].rot3);
+}
+
+void OPvPCapturePointEP_NPT::ChangeState()
+{
+    if(fabs(m_value) == m_maxValue)  // state won't change, only phase when maxed out!
+    {
+        // if changing from controlling alliance to horde or vice versa
+        if( m_OldState == OBJECTIVESTATE_ALLIANCE &amp;&amp; m_OldState != m_State )
+        {
+            sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_LOOSE_NPT_A));
+            ((OutdoorPvPEP*)m_PvP)-&gt;EP_Controls[EP_NPT] = 0;
+        }
+        else if ( m_OldState == OBJECTIVESTATE_HORDE &amp;&amp; m_OldState != m_State )
+        {
+            sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_LOOSE_NPT_H));
+            ((OutdoorPvPEP*)m_PvP)-&gt;EP_Controls[EP_NPT] = 0;
+        }
+
+        uint32 artkit = 21;
+
+        switch(m_State)
+        {
+        case OBJECTIVESTATE_ALLIANCE:
+            if(m_value == m_maxValue)
+                m_TowerState = EP_TS_A;
+            else
+                m_TowerState = EP_TS_A_P;
+            artkit = 2;
+            SummonGO(ALLIANCE);
+            ((OutdoorPvPEP*)m_PvP)-&gt;EP_Controls[EP_NPT] = ALLIANCE;
+            if(m_OldState != m_State) sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_CAPTURE_NPT_A));
+            break;
+        case OBJECTIVESTATE_HORDE:
+            if(m_value == -m_maxValue)
+                m_TowerState = EP_TS_H;
+            else
+                m_TowerState = EP_TS_H_P;
+            artkit = 1;
+            SummonGO(HORDE);
+            ((OutdoorPvPEP*)m_PvP)-&gt;EP_Controls[EP_NPT] = HORDE;
+            if(m_OldState != m_State) sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_CAPTURE_NPT_H));
+            break;
+        case OBJECTIVESTATE_NEUTRAL:
+            m_TowerState = EP_TS_N;
+            m_SummonedGOSide = 0;
+            DelObject(EP_NPT_BUFF);
+            break;
+        case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+            m_TowerState = EP_TS_N_A;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+            m_TowerState = EP_TS_N_H;
+            break;
+        }
+
+        GameObject * flag = ObjectAccessor::GetGameObjectInWorld(ObjectGuid(HIGHGUID_GAMEOBJECT, m_capturePointGUID));
+        GameObject * flag2 = ObjectAccessor::GetGameObjectInWorld(ObjectGuid(HIGHGUID_GAMEOBJECT, m_Objects[EP_NPT_FLAGS]));
+        if(flag)
+        {
+            flag-&gt;SetGoArtKit(artkit);
+        }
+        if(flag2)
+        {
+            flag2-&gt;SetGoArtKit(artkit);
+        }
+
+        UpdateTowerState();
+
+        // complete quest objective
+        if(m_TowerState == EP_TS_A || m_TowerState == EP_TS_H)
+            SendObjectiveComplete(EP_NPT_CM, 0);
+    }
+}
+
+void OPvPCapturePointEP_NPT::SendChangePhase()
+{
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+    // send these updates to only the ones in this objective
+    uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+    // send this too, sometimes it resets :S
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+}
+
+void OPvPCapturePointEP_NPT::FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count)
+{
+    FillInitialWorldState(data, count, EP_NPT_A,   bool(m_TowerState &amp; EP_TS_A));
+    FillInitialWorldState(data, count, EP_NPT_H,   bool(m_TowerState &amp; EP_TS_H));
+    FillInitialWorldState(data, count, EP_NPT_A_P, bool(m_TowerState &amp; EP_TS_A_P));
+    FillInitialWorldState(data, count, EP_NPT_H_P,  bool(m_TowerState &amp; EP_TS_H_P));
+    FillInitialWorldState(data, count, EP_NPT_N_A, bool(m_TowerState &amp; EP_TS_N_A));
+    FillInitialWorldState(data, count, EP_NPT_N_H, bool(m_TowerState &amp; EP_TS_N_H));
+    FillInitialWorldState(data, count, EP_NPT_N,   bool(m_TowerState &amp; EP_TS_N));
+}
+
+void OPvPCapturePointEP_NPT::UpdateTowerState()
+{
+    m_PvP-&gt;SendUpdateWorldState(EP_NPT_A , bool(m_TowerState &amp; EP_TS_A));
+    m_PvP-&gt;SendUpdateWorldState(EP_NPT_H , bool(m_TowerState &amp; EP_TS_H));
+    m_PvP-&gt;SendUpdateWorldState(EP_NPT_A_P , bool(m_TowerState &amp; EP_TS_A_P));
+    m_PvP-&gt;SendUpdateWorldState(EP_NPT_H_P , bool(m_TowerState &amp; EP_TS_H_P));
+    m_PvP-&gt;SendUpdateWorldState(EP_NPT_N_A , bool(m_TowerState &amp; EP_TS_N_A));
+    m_PvP-&gt;SendUpdateWorldState(EP_NPT_N_H , bool(m_TowerState &amp; EP_TS_N_H));
+    m_PvP-&gt;SendUpdateWorldState(EP_NPT_N , bool(m_TowerState &amp; EP_TS_N));
+}
+
+bool OPvPCapturePointEP_NPT::HandlePlayerEnter(Player *plr)
+{
+    if(OPvPCapturePoint::HandlePlayerEnter(plr))
+    {
+        plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+        plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+        plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+        return true;
+    }
+    return false;
+}
+
+void OPvPCapturePointEP_NPT::HandlePlayerLeave(Player *plr)
+{
+    plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OPvPCapturePoint::HandlePlayerLeave(plr);
+}
+
+void OPvPCapturePointEP_NPT::SummonGO(uint32 team)
+{
+    if(m_SummonedGOSide != team)
+    {
+        m_SummonedGOSide = team;
+        DelObject(EP_NPT_BUFF);
+        AddObject(EP_NPT_BUFF,EP_NPT_LordaeronShrine.entry,EP_NPT_LordaeronShrine.map,EP_NPT_LordaeronShrine.x,EP_NPT_LordaeronShrine.y,EP_NPT_LordaeronShrine.z,EP_NPT_LordaeronShrine.o,EP_NPT_LordaeronShrine.rot0,EP_NPT_LordaeronShrine.rot1,EP_NPT_LordaeronShrine.rot2,EP_NPT_LordaeronShrine.rot3);
+        GameObject * go = ObjectAccessor::GetGameObjectInWorld(m_Objects[EP_NPT_BUFF]);
+        if(go)
+            go-&gt;SetUInt32Value(GAMEOBJECT_FACTION,(team == ALLIANCE ? 84 : 83));
+    }
+}
+
+// CGT
+OPvPCapturePointEP_CGT::OPvPCapturePointEP_CGT(OutdoorPvP *pvp)
+: OPvPCapturePoint(pvp), m_TowerState(EP_TS_N), m_GraveyardSide(0)
+{
+    SetCapturePointData(EPCapturePoints[EP_CGT].entry,EPCapturePoints[EP_CGT].map,EPCapturePoints[EP_CGT].x,EPCapturePoints[EP_CGT].y,EPCapturePoints[EP_CGT].z,EPCapturePoints[EP_CGT].o,EPCapturePoints[EP_CGT].rot0,EPCapturePoints[EP_CGT].rot1,EPCapturePoints[EP_CGT].rot2,EPCapturePoints[EP_CGT].rot3);
+    AddObject(EP_CGT_FLAGS,EPTowerFlags[EP_CGT].entry,EPTowerFlags[EP_CGT].map,EPTowerFlags[EP_CGT].x,EPTowerFlags[EP_CGT].y,EPTowerFlags[EP_CGT].z,EPTowerFlags[EP_CGT].o,EPTowerFlags[EP_CGT].rot0,EPTowerFlags[EP_CGT].rot1,EPTowerFlags[EP_CGT].rot2,EPTowerFlags[EP_CGT].rot3);
+}
+
+void OPvPCapturePointEP_CGT::ChangeState()
+{
+    if(fabs(m_value) == m_maxValue)  // state won't change, only phase when maxed out!
+    {
+        // if changing from controlling alliance to horde or vice versa
+        if( m_OldState == OBJECTIVESTATE_ALLIANCE &amp;&amp; m_OldState != m_State )
+        {
+            sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_LOOSE_CGT_A));
+            ((OutdoorPvPEP*)m_PvP)-&gt;EP_Controls[EP_CGT] = 0;
+        }
+        else if ( m_OldState == OBJECTIVESTATE_HORDE &amp;&amp; m_OldState != m_State )
+        {
+            sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_LOOSE_CGT_H));
+            ((OutdoorPvPEP*)m_PvP)-&gt;EP_Controls[EP_CGT] = 0;
+        }
+
+        uint32 artkit = 21;
+
+        switch(m_State)
+        {
+        case OBJECTIVESTATE_ALLIANCE:
+            if(m_value == m_maxValue)
+                m_TowerState = EP_TS_A;
+            else
+                m_TowerState = EP_TS_A_P;
+            artkit = 2;
+            LinkGraveYard(ALLIANCE);
+            ((OutdoorPvPEP*)m_PvP)-&gt;EP_Controls[EP_CGT] = ALLIANCE;
+            if(m_OldState != m_State) sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_CAPTURE_CGT_A));
+            break;
+        case OBJECTIVESTATE_HORDE:
+            if(m_value == -m_maxValue)
+                m_TowerState = EP_TS_H;
+            else
+                m_TowerState = EP_TS_H_P;
+            artkit = 1;
+            LinkGraveYard(HORDE);
+            ((OutdoorPvPEP*)m_PvP)-&gt;EP_Controls[EP_CGT] = HORDE;
+            if(m_OldState != m_State) sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_CAPTURE_CGT_H));
+            break;
+        case OBJECTIVESTATE_NEUTRAL:
+            m_TowerState = EP_TS_N;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+            m_TowerState = EP_TS_N_A;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+            m_TowerState = EP_TS_N_H;
+            break;
+        }
+
+        GameObject* flag = ObjectAccessor::GetGameObjectInWorld(ObjectGuid(HIGHGUID_GAMEOBJECT, m_capturePointGUID));
+        GameObject* flag2 = ObjectAccessor::GetGameObjectInWorld(ObjectGuid(HIGHGUID_GAMEOBJECT,m_Objects[EP_CGT_FLAGS]));
+        if(flag)
+        {
+            flag-&gt;SetGoArtKit(artkit);
+        }
+        if(flag2)
+        {
+            flag2-&gt;SetGoArtKit(artkit);
+        }
+
+        UpdateTowerState();
+
+        // complete quest objective
+        if(m_TowerState == EP_TS_A || m_TowerState == EP_TS_H)
+            SendObjectiveComplete(EP_CGT_CM, 0);
+    }
+}
+
+void OPvPCapturePointEP_CGT::SendChangePhase()
+{
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+    // send these updates to only the ones in this objective
+    uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+    // send this too, sometimes it resets :S
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+}
+
+void OPvPCapturePointEP_CGT::FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count)
+{
+    FillInitialWorldState(data, count, EP_CGT_A,   bool(m_TowerState &amp; EP_TS_A));
+    FillInitialWorldState(data, count, EP_CGT_H,   bool(m_TowerState &amp; EP_TS_H));
+    FillInitialWorldState(data, count, EP_CGT_A_P, bool(m_TowerState &amp; EP_TS_A_P));
+    FillInitialWorldState(data, count, EP_CGT_H_P, bool(m_TowerState &amp; EP_TS_H_P));
+    FillInitialWorldState(data, count, EP_CGT_N_A, bool(m_TowerState &amp; EP_TS_N_A));
+    FillInitialWorldState(data, count, EP_CGT_N_H, bool(m_TowerState &amp; EP_TS_N_H));
+    FillInitialWorldState(data, count, EP_CGT_N,   bool(m_TowerState &amp; EP_TS_N));
+}
+
+void OPvPCapturePointEP_CGT::UpdateTowerState()
+{
+    m_PvP-&gt;SendUpdateWorldState(EP_CGT_A , bool(m_TowerState &amp; EP_TS_A));
+    m_PvP-&gt;SendUpdateWorldState(EP_CGT_H , bool(m_TowerState &amp; EP_TS_H));
+    m_PvP-&gt;SendUpdateWorldState(EP_CGT_A_P , bool(m_TowerState &amp; EP_TS_A_P));
+    m_PvP-&gt;SendUpdateWorldState(EP_CGT_H_P , bool(m_TowerState &amp; EP_TS_H_P));
+    m_PvP-&gt;SendUpdateWorldState(EP_CGT_N_A , bool(m_TowerState &amp; EP_TS_N_A));
+    m_PvP-&gt;SendUpdateWorldState(EP_CGT_N_H , bool(m_TowerState &amp; EP_TS_N_H));
+    m_PvP-&gt;SendUpdateWorldState(EP_CGT_N , bool(m_TowerState &amp; EP_TS_N));
+}
+
+bool OPvPCapturePointEP_CGT::HandlePlayerEnter(Player *plr)
+{
+    if(OPvPCapturePoint::HandlePlayerEnter(plr))
+    {
+        plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+        plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+        plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+        return true;
+    }
+    return false;
+}
+
+void OPvPCapturePointEP_CGT::HandlePlayerLeave(Player *plr)
+{
+    plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OPvPCapturePoint::HandlePlayerLeave(plr);
+}
+
+void OPvPCapturePointEP_CGT::LinkGraveYard(uint32 team)
+{
+    if(m_GraveyardSide != team)
+    {
+        m_GraveyardSide = team;
+        sObjectMgr.RemoveGraveYardLink(EP_GraveYardId,EP_GraveYardZone,team,false);
+        sObjectMgr.AddGraveYardLink(EP_GraveYardId,EP_GraveYardZone,team,false);
+    }
+}
+
+// PWT
+OPvPCapturePointEP_PWT::OPvPCapturePointEP_PWT(OutdoorPvP *pvp)
+: OPvPCapturePoint(pvp), m_TowerState(EP_TS_N), m_FlightMasterSpawned(0)
+{
+    SetCapturePointData(EPCapturePoints[EP_PWT].entry,EPCapturePoints[EP_PWT].map,EPCapturePoints[EP_PWT].x,EPCapturePoints[EP_PWT].y,EPCapturePoints[EP_PWT].z,EPCapturePoints[EP_PWT].o,EPCapturePoints[EP_PWT].rot0,EPCapturePoints[EP_PWT].rot1,EPCapturePoints[EP_PWT].rot2,EPCapturePoints[EP_PWT].rot3);
+    AddObject(EP_PWT_FLAGS,EPTowerFlags[EP_PWT].entry,EPTowerFlags[EP_PWT].map,EPTowerFlags[EP_PWT].x,EPTowerFlags[EP_PWT].y,EPTowerFlags[EP_PWT].z,EPTowerFlags[EP_PWT].o,EPTowerFlags[EP_PWT].rot0,EPTowerFlags[EP_PWT].rot1,EPTowerFlags[EP_PWT].rot2,EPTowerFlags[EP_PWT].rot3);
+}
+
+void OPvPCapturePointEP_PWT::ChangeState()
+{
+    if(fabs(m_value) == m_maxValue)  // state won't change, only phase when maxed out!
+    {
+        // if changing from controlling alliance to horde or vice versa
+        if( m_OldState == OBJECTIVESTATE_ALLIANCE &amp;&amp; m_OldState != m_State )
+        {
+            sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_LOOSE_PWT_A));
+            ((OutdoorPvPEP*)m_PvP)-&gt;EP_Controls[EP_PWT] = 0;
+        }
+        else if ( m_OldState == OBJECTIVESTATE_HORDE &amp;&amp; m_OldState != m_State )
+        {
+            sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_LOOSE_PWT_H));
+            ((OutdoorPvPEP*)m_PvP)-&gt;EP_Controls[EP_PWT] = 0;
+        }
+
+        uint32 artkit = 21;
+
+        switch(m_State)
+        {
+        case OBJECTIVESTATE_ALLIANCE:
+            if(m_value == m_maxValue)
+                m_TowerState = EP_TS_A;
+            else
+                m_TowerState = EP_TS_A_P;
+            SummonFlightMaster(ALLIANCE);
+            artkit = 2;
+            ((OutdoorPvPEP*)m_PvP)-&gt;EP_Controls[EP_PWT] = ALLIANCE;
+            if(m_OldState != m_State) sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_CAPTURE_PWT_A));
+            break;
+        case OBJECTIVESTATE_HORDE:
+            if(m_value == -m_maxValue)
+                m_TowerState = EP_TS_H;
+            else
+                m_TowerState = EP_TS_H_P;
+            SummonFlightMaster(HORDE);
+            artkit = 1;
+            ((OutdoorPvPEP*)m_PvP)-&gt;EP_Controls[EP_PWT] = HORDE;
+            if(m_OldState != m_State) sWorld.SendZoneText(EP_GraveYardZone,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_EP_CAPTURE_PWT_H));
+            break;
+        case OBJECTIVESTATE_NEUTRAL:
+            m_TowerState = EP_TS_N;
+            DelCreature(EP_PWT_FLIGHTMASTER);
+            m_FlightMasterSpawned = 0;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+            m_TowerState = EP_TS_N_A;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+            m_TowerState = EP_TS_N_H;
+            break;
+        }
+
+        GameObject * flag = ObjectAccessor::GetGameObjectInWorld(ObjectGuid(HIGHGUID_GAMEOBJECT, m_capturePointGUID));
+        GameObject * flag2 = ObjectAccessor::GetGameObjectInWorld(ObjectGuid(HIGHGUID_GAMEOBJECT, m_Objects[EP_PWT_FLAGS]));
+        if(flag)
+        {
+            flag-&gt;SetGoArtKit(artkit);
+        }
+        if(flag2)
+        {
+            flag2-&gt;SetGoArtKit(artkit);
+        }
+
+        UpdateTowerState();
+
+        // complete quest objective
+        if(m_TowerState == EP_TS_A || m_TowerState == EP_TS_H)
+            SendObjectiveComplete(EP_PWT_CM, 0);
+    }
+}
+
+void OPvPCapturePointEP_PWT::SendChangePhase()
+{
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+    // send these updates to only the ones in this objective
+    uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+    // send this too, sometimes it resets :S
+    SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+}
+
+void OPvPCapturePointEP_PWT::FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count)
+{
+    FillInitialWorldState(data, count, EP_PWT_A,   bool(m_TowerState &amp; EP_TS_A));
+    FillInitialWorldState(data, count, EP_PWT_H,   bool(m_TowerState &amp; EP_TS_H));
+    FillInitialWorldState(data, count, EP_PWT_A_P, bool(m_TowerState &amp; EP_TS_A_P));
+    FillInitialWorldState(data, count, EP_PWT_H_P, bool(m_TowerState &amp; EP_TS_H_P));
+    FillInitialWorldState(data, count, EP_PWT_N_A, bool(m_TowerState &amp; EP_TS_N_A));
+    FillInitialWorldState(data, count, EP_PWT_N_H, bool(m_TowerState &amp; EP_TS_N_H));
+    FillInitialWorldState(data, count, EP_PWT_N,   bool(m_TowerState &amp; EP_TS_N));
+}
+
+void OPvPCapturePointEP_PWT::UpdateTowerState()
+{
+    m_PvP-&gt;SendUpdateWorldState(EP_PWT_A , bool(m_TowerState &amp; EP_TS_A));
+    m_PvP-&gt;SendUpdateWorldState(EP_PWT_H , bool(m_TowerState &amp; EP_TS_H));
+    m_PvP-&gt;SendUpdateWorldState(EP_PWT_A_P , bool(m_TowerState &amp; EP_TS_A_P));
+    m_PvP-&gt;SendUpdateWorldState(EP_PWT_H_P , bool(m_TowerState &amp; EP_TS_H_P));
+    m_PvP-&gt;SendUpdateWorldState(EP_PWT_N_A , bool(m_TowerState &amp; EP_TS_N_A));
+    m_PvP-&gt;SendUpdateWorldState(EP_PWT_N_H , bool(m_TowerState &amp; EP_TS_N_H));
+    m_PvP-&gt;SendUpdateWorldState(EP_PWT_N , bool(m_TowerState &amp; EP_TS_N));
+}
+
+bool OPvPCapturePointEP_PWT::HandlePlayerEnter(Player *plr)
+{
+    if(OPvPCapturePoint::HandlePlayerEnter(plr))
+    {
+        plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+        plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS, phase);
+        plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+        return true;
+    }
+    return false;
+}
+
+void OPvPCapturePointEP_PWT::HandlePlayerLeave(Player *plr)
+{
+    plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OPvPCapturePoint::HandlePlayerLeave(plr);
+}
+
+void OPvPCapturePointEP_PWT::SummonFlightMaster(uint32 team)
+{
+    if(m_FlightMasterSpawned != team)
+    {
+        m_FlightMasterSpawned = team;
+        DelCreature(EP_PWT_FLIGHTMASTER);
+        AddCreature(EP_PWT_FLIGHTMASTER,EP_PWT_FlightMaster.entry,team,EP_PWT_FlightMaster.map,EP_PWT_FlightMaster.x,EP_PWT_FlightMaster.y,EP_PWT_FlightMaster.z,EP_PWT_FlightMaster.o);
+    }
+}
+
+// ep
+OutdoorPvPEP::OutdoorPvPEP()
+{
+    m_TypeId = OUTDOOR_PVP_EP;
+    memset(EP_Controls,0,sizeof(EP_Controls));
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+}
+
+bool OutdoorPvPEP::SetupOutdoorPvP()
+{
+    for (int i = 0; i &lt; EPBuffZonesNum; ++i)
+        RegisterZone(EPBuffZones[i]);
+
+    AddCapturePoint(new OPvPCapturePointEP_EWT(this));
+    AddCapturePoint(new OPvPCapturePointEP_PWT(this));
+    AddCapturePoint(new OPvPCapturePointEP_CGT(this));
+    AddCapturePoint(new OPvPCapturePointEP_NPT(this));
+    return true;
+}
+
+bool OutdoorPvPEP::Update(uint32 diff)
+{
+    if(OutdoorPvP::Update(diff))
+    {
+        m_AllianceTowersControlled = 0;
+        m_HordeTowersControlled = 0;
+        for (int i = 0; i &lt; EP_TOWER_NUM; ++i)
+        {
+            if(EP_Controls[i] == ALLIANCE)
+                ++m_AllianceTowersControlled;
+            else if(EP_Controls[i] == HORDE)
+                ++m_HordeTowersControlled;
+            SendUpdateWorldState(EP_UI_TOWER_COUNT_A,m_AllianceTowersControlled);
+            SendUpdateWorldState(EP_UI_TOWER_COUNT_H,m_HordeTowersControlled);
+            BuffTeams();
+        }
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPEP::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    // add buffs
+    if(plr-&gt;GetTeam() == ALLIANCE)
+    {
+        if(m_AllianceTowersControlled &amp;&amp; m_AllianceTowersControlled &lt; 5)
+            plr-&gt;CastSpell(plr,EP_AllianceBuffs[m_AllianceTowersControlled-1],true);
+    }
+    else
+    {
+        if(m_HordeTowersControlled &amp;&amp; m_HordeTowersControlled &lt; 5)
+            plr-&gt;CastSpell(plr,EP_HordeBuffs[m_HordeTowersControlled-1],true);
+    }
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPEP::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    if(plr-&gt;GetTeam() == ALLIANCE)
+    {
+        for (int i = 0; i &lt; 4; ++i)
+            plr-&gt;RemoveAurasDueToSpell(EP_AllianceBuffs[i]);
+    }
+    else
+    {
+        for (int i = 0; i &lt; 4; ++i)
+            plr-&gt;RemoveAurasDueToSpell(EP_HordeBuffs[i]);
+    }
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+void OutdoorPvPEP::BuffTeams()
+{
+    for (PlayerSet::iterator itr = m_players[0].begin(); itr != m_players[0].end(); ++itr)
+    {
+        Player * plr = *itr;
+        {
+            for (int i = 0; i &lt; 4; ++i)
+                plr-&gt;RemoveAurasDueToSpell(EP_AllianceBuffs[i]);
+            if(m_AllianceTowersControlled &amp;&amp; m_AllianceTowersControlled &lt; 5)
+                plr-&gt;CastSpell(plr,EP_AllianceBuffs[m_AllianceTowersControlled-1],true);
+        }
+    }
+    for (PlayerSet::iterator itr = m_players[1].begin(); itr != m_players[1].end(); ++itr)
+    {
+        Player * plr = *itr;
+        {
+            for (int i = 0; i &lt; 4; ++i)
+                plr-&gt;RemoveAurasDueToSpell(EP_HordeBuffs[i]);
+            if(m_HordeTowersControlled &amp;&amp; m_HordeTowersControlled &lt; 5)
+                plr-&gt;CastSpell(plr,EP_HordeBuffs[m_HordeTowersControlled-1],true);
+        }
+    }
+}
+
+void OutdoorPvPEP::FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count)
+{
+    FillInitialWorldState(data, count, EP_UI_TOWER_COUNT_A,        m_AllianceTowersControlled);
+    FillInitialWorldState(data, count, EP_UI_TOWER_COUNT_H,        m_HordeTowersControlled);
+    FillInitialWorldState(data, count, EP_UI_TOWER_SLIDER_DISPLAY, 0);
+    FillInitialWorldState(data, count, EP_UI_TOWER_SLIDER_POS,     50);
+    FillInitialWorldState(data, count, EP_UI_TOWER_SLIDER_N,       100);
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+    {
+        itr-&gt;second-&gt;FillInitialWorldStates(data, count);
+    }
+}
+
+void OutdoorPvPEP::SendRemoveWorldStates(Player *plr)
+{
+    plr-&gt;SendUpdateWorldState(EP_UI_TOWER_COUNT_A,0);
+    plr-&gt;SendUpdateWorldState(EP_UI_TOWER_COUNT_H,0);
+    plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_DISPLAY,0);
+    plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_POS,0);
+    plr-&gt;SendUpdateWorldState(EP_UI_TOWER_SLIDER_N,0);
+
+    plr-&gt;SendUpdateWorldState(EP_EWT_A,0);
+    plr-&gt;SendUpdateWorldState(EP_EWT_H,0);
+    plr-&gt;SendUpdateWorldState(EP_EWT_N,0);
+    plr-&gt;SendUpdateWorldState(EP_EWT_A_P,0);
+    plr-&gt;SendUpdateWorldState(EP_EWT_H_P,0);
+    plr-&gt;SendUpdateWorldState(EP_EWT_N_A,0);
+    plr-&gt;SendUpdateWorldState(EP_EWT_N_H,0);
+
+    plr-&gt;SendUpdateWorldState(EP_PWT_A,0);
+    plr-&gt;SendUpdateWorldState(EP_PWT_H,0);
+    plr-&gt;SendUpdateWorldState(EP_PWT_N,0);
+    plr-&gt;SendUpdateWorldState(EP_PWT_A_P,0);
+    plr-&gt;SendUpdateWorldState(EP_PWT_H_P,0);
+    plr-&gt;SendUpdateWorldState(EP_PWT_N_A,0);
+    plr-&gt;SendUpdateWorldState(EP_PWT_N_H,0);
+
+    plr-&gt;SendUpdateWorldState(EP_NPT_A,0);
+    plr-&gt;SendUpdateWorldState(EP_NPT_H,0);
+    plr-&gt;SendUpdateWorldState(EP_NPT_N,0);
+    plr-&gt;SendUpdateWorldState(EP_NPT_A_P,0);
+    plr-&gt;SendUpdateWorldState(EP_NPT_H_P,0);
+    plr-&gt;SendUpdateWorldState(EP_NPT_N_A,0);
+    plr-&gt;SendUpdateWorldState(EP_NPT_N_H,0);
+
+    plr-&gt;SendUpdateWorldState(EP_CGT_A,0);
+    plr-&gt;SendUpdateWorldState(EP_CGT_H,0);
+    plr-&gt;SendUpdateWorldState(EP_CGT_N,0);
+    plr-&gt;SendUpdateWorldState(EP_CGT_A_P,0);
+    plr-&gt;SendUpdateWorldState(EP_CGT_H_P,0);
+    plr-&gt;SendUpdateWorldState(EP_CGT_N_A,0);
+    plr-&gt;SendUpdateWorldState(EP_CGT_N_H,0);
+}
\ No newline at end of file
diff --git a/src/game/OutdoorPvPEP.h b/src/game/OutdoorPvPEP.h
new file mode 100644
index 0000000..2595936
--- /dev/null
+++ b/src/game/OutdoorPvPEP.h
@@ -0,0 +1,279 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS &lt;http://www.MaNGOScore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef OUTDOOR_PVP_EP_
+#define OUTDOOR_PVP_EP_
+
+#include "OutdoorPvPImpl.h"
+
+#include "DBCStructure.h"
+
+const uint32 EP_AllianceBuffs[4] = {11413, 11414, 11415, 1386};
+
+const uint32 EP_HordeBuffs[4] = {30880, 30683, 30682, 29520};
+
+const uint32 EP_GraveYardZone = 139;
+
+const uint32 EP_GraveYardId = 927;
+
+const uint32 EPBuffZonesNum = 3;
+
+const uint32 EP_EWT_CM = 17690;
+const uint32 EP_CGT_CM = 17689;
+const uint32 EP_NPT_CM = 17696;
+const uint32 EP_PWT_CM = 17698;
+
+const uint32 EPBuffZones[EPBuffZonesNum] = {139, 2017, 2057};
+
+enum EP_TaxiNodes {
+    EP_CGT_Taxi = 87,
+    EP_EWT_Taxi = 86,
+    EP_NPT_Taxi = 85,
+    EP_PWT_Taxi = 84
+};
+
+enum EP_EastwallTowerWorldStates {
+    EP_EWT_A = 2354,
+    EP_EWT_H = 2356,
+    EP_EWT_A_P = 2357, // ally progressing
+    EP_EWT_H_P = 2358,
+    EP_EWT_N_A = 2359, // ally conquested
+    EP_EWT_N_H = 2360,
+    EP_EWT_N = 2361
+};
+
+enum EP_NorthpassTowerWorldStates {
+    EP_NPT_N = 2352,
+    EP_NPT_N_A = 2362,
+    EP_NPT_N_H = 2363,
+    EP_NPT_A_P = 2364,
+    EP_NPT_H_P = 2365,
+    EP_NPT_A = 2372,
+    EP_NPT_H = 2373
+};
+
+enum EP_PlagewoodTowerWorldStates {
+    EP_PWT_N_A = 2366,
+    EP_PWT_N_H = 2353, //2367 not present! use neutral!
+    EP_PWT_A_P = 2368,
+    EP_PWT_H_P = 2369,
+    EP_PWT_A = 2370,
+    EP_PWT_H = 2371,
+    EP_PWT_N = 2353
+};
+
+enum EP_CrownGuardTowerWorldStates {
+    EP_CGT_N_A = 2374,
+    EP_CGT_N_H = 2375,
+    EP_CGT_A_P = 2376,
+    EP_CGT_H_P = 2377,
+    EP_CGT_A = 2378,
+    EP_CGT_H = 2379,
+    EP_CGT_N = 2355
+};
+
+enum EP_WorldStates {
+    EP_UI_TOWER_SLIDER_DISPLAY = 2426,
+    EP_UI_TOWER_SLIDER_POS = 2427,
+    EP_UI_TOWER_SLIDER_N = 2428,
+
+    EP_UI_TOWER_COUNT_A = 2327,
+    EP_UI_TOWER_COUNT_H = 2328
+};
+
+enum EP_Summons {
+    EP_EWT_COMMANDER = 0,
+    EP_EWT_SOLDIER1,
+    EP_EWT_SOLDIER2,
+    EP_EWT_SOLDIER3,
+    EP_EWT_SOLDIER4,
+    EP_PWT_FLIGHTMASTER,
+};
+
+enum EP_GoSummons {
+    EP_NPT_BUFF = 0,
+    EP_NPT_FLAGS,
+    EP_EWT_FLAGS,
+    EP_CGT_FLAGS,
+    EP_PWT_FLAGS
+};
+
+enum EP_Towers {
+    EP_EWT = 0, // plaguelands 03
+    EP_NPT,// plaguelands 01
+    EP_PWT,// plaguelands 04
+    EP_CGT,// plaguelands 02
+    EP_TOWER_NUM
+};
+
+const go_type EPCapturePoints[EP_TOWER_NUM] = {
+    {182097,0,2574.51f,-4794.89f,144.704f,-1.45003f,-0.097056f,0.095578f,-0.656229f,0.742165f},
+    {181899,0,3181.08f,-4379.36f,174.123f,-2.03472f,-0.065392f,0.119494f,-0.842275f,0.521553f},
+    {182098,0,2962.71f,-3042.31f,154.789f,2.08426f,-0.074807f,-0.113837f,0.855928f,0.49883f},
+    {182096,0,1860.85f,-3731.23f,196.716f,-2.53214f,0.033967f,-0.131914f,0.944741f,-0.298177f}
+};
+
+const go_type EPTowerFlags[EP_TOWER_NUM] = {
+    {182106,0,2569.60f,-4772.93f,115.399f,2.72271f,0,0,0.978148f,0.207912f},
+    {182106,0,3148.17f,-4365.51f,145.029f,1.53589f,0,0,0.694658f,0.71934f},
+    {182106,0,2992.63f,-3022.95f,125.593f,3.03687f,0,0,0.99863f,0.052336f},
+    {182106,0,1838.42f,-3703.56f,167.713f,0.890118f,0,0,0.430511f,0.902585f}
+};
+
+const uint32 EPTowerPlayerEnterEvents[EP_TOWER_NUM] = {10691,10699,10701,10705};
+
+const uint32 EPTowerPlayerLeaveEvents[EP_TOWER_NUM] = {10692,10698,10700,10704};
+
+const uint32 EP_NUM_CREATURES = 6;
+const uint32 EP_EWT_NUM_CREATURES = 5;
+
+// one lordaeron commander, 4 soldiers
+// should be spawned at EWT and follow a path, but trans-grid pathing isn't safe, so summon them directly at NPT
+const creature_type EP_EWT_Summons_A[EP_EWT_NUM_CREATURES] = {
+    {17635,469,0, 3167.61f,-4352.09f,138.20f,4.5811f},
+    {17647,469,0, 3172.74f,-4352.99f,139.14f,4.9873f},
+    {17647,469,0, 3165.89f,-4354.46f,138.67f,3.7244f},
+    {17647,469,0, 3164.65f,-4350.26f,138.22f,2.4794f},
+    {17647,469,0, 3169.91f,-4349.68f,138.37f,0.7444f}
+};
+
+const creature_type EP_EWT_Summons_H[EP_EWT_NUM_CREATURES] = {
+    {17995,67,0, 3167.61f,-4352.09f,138.20f,4.5811f},
+    {17996,67,0, 3172.74f,-4352.99f,139.14f,4.9873f},
+    {17996,67,0, 3165.89f,-4354.46f,138.67f,3.7244f},
+    {17996,67,0, 3164.65f,-4350.26f,138.22f,2.4794f},
+    {17996,67,0, 3169.91f,-4349.68f,138.37f,0.7444f}
+};
+
+enum EP_TowerStates {
+    EP_TS_N = 1,
+    EP_TS_N_A = 2,
+    EP_TS_N_H = 4,
+    EP_TS_A_P = 8,
+    EP_TS_H_P = 16,
+    EP_TS_A = 32,
+    EP_TS_H = 64
+};
+
+// when spawning, pay attention at setting the faction manually!
+const creature_type EP_PWT_FlightMaster = {17209,0,0,2987.5f,-3049.11f,120.126f,5.75959f};
+
+// after spawning, modify the faction so that only the controller will be able to use it with SetUInt32Value(GAMEOBJECT_FACTION, faction_id);
+const go_type EP_NPT_LordaeronShrine = {181682,0,3167.72f,-4355.91f,138.785f,1.69297f,0,0,0.748956f,0.66262f};
+
+class OutdoorPvPEP;
+
+class OPvPCapturePointEP_EWT : public OPvPCapturePoint
+{
+friend class OutdoorPvPEP;
+public:
+    OPvPCapturePointEP_EWT(OutdoorPvP * pvp);
+    void ChangeState();
+    void SendChangePhase();
+    void FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+protected:
+    void SummonSupportUnitAtNorthpassTower(uint32 team);
+    void UpdateTowerState();
+protected:
+    uint32 m_TowerState;
+    uint32 m_UnitsSummonedSide;
+};
+
+class OPvPCapturePointEP_NPT : public OPvPCapturePoint
+{
+friend class OutdoorPvPEP;
+public:
+    OPvPCapturePointEP_NPT(OutdoorPvP * pvp);
+    void ChangeState();
+    void SendChangePhase();
+    void FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+protected:
+    void SummonGO(uint32 team);
+    void UpdateTowerState();
+protected:
+    uint32 m_TowerState;
+    uint32 m_SummonedGOSide;
+};
+
+class OPvPCapturePointEP_CGT : public OPvPCapturePoint
+{
+friend class OutdoorPvPEP;
+public:
+    OPvPCapturePointEP_CGT(OutdoorPvP * pvp);
+    void ChangeState();
+    void SendChangePhase();
+    void FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+protected:
+    void LinkGraveYard(uint32 team);
+    void UpdateTowerState();
+protected:
+    uint32 m_TowerState;
+    uint32 m_GraveyardSide;
+};
+
+class OPvPCapturePointEP_PWT : public OPvPCapturePoint
+{
+friend class OutdoorPvPEP;
+public:
+    OPvPCapturePointEP_PWT(OutdoorPvP * pvp);
+    void ChangeState();
+    void SendChangePhase();
+    void FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+protected:
+    void SummonFlightMaster(uint32 team);
+    void UpdateTowerState();
+protected:
+    uint32 m_FlightMasterSpawned;
+    uint32 m_TowerState;
+};
+
+class OutdoorPvPEP : public OutdoorPvP
+{
+friend class OPvPCapturePointEP_EWT;
+friend class OPvPCapturePointEP_NPT;
+friend class OPvPCapturePointEP_PWT;
+friend class OPvPCapturePointEP_CGT;
+public:
+    OutdoorPvPEP();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count);
+    void SendRemoveWorldStates(Player * plr);
+    void BuffTeams();
+private:
+    // how many towers are controlled
+    uint32 EP_Controls[EP_TOWER_NUM];
+    uint32 m_AllianceTowersControlled;
+    uint32 m_HordeTowersControlled;
+};
+
+#endif
\ No newline at end of file
diff --git a/src/game/OutdoorPvPGH.cpp b/src/game/OutdoorPvPGH.cpp
new file mode 100644
index 0000000..c55d74b
--- /dev/null
+++ b/src/game/OutdoorPvPGH.cpp
@@ -0,0 +1,234 @@
+/*
+* Copyright (C) 2008-2010 TrinityCore &lt;http://www.trinitycore.org/&gt;
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
+*/
+
+#include "OutdoorPvPGH.h"
+#include "OutdoorPvPMgr.h"
+#include "Player.h"
+#include "WorldPacket.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "Language.h"
+
+
+OPvPCapturePointGH::OPvPCapturePointGH(OutdoorPvP *pvp) :
+OPvPCapturePoint(pvp), 
+m_capturable(true), 
+m_ControllingFaction(0),
+m_VentureState(VENTURE_N)
+{
+    SetCapturePointData(189310,571,2483.68f,-1873.6f,10.68f,-0.1047f,0.0f,0.0f,0.0f,0.0f);
+}
+
+void OPvPCapturePointGH::SpawnNPCsForTeam(uint32 team)
+{
+    const creature_type* creatures = NULL;
+    if (team == ALLIANCE)
+        creatures = AllianceLighthouseNPCs;
+    else if (team == HORDE)
+        creatures = HordeLighthouseNPCs;
+    else
+        return;
+    for (int i = 0; i &lt; GH_CONTROL_NPC_NUM; ++i)
+        AddCreature(i,creatures[i].entry,creatures[i].teamval,creatures[i].map,creatures[i].x,creatures[i].y,creatures[i].z,creatures[i].o,1000000);
+}
+
+void OPvPCapturePointGH::DeSpawnNPCs()
+{
+    for (int i = 0; i &lt; GH_CONTROL_NPC_NUM; ++i)
+        DelCreature(i);
+}
+
+void OPvPCapturePointGH::FactionTakeOver(uint32 team)
+{
+    m_ControllingFaction = team;
+    DeSpawnNPCs();
+    SpawnNPCsForTeam(team);
+    m_capturable = true;
+}
+
+bool OPvPCapturePointGH::HandlePlayerEnter(Player *plr)
+{
+    if (OPvPCapturePoint::HandlePlayerEnter(plr))
+    {
+        plr-&gt;SendUpdateWorldState(GH_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f);
+        plr-&gt;SendUpdateWorldState(GH_UI_TOWER_SLIDER_POS, phase);
+        plr-&gt;SendUpdateWorldState(GH_UI_TOWER_SLIDER_N, m_neutralValuePct);
+        return true;
+    }
+    return false;
+}
+
+void OPvPCapturePointGH::HandlePlayerLeave(Player *plr)
+{
+    plr-&gt;SendUpdateWorldState(GH_UI_TOWER_SLIDER_DISPLAY, 0);
+    OPvPCapturePoint::HandlePlayerLeave(plr);
+}
+
+void OPvPCapturePointGH::FillInitialWorldStates(WorldPacket &amp;data)
+{
+    data &lt;&lt; GH_UI_TOWER_SLIDER_DISPLAY &lt;&lt; uint32(0);
+    data &lt;&lt; GH_UI_TOWER_SLIDER_POS &lt;&lt; uint32(50);
+    data &lt;&lt; GH_UI_TOWER_SLIDER_N &lt;&lt; uint32(100);
+
+    m_PvP-&gt;SendUpdateWorldState(GH_MAP_VENTURE_NEUTRAL ,uint32(bool(m_VentureState &amp; VENTURE_N)));
+    m_PvP-&gt;SendUpdateWorldState(GH_MAP_VENTURE_HORDE ,uint32(bool(m_VentureState &amp; VENTURE_H)));
+    m_PvP-&gt;SendUpdateWorldState(GH_MAP_VENTURE_ALLIANCE ,uint32(bool(m_VentureState &amp; VENTURE_A)));
+    m_PvP-&gt;SendUpdateWorldState(GH_MAP_VENTURE_NEU_A ,uint32(bool(m_VentureState &amp; VENTURE_N_A)));
+    m_PvP-&gt;SendUpdateWorldState(GH_MAP_VENTURE_NEU_H ,uint32(bool(m_VentureState &amp; VENTURE_N_H)));
+}
+
+bool OPvPCapturePointGH::Update(uint32 diff)
+{
+    // ToDo: research if all the soldiers attack at once
+    // research if they respawn after some time
+    if (m_capturable)
+        return OPvPCapturePoint::Update(diff);
+    return false;
+}
+
+void OPvPCapturePointGH::ChangeState()
+{
+    switch(m_OldState)
+    {
+    case OBJECTIVESTATE_NEUTRAL:
+        break;
+    case OBJECTIVESTATE_ALLIANCE:
+        sWorld.SendZoneText(GH_OUTDOORPVP_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_GH_LOOSE_A));
+        DeSpawnNPCs();
+        break;
+    case OBJECTIVESTATE_HORDE:
+        sWorld.SendZoneText(GH_OUTDOORPVP_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_GH_LOOSE_H));
+        DeSpawnNPCs();
+        break;
+    case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+    case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+    case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+    case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+        break;
+    }
+
+    uint32 artkit = 21;
+    switch(m_State)
+    {
+    case OBJECTIVESTATE_NEUTRAL:
+        m_VentureState = VENTURE_N;
+        break;
+    case OBJECTIVESTATE_ALLIANCE:
+        m_VentureState = VENTURE_A;
+        FactionTakeOver(ALLIANCE);
+        artkit = 2;
+        sWorld.SendZoneText(GH_OUTDOORPVP_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_GH_CAPTURE_A));
+        break;
+    case OBJECTIVESTATE_HORDE:
+        m_VentureState = VENTURE_H;
+        FactionTakeOver(HORDE);
+        artkit = 1;
+        sWorld.SendZoneText(GH_OUTDOORPVP_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_GH_CAPTURE_H));
+        break;
+    case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        m_VentureState = VENTURE_N_A;
+        break;
+    case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        m_VentureState = VENTURE_N_H;
+        break;
+    case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+        m_VentureState = VENTURE_N_A;
+        artkit = 2;
+        break;
+    case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+        m_VentureState = VENTURE_N_H;
+        artkit = 1;
+        break;
+    }
+
+    GameObject* flag = ObjectAccessor::GetGameObjectInWorld(ObjectGuid(HIGHGUID_GAMEOBJECT, m_capturePointGUID));
+    if (flag)
+    {
+        flag-&gt;SetGoArtKit(artkit);
+    }
+    // ToDo: research about the world states!
+    //this-&gt;UpdateVentureWorldState();
+}
+
+void OPvPCapturePointGH::UpdateVentureWorldState()
+{
+    m_PvP-&gt;SendUpdateWorldState(GH_MAP_VENTURE_NEUTRAL ,uint32(bool(m_VentureState &amp; VENTURE_N)));
+    m_PvP-&gt;SendUpdateWorldState(GH_MAP_VENTURE_HORDE ,uint32(bool(m_VentureState &amp; VENTURE_H)));
+    m_PvP-&gt;SendUpdateWorldState(GH_MAP_VENTURE_ALLIANCE ,uint32(bool(m_VentureState &amp; VENTURE_A)));
+    m_PvP-&gt;SendUpdateWorldState(GH_MAP_VENTURE_NEU_A ,uint32(bool(m_VentureState &amp; VENTURE_N_A)));
+    m_PvP-&gt;SendUpdateWorldState(GH_MAP_VENTURE_NEU_H ,uint32(bool(m_VentureState &amp; VENTURE_N_H)));
+}
+
+void OPvPCapturePointGH::SendChangePhase()
+{
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(GH_UI_TOWER_SLIDER_DISPLAY, 1);
+    // send these updates to only the ones in this objective
+    uint32 phase = (uint32)ceil((m_value + m_maxValue) / (2 * m_maxValue) * 100.0f);
+    SendUpdateWorldState(GH_UI_TOWER_SLIDER_POS, phase);
+    SendUpdateWorldState(GH_UI_TOWER_SLIDER_N, m_neutralValuePct);
+}
+
+
+OutdoorPvPGH::OutdoorPvPGH()
+{
+    m_TypeId = OUTDOOR_PVP_GH;
+}
+
+void OutdoorPvPGH::HandleKillImpl(Player *plr, Unit * killed)
+{
+    if (killed-&gt;GetTypeId() == TYPEID_PLAYER &amp;&amp; plr-&gt;GetTeam() != ((Player*)killed)-&gt;GetTeam())
+        plr-&gt;CastSpell(plr,GH_VENTURE_KILL_CREDIT,true);
+}
+
+void OutdoorPvPGH::SendRemoveWorldStates(Player *plr)
+{
+    plr-&gt;SendUpdateWorldState(GH_UI_TOWER_SLIDER_DISPLAY,0);
+    plr-&gt;SendUpdateWorldState(GH_UI_TOWER_SLIDER_POS,0);
+    plr-&gt;SendUpdateWorldState(GH_UI_TOWER_SLIDER_N,0);
+}
+
+bool OutdoorPvPGH::Update(uint32 diff)
+{
+    return m_obj-&gt;Update(diff);
+}
+
+void OutdoorPvPGH::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPGH::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+bool OutdoorPvPGH::SetupOutdoorPvP()
+{
+    RegisterZone(GH_OUTDOORPVP_ZONE);
+    m_obj = new OPvPCapturePointGH(this);
+    if (!m_obj)
+        return false;
+    AddCapturePoint(m_obj);
+    return true;
+}
+
+void OutdoorPvPGH::FillInitialWorldStates(WorldPacket &amp;data)
+{
+    m_obj-&gt;FillInitialWorldStates(data);
+}
diff --git a/src/game/OutdoorPvPGH.h b/src/game/OutdoorPvPGH.h
new file mode 100644
index 0000000..dee7424
--- /dev/null
+++ b/src/game/OutdoorPvPGH.h
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore &lt;http://www.trinitycore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
+ */
+
+#ifndef OUTDOOR_PVP_GH_
+#define OUTDOOR_PVP_GH_
+
+#include "OutdoorPvP.h"
+#include "DBCStructure.h"
+
+enum OutdoorPvPGHSpells
+{
+    GH_VENTURE_KILL_CREDIT  = 50858,
+    GH_VENTURE_PVP_MASTER   = 50857,
+};
+
+enum OutdoorPvPGHWorldStates
+{
+    GH_UI_TOWER_SLIDER_DISPLAY  = 3466,
+    GH_UI_TOWER_SLIDER_POS      = 3467,
+    GH_UI_TOWER_SLIDER_N        = 3468,
+
+    GH_MAP_VENTURE_NEUTRAL      = 3501,
+    GH_MAP_VENTURE_NEU_A        = 3501,
+    GH_MAP_VENTURE_NEU_H        = 3501,
+    GH_MAP_VENTURE_HORDE        = 3508,
+    GH_MAP_VENTURE_ALLIANCE     = 3502
+};
+
+enum Misc
+{
+    GH_OUTDOORPVP_ZONE      = 394,
+    GH_CONTROL_NPC_NUM      = 21,
+
+    // Grizzly Hills text
+    //LANG_OPVP_GH_CAPTURE_A              = 12002,
+    //LANG_OPVP_GH_LOOSE_A                = 12004,
+    //LANG_OPVP_GH_CAPTURE_H              = 12001,
+    //LANG_OPVP_GH_LOOSE_H                = 12003,
+};
+
+const creature_type HordeLighthouseNPCs[GH_CONTROL_NPC_NUM] =
+{
+    // soldiers
+    {27748,67,571,2492.002930f,-1845.899414f,10.711608f,5.529358f},
+    {27748,67,571,2498.592773f,-1837.833740f,10.552654f,5.351072f},
+    {27748,67,571,2515.539307f,-1822.425171f,10.910775f,5.558418f},
+    {27748,67,571,2575.352051f,-1796.180420f,10.441980f,0.377932f},
+    {27748,67,571,2580.784180f,-1809.862549f,10.445493f,0.377932f},
+    {27748,67,571,2552.297363f,-1831.839966f,10.495550f,2.246392f},
+    {27748,67,571,2464.210693f,-1850.925415f,6.143895f,2.954036f},
+    {27748,67,571,2410.525391f,-1825.168335f,1.870843f,4.718826f},
+    {27748,67,571,2481.714355f,-1877.021362f,10.700072f,6.010807f},
+    {27748,67,571,2479.789551f,-1905.015259f,10.398465f,0.403849f},
+    {27748,67,571,2508.500244f,-1896.378784f,8.882201f,4.220098f},
+    {27748,67,571,2494.566895f,-1934.060181f,12.319469f,0.606482f},
+    {27748,67,571,2543.587646f,-1916.709961f,3.205774f,0.106969f},
+    {27748,67,571,2545.027100f,-1930.114868f,3.636569f,0.106969f},
+    {27748,67,571,2539.792236f,-1974.311035f,8.256695f,5.160220f},
+    {27748,67,571,2526.169189f,-1980.855347f,8.273070f,5.160220f},
+    {27748,67,571,2553.052734f,-1882.842896f,4.512696f,6.110557f},
+    // captain
+    {27708,67,571,2485.295898f,-1889.402344f,9.714134f,6.202426f},
+    // blacksmith
+    {29253,67,571,2476.218750f,-1953.859131f,10.883574f,1.297610f},
+    // vendor
+    {27730,67,571,2489.363770f,-1836.897095f,11.650964f,5.528555f},
+    // stable master
+    {29251,67,571,2551.742188f,-1835.743652f,10.553280f,2.068092f}
+};
+
+const creature_type AllianceLighthouseNPCs[GH_CONTROL_NPC_NUM] =
+{
+    // soldiers
+    {27758,469,571,2492.002930f,-1845.899414f,10.711608f,5.529358f},
+    {27758,469,571,2498.592773f,-1837.833740f,10.552654f,5.351072f},
+    {27758,469,571,2515.539307f,-1822.425171f,10.910775f,5.558418f},
+    {27758,469,571,2575.352051f,-1796.180420f,10.441980f,0.377932f},
+    {27758,469,571,2580.784180f,-1809.862549f,10.445493f,0.377932f},
+    {27758,469,571,2552.297363f,-1831.839966f,10.495550f,2.246392f},
+    {27758,469,571,2464.210693f,-1850.925415f,6.143895f,2.954036f},
+    {27758,469,571,2410.525391f,-1825.168335f,1.870843f,4.718826f},
+    {27758,469,571,2481.714355f,-1877.021362f,10.700072f,6.010807f},
+    {27758,469,571,2479.789551f,-1905.015259f,10.398465f,0.403849f},
+    {27758,469,571,2508.500244f,-1896.378784f,8.882201f,4.220098f},
+    {27758,469,571,2494.566895f,-1934.060181f,12.319469f,0.606482f},
+    {27758,469,571,2543.587646f,-1916.709961f,3.205774f,0.106969f},
+    {27758,469,571,2545.027100f,-1930.114868f,3.636569f,0.106969f},
+    {27758,469,571,2539.792236f,-1974.311035f,8.256695f,5.160220f},
+    {27758,469,571,2526.169189f,-1980.855347f,8.273070f,5.160220f},
+    {27758,469,571,2553.052734f,-1882.842896f,4.512696f,6.110557f},
+    // captain
+    {27759,469,571,2485.295898f,-1889.402344f,9.714134f,6.202426f},
+    // blacksmith
+    {29252,469,571,2476.218750f,-1953.859131f,10.883574f,1.297610f},
+    // vendor
+    {27760,469,571,2489.363770f,-1836.897095f,11.650964f,5.528555f},
+    // stable master
+    {29250,469,571,2551.742188f,-1835.743652f,10.553280f,2.068092f}
+};
+
+enum VentureStates
+{
+    VENTURE_N   = 1,
+    VENTURE_N_A = 2,
+    VENTURE_A   = 4,
+    VENTURE_N_H = 8,
+    VENTURE_H   = 16
+};
+
+class OutdoorPvPGH;
+
+class OPvPCapturePointGH : public OPvPCapturePoint
+{
+    friend class OutdoorPvPGH;
+
+    public:
+
+        OPvPCapturePointGH(OutdoorPvP * pvp);
+
+        bool Update(uint32 diff);
+
+        void ChangeState();
+
+        void SendChangePhase();
+
+        void FillInitialWorldStates(WorldPacket &amp; data);
+
+        // used when player is activated/inactivated in the area
+        bool HandlePlayerEnter(Player * plr);
+        void HandlePlayerLeave(Player * plr);
+
+    protected:
+
+        // called when a faction takes control
+        void FactionTakeOver(uint32 team);
+
+        void DeSpawnNPCs();
+        void SpawnNPCsForTeam(uint32 team);
+
+        void UpdateVentureWorldState();
+
+    private:
+
+        bool m_capturable;
+
+        uint32 m_ControllingFaction;
+        uint32 m_VentureState;
+};
+
+class OutdoorPvPGH : public OutdoorPvP
+{
+    friend class OPvPCapturePointGH;
+
+    public:
+
+        OutdoorPvPGH();
+
+        bool SetupOutdoorPvP();
+
+        void HandlePlayerEnterZone(Player *plr, uint32 zone);
+        void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+
+        bool Update(uint32 diff);
+
+        void FillInitialWorldStates(WorldPacket &amp;data);
+
+        void SendRemoveWorldStates(Player * plr);
+
+        void HandleKillImpl(Player * plr, Unit * killed);
+
+    private:
+
+        OPvPCapturePointGH * m_obj;
+};
+
+#endif
diff --git a/src/game/OutdoorPvPHP.cpp b/src/game/OutdoorPvPHP.cpp
new file mode 100644
index 0000000..948c86f
--- /dev/null
+++ b/src/game/OutdoorPvPHP.cpp
@@ -0,0 +1,332 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS &lt;http://www.MaNGOScore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvPHP.h"
+#include "OutdoorPvP.h"
+#include "OutdoorPvPMgr.h"
+#include "Player.h"
+#include "WorldPacket.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "Language.h"
+
+const uint32 HP_LANG_LOOSE_A[HP_TOWER_NUM] = {LANG_OPVP_HP_LOOSE_BROKENHILL_A,LANG_OPVP_HP_LOOSE_OVERLOOK_A,LANG_OPVP_HP_LOOSE_STADIUM_A};
+
+const uint32 HP_LANG_LOOSE_H[HP_TOWER_NUM] = {LANG_OPVP_HP_LOOSE_BROKENHILL_H,LANG_OPVP_HP_LOOSE_OVERLOOK_H,LANG_OPVP_HP_LOOSE_STADIUM_H};
+
+const uint32 HP_LANG_CAPTURE_A[HP_TOWER_NUM] = {LANG_OPVP_HP_CAPTURE_BROKENHILL_A,LANG_OPVP_HP_CAPTURE_OVERLOOK_A,LANG_OPVP_HP_CAPTURE_STADIUM_A};
+
+const uint32 HP_LANG_CAPTURE_H[HP_TOWER_NUM] = {LANG_OPVP_HP_CAPTURE_BROKENHILL_H,LANG_OPVP_HP_CAPTURE_OVERLOOK_H,LANG_OPVP_HP_CAPTURE_STADIUM_H};
+
+OPvPCapturePointHP::OPvPCapturePointHP(OutdoorPvP *pvp,OutdoorPvPHPTowerType type)
+: OPvPCapturePoint(pvp), m_TowerType(type)
+{
+    SetCapturePointData(HPCapturePoints[type].entry,
+        HPCapturePoints[type].map,
+        HPCapturePoints[type].x,
+        HPCapturePoints[type].y,
+        HPCapturePoints[type].z,
+        HPCapturePoints[type].o,
+        HPCapturePoints[type].rot0,
+        HPCapturePoints[type].rot1,
+        HPCapturePoints[type].rot2,
+        HPCapturePoints[type].rot3);
+    AddObject(type,
+        HPTowerFlags[type].entry,
+        HPTowerFlags[type].map,
+        HPTowerFlags[type].x,
+        HPTowerFlags[type].y,
+        HPTowerFlags[type].z,
+        HPTowerFlags[type].o,
+        HPTowerFlags[type].rot0,
+        HPTowerFlags[type].rot1,
+        HPTowerFlags[type].rot2,
+        HPTowerFlags[type].rot3);
+}
+
+OutdoorPvPHP::OutdoorPvPHP()
+{
+    m_TypeId = OUTDOOR_PVP_HP;
+}
+
+bool OutdoorPvPHP::SetupOutdoorPvP()
+{
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+    // add the zones affected by the pvp buff
+    for (int i = 0; i &lt; OutdoorPvPHPBuffZonesNum; ++i)
+        RegisterZone(OutdoorPvPHPBuffZones[i]);
+
+    AddCapturePoint(new OPvPCapturePointHP(this,HP_TOWER_BROKEN_HILL));
+
+    AddCapturePoint(new OPvPCapturePointHP(this,HP_TOWER_OVERLOOK));
+
+    AddCapturePoint(new OPvPCapturePointHP(this,HP_TOWER_STADIUM));
+
+    return true;
+}
+
+void OutdoorPvPHP::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    // add buffs
+    if(plr-&gt;GetTeam() == ALLIANCE)
+    {
+        if(m_AllianceTowersControlled &gt;=3)
+            plr-&gt;CastSpell(plr,AllianceBuff,true);
+    }
+    else
+    {
+        if(m_HordeTowersControlled &gt;=3)
+            plr-&gt;CastSpell(plr,HordeBuff,true);
+    }
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPHP::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    if(plr-&gt;GetTeam() == ALLIANCE)
+    {
+        plr-&gt;RemoveAurasDueToSpell(AllianceBuff);
+    }
+    else
+    {
+        plr-&gt;RemoveAurasDueToSpell(HordeBuff);
+    }
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+bool OutdoorPvPHP::Update(uint32 diff)
+{
+    bool changed = false;
+    if(changed = OutdoorPvP::Update(diff))
+    {
+        if(m_AllianceTowersControlled == 3)
+            TeamApplyBuff(TEAM_ALLIANCE, AllianceBuff, HordeBuff);
+        else if(m_HordeTowersControlled == 3)
+            TeamApplyBuff(TEAM_HORDE, HordeBuff, AllianceBuff);
+        else
+        {
+            TeamCastSpell(TEAM_ALLIANCE, -AllianceBuff);
+            TeamCastSpell(TEAM_HORDE, -HordeBuff);
+        }
+        SendUpdateWorldState(HP_UI_TOWER_COUNT_A, m_AllianceTowersControlled);
+        SendUpdateWorldState(HP_UI_TOWER_COUNT_H, m_HordeTowersControlled);
+    }
+    return changed;
+}
+
+void OutdoorPvPHP::SendRemoveWorldStates(Player *plr)
+{
+    plr-&gt;SendUpdateWorldState(HP_UI_TOWER_DISPLAY_A,0);
+    plr-&gt;SendUpdateWorldState(HP_UI_TOWER_DISPLAY_H,0);
+    plr-&gt;SendUpdateWorldState(HP_UI_TOWER_COUNT_H,0);
+    plr-&gt;SendUpdateWorldState(HP_UI_TOWER_COUNT_A,0);
+    plr-&gt;SendUpdateWorldState(HP_UI_TOWER_SLIDER_N,0);
+    plr-&gt;SendUpdateWorldState(HP_UI_TOWER_SLIDER_POS,0);
+    plr-&gt;SendUpdateWorldState(HP_UI_TOWER_SLIDER_DISPLAY,0);
+    for (int i = 0; i &lt; HP_TOWER_NUM; ++i)
+    {
+        plr-&gt;SendUpdateWorldState(HP_MAP_N[i],0);
+        plr-&gt;SendUpdateWorldState(HP_MAP_A[i],0);
+        plr-&gt;SendUpdateWorldState(HP_MAP_H[i],0);
+    }
+}
+
+void OutdoorPvPHP::FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count)
+{
+    FillInitialWorldState(data, count, HP_UI_TOWER_DISPLAY_A,        1);
+    FillInitialWorldState(data, count, HP_UI_TOWER_DISPLAY_H,        1);
+    FillInitialWorldState(data, count, HP_UI_TOWER_COUNT_A,          m_AllianceTowersControlled);
+    FillInitialWorldState(data, count, HP_UI_TOWER_COUNT_H,          m_HordeTowersControlled);
+    FillInitialWorldState(data, count, HP_UI_TOWER_SLIDER_DISPLAY,   0);
+    FillInitialWorldState(data, count, HP_UI_TOWER_SLIDER_POS,       50);
+    FillInitialWorldState(data, count, HP_UI_TOWER_SLIDER_N,         100);
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+    {
+        itr-&gt;second-&gt;FillInitialWorldStates(data, count);
+    }
+}
+
+void OPvPCapturePointHP::ChangeState()
+{
+    uint32 field = 0;
+    switch(m_OldState)
+    {
+    case OBJECTIVESTATE_NEUTRAL:
+        field = HP_MAP_N[m_TowerType];
+        break;
+    case OBJECTIVESTATE_ALLIANCE:
+        field = HP_MAP_A[m_TowerType];
+        if(((OutdoorPvPHP*)m_PvP)-&gt;m_AllianceTowersControlled)
+            ((OutdoorPvPHP*)m_PvP)-&gt;m_AllianceTowersControlled--;
+        sWorld.SendZoneText(OutdoorPvPHPBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(HP_LANG_LOOSE_A[m_TowerType]));
+        break;
+    case OBJECTIVESTATE_HORDE:
+        field = HP_MAP_H[m_TowerType];
+        if(((OutdoorPvPHP*)m_PvP)-&gt;m_HordeTowersControlled)
+            ((OutdoorPvPHP*)m_PvP)-&gt;m_HordeTowersControlled--;
+        sWorld.SendZoneText(OutdoorPvPHPBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(HP_LANG_LOOSE_H[m_TowerType]));
+        break;
+    case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        field = HP_MAP_N[m_TowerType];
+        break;
+    case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        field = HP_MAP_N[m_TowerType];
+        break;
+    case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+        field = HP_MAP_A[m_TowerType];
+        break;
+    case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+        field = HP_MAP_H[m_TowerType];
+        break;
+    }
+
+    // send world state update
+    if(field)
+    {
+        m_PvP-&gt;SendUpdateWorldState(field, 0);
+        field = 0;
+    }
+    uint32 artkit = 21;
+    uint32 artkit2 = HP_TowerArtKit_N[m_TowerType];
+    switch(m_State)
+    {
+    case OBJECTIVESTATE_NEUTRAL:
+        field = HP_MAP_N[m_TowerType];
+        break;
+    case OBJECTIVESTATE_ALLIANCE:
+        field = HP_MAP_A[m_TowerType];
+        artkit = 2;
+        artkit2 = HP_TowerArtKit_A[m_TowerType];
+        if(((OutdoorPvPHP*)m_PvP)-&gt;m_AllianceTowersControlled&lt;3)
+            ((OutdoorPvPHP*)m_PvP)-&gt;m_AllianceTowersControlled++;
+        sWorld.SendZoneText(OutdoorPvPHPBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(HP_LANG_CAPTURE_A[m_TowerType]));
+        break;
+    case OBJECTIVESTATE_HORDE:
+        field = HP_MAP_H[m_TowerType];
+        artkit = 1;
+        artkit2 = HP_TowerArtKit_H[m_TowerType];
+        if(((OutdoorPvPHP*)m_PvP)-&gt;m_HordeTowersControlled&lt;3)
+            ((OutdoorPvPHP*)m_PvP)-&gt;m_HordeTowersControlled++;
+        sWorld.SendZoneText(OutdoorPvPHPBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(HP_LANG_CAPTURE_H[m_TowerType]));
+        break;
+    case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        field = HP_MAP_N[m_TowerType];
+        break;
+    case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        field = HP_MAP_N[m_TowerType];
+        break;
+    case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+        field = HP_MAP_A[m_TowerType];
+        artkit = 2;
+        artkit2 = HP_TowerArtKit_A[m_TowerType];
+        break;
+    case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+        field = HP_MAP_H[m_TowerType];
+        artkit = 1;
+        artkit2 = HP_TowerArtKit_H[m_TowerType];
+        break;
+    }
+
+    GameObject* flag = ObjectAccessor::GetGameObjectInWorld(ObjectGuid(HIGHGUID_GAMEOBJECT, m_capturePointGUID));
+    GameObject* flag2 = ObjectAccessor::GetGameObjectInWorld(ObjectGuid(HIGHGUID_GAMEOBJECT, m_Objects[m_TowerType]));
+    if(flag)
+    {
+        flag-&gt;SetGoArtKit(artkit);
+    }
+    if(flag2)
+    {
+        flag2-&gt;SetGoArtKit(artkit2);
+    }
+
+    // send world state update
+    if(field)
+        m_PvP-&gt;SendUpdateWorldState(field, 1);
+
+    // complete quest objective
+    if(m_State == OBJECTIVESTATE_ALLIANCE || m_State == OBJECTIVESTATE_HORDE)
+        SendObjectiveComplete(HP_CREDITMARKER[m_TowerType], 0);
+}
+
+void OPvPCapturePointHP::SendChangePhase()
+{
+    SendUpdateWorldState(HP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+    // send these updates to only the ones in this objective
+    uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+    SendUpdateWorldState(HP_UI_TOWER_SLIDER_POS, phase);
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(HP_UI_TOWER_SLIDER_DISPLAY, 1);
+}
+
+void OPvPCapturePointHP::FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count)
+{
+    switch(m_State)
+    {
+        case OBJECTIVESTATE_ALLIANCE:
+        case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+                       FillInitialWorldState(data, count, HP_MAP_N[m_TowerType],        0);
+                       FillInitialWorldState(data, count, HP_MAP_A[m_TowerType],        1);
+                       FillInitialWorldState(data, count, HP_MAP_H[m_TowerType],        0);
+            break;
+        case OBJECTIVESTATE_HORDE:
+        case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+                       FillInitialWorldState(data, count, HP_MAP_N[m_TowerType],        0);
+                       FillInitialWorldState(data, count, HP_MAP_A[m_TowerType],        0);
+                       FillInitialWorldState(data, count, HP_MAP_H[m_TowerType],        1);
+            break;
+        case OBJECTIVESTATE_NEUTRAL:
+        case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        default:
+                       FillInitialWorldState(data, count, HP_MAP_N[m_TowerType],        1);
+                       FillInitialWorldState(data, count, HP_MAP_A[m_TowerType],        0);
+                       FillInitialWorldState(data, count, HP_MAP_H[m_TowerType],        0);
+            break;
+    }
+}
+
+bool OPvPCapturePointHP::HandlePlayerEnter(Player *plr)
+{
+    if(OPvPCapturePoint::HandlePlayerEnter(plr))
+    {
+        plr-&gt;SendUpdateWorldState(HP_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+        plr-&gt;SendUpdateWorldState(HP_UI_TOWER_SLIDER_POS, phase);
+        plr-&gt;SendUpdateWorldState(HP_UI_TOWER_SLIDER_N, m_neutralValuePct);
+        return true;
+    }
+    return false;
+}
+
+void OPvPCapturePointHP::HandlePlayerLeave(Player *plr)
+{
+    plr-&gt;SendUpdateWorldState(HP_UI_TOWER_SLIDER_DISPLAY, 0);
+    OPvPCapturePoint::HandlePlayerLeave(plr);
+}
+
+void OutdoorPvPHP::HandleKillImpl(Player *plr, Unit * killed)
+{
+    if(killed-&gt;GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    if(plr-&gt;GetTeam() == ALLIANCE &amp;&amp; ((Player*)killed)-&gt;GetTeam() != ALLIANCE)
+        plr-&gt;CastSpell(plr,AlliancePlayerKillReward,true);
+    else if(plr-&gt;GetTeam() == HORDE &amp;&amp; ((Player*)killed)-&gt;GetTeam() != HORDE)
+        plr-&gt;CastSpell(plr,HordePlayerKillReward,true);
+}
\ No newline at end of file
diff --git a/src/game/OutdoorPvPHP.h b/src/game/OutdoorPvPHP.h
new file mode 100644
index 0000000..ddd14e0
--- /dev/null
+++ b/src/game/OutdoorPvPHP.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS &lt;http://www.MaNGOScore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef OUTDOOR_PVP_HP_
+#define OUTDOOR_PVP_HP_
+
+#include "OutdoorPvPImpl.h"
+
+#define OutdoorPvPHPBuffZonesNum 6
+                                                         //  HP, citadel, ramparts, blood furnace, shattered halls, mag's lair
+const uint32 OutdoorPvPHPBuffZones[OutdoorPvPHPBuffZonesNum] = { 3483, 3563, 3562, 3713, 3714, 3836 };
+
+enum OutdoorPvPHPSpells
+{
+    AlliancePlayerKillReward = 32155,
+    HordePlayerKillReward = 32158,
+    AllianceBuff = 32071,
+    HordeBuff = 32049
+};
+
+enum OutdoorPvPHPTowerType{
+    HP_TOWER_BROKEN_HILL = 0,
+    HP_TOWER_OVERLOOK = 1,
+    HP_TOWER_STADIUM = 2,
+    HP_TOWER_NUM = 3
+};
+
+const uint32 HP_CREDITMARKER[HP_TOWER_NUM] = {19032,19028,19029};
+
+const uint32 HP_CapturePointEvent_Enter[HP_TOWER_NUM] = {11404,11396,11388};
+
+const uint32 HP_CapturePointEvent_Leave[HP_TOWER_NUM] = {11403,11395,11387};
+
+enum OutdoorPvPHPWorldStates{
+    HP_UI_TOWER_DISPLAY_A = 0x9ba,
+    HP_UI_TOWER_DISPLAY_H = 0x9b9,
+
+    HP_UI_TOWER_COUNT_H = 0x9ae,
+    HP_UI_TOWER_COUNT_A = 0x9ac,
+
+    HP_UI_TOWER_SLIDER_N = 2475,
+    HP_UI_TOWER_SLIDER_POS = 2474,
+    HP_UI_TOWER_SLIDER_DISPLAY = 2473
+};
+
+const uint32 HP_MAP_N[HP_TOWER_NUM] = {0x9b5,0x9b2,0x9a8};
+
+const uint32 HP_MAP_A[HP_TOWER_NUM] = {0x9b3,0x9b0,0x9a7};
+
+const uint32 HP_MAP_H[HP_TOWER_NUM] = {0x9b4,0x9b1,0x9a6};
+
+const uint32 HP_TowerArtKit_A[HP_TOWER_NUM] = {65,62,67};
+
+const uint32 HP_TowerArtKit_H[HP_TOWER_NUM] = {64,61,68};
+
+const uint32 HP_TowerArtKit_N[HP_TOWER_NUM] = {66,63,69};
+
+const go_type HPCapturePoints[HP_TOWER_NUM] = {
+    {182175,530,-471.462f,3451.09f,34.6432f,0.174533f,0,0,0.087156f,0.996195f},      // 0 - Broken Hill
+    {182174,530,-184.889f,3476.93f,38.205f,-0.017453f,0,0,0.008727f,-0.999962f},     // 1 - Overlook
+    {182173,530,-290.016f,3702.42f,56.6729f,0.034907f,0,0,0.017452f,0.999848f}     // 2 - Stadium
+};
+
+const go_type HPTowerFlags[HP_TOWER_NUM] = {
+    {183514,530,-467.078f,3528.17f,64.7121f,3.14159f,0,0,1,0},  // 0 broken hill
+    {182525,530,-187.887f,3459.38f,60.0403f,-3.12414f,0,0,0.999962f,-0.008727f}, // 1 overlook
+    {183515,530,-289.610f,3696.83f,75.9447f,3.12414f,0,0,0.999962f,0.008727f} // 2 stadium
+};
+
+class OPvPCapturePointHP : public OPvPCapturePoint
+{
+public:
+    OPvPCapturePointHP(OutdoorPvP * pvp, OutdoorPvPHPTowerType type);
+    void ChangeState();
+    void SendChangePhase();
+    void FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+private:
+    OutdoorPvPHPTowerType m_TowerType;
+};
+
+class OutdoorPvPHP : public OutdoorPvP
+{
+friend class OPvPCapturePointHP;
+public:
+    OutdoorPvPHP();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count);
+    void SendRemoveWorldStates(Player * plr);
+    void HandleKillImpl(Player * plr, Unit * killed);
+private:
+    // how many towers are controlled
+    uint32 m_AllianceTowersControlled;
+    uint32 m_HordeTowersControlled;
+};
+
+#endif
\ No newline at end of file
diff --git a/src/game/OutdoorPvPImpl.h b/src/game/OutdoorPvPImpl.h
new file mode 100644
index 0000000..5a54546
--- /dev/null
+++ b/src/game/OutdoorPvPImpl.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS &lt;http://www.MaNGOScore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef OUTDOORPVP_IMPL_H
+#define OUTDOORPVP_IMPL_H
+
+#include "SharedDefines.h"
+#include "OutdoorPvP.h"
+#include "Player.h"
+#include "WorldPacket.h"
+
+#define OTHER_TEAM(a) (a == TEAM_ALLIANCE ? TEAM_HORDE : TEAM_ALLIANCE)
+
+#endif
\ No newline at end of file
diff --git a/src/game/OutdoorPvPMgr.cpp b/src/game/OutdoorPvPMgr.cpp
new file mode 100644
index 0000000..e175d40
--- /dev/null
+++ b/src/game/OutdoorPvPMgr.cpp
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS &lt;http://www.MaNGOScore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPHP.h"
+#include "OutdoorPvPNA.h"
+#include "OutdoorPvPTF.h"
+#include "OutdoorPvPZM.h"
+#include "OutdoorPvPSI.h"
+#include "OutdoorPvPEP.h"
+#include "OutdoorPvPGH.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "Policies/SingletonImp.h"
+
+INSTANTIATE_SINGLETON_1( OutdoorPvPMgr );
+
+OutdoorPvPMgr::OutdoorPvPMgr()
+{
+    m_UpdateTimer = 0;
+    //sLog.outDebug("Instantiating OutdoorPvPMgr");
+}
+
+OutdoorPvPMgr::~OutdoorPvPMgr()
+{
+    //sLog.outDebug("Deleting OutdoorPvPMgr");
+    for (OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        (*itr)-&gt;DeleteSpawns();
+        delete *itr;
+    }
+}
+
+void OutdoorPvPMgr::InitOutdoorPvP()
+{
+    // create new opvp
+    OutdoorPvP * pOP = new OutdoorPvPHP;
+    // respawn, init variables
+    if(!pOP-&gt;SetupOutdoorPvP())
+    {
+        sLog.outError("OutdoorPvP : HP init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.push_back(pOP);
+        sLog.outString();
+        sLog.outString("OutdoorPvP : HP successfully initiated.");
+    }
+
+    pOP = new OutdoorPvPNA;
+    // respawn, init variables
+    if(!pOP-&gt;SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : NA init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.push_back(pOP);
+        sLog.outString();
+        sLog.outString("OutdoorPvP : NA successfully initiated.");
+    }
+
+    pOP = new OutdoorPvPTF;
+    // respawn, init variables
+    if(!pOP-&gt;SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : TF init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.push_back(pOP);
+        sLog.outString();
+        sLog.outString("OutdoorPvP : TF successfully initiated.");
+    }
+
+    pOP = new OutdoorPvPZM;
+    // respawn, init variables
+    if(!pOP-&gt;SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : ZM init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.push_back(pOP);
+        sLog.outString();
+        sLog.outString("OutdoorPvP : ZM successfully initiated.");
+    }
+
+    pOP = new OutdoorPvPSI;
+    // respawn, init variables
+    if(!pOP-&gt;SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : SI init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.push_back(pOP);
+        sLog.outString();
+        sLog.outString("OutdoorPvP : SI successfully initiated.");
+    }
+
+    pOP = new OutdoorPvPEP;
+    // respawn, init variables
+    if(!pOP-&gt;SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : EP init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.push_back(pOP);
+        sLog.outString();
+        sLog.outString("OutdoorPvP : EP successfully initiated.");
+        sLog.outString();
+    }
+
+    pOP = new OutdoorPvPGH;
+    // respawn, init variables
+    if(!pOP-&gt;SetupOutdoorPvP())
+    {
+        sLog.outDebug("OutdoorPvP : GH init failed.");
+        delete pOP;
+    }
+    else
+    {
+        m_OutdoorPvPSet.push_back(pOP);
+        sLog.outString();
+        sLog.outString("OutdoorPvP : GH successfully initiated.");
+        sLog.outString();
+    }
+}
+
+void OutdoorPvPMgr::AddZone(uint32 zoneid, OutdoorPvP *handle)
+{
+    m_OutdoorPvPMap[zoneid] = handle;
+}
+
+void OutdoorPvPMgr::HandlePlayerEnterZone(Player *plr, uint32 zoneid)
+{
+    OutdoorPvPMap::iterator itr = m_OutdoorPvPMap.find(zoneid);
+    if(itr == m_OutdoorPvPMap.end())
+        return;
+
+    if(itr-&gt;second-&gt;HasPlayer(plr))
+        return;
+
+    itr-&gt;second-&gt;HandlePlayerEnterZone(plr, zoneid);
+    sLog.outDebug("Player %u entered outdoorpvp id %u", plr-&gt;GetGUIDLow(), itr-&gt;second-&gt;GetTypeId());
+}
+
+void OutdoorPvPMgr::HandlePlayerLeaveZone(Player *plr, uint32 zoneid)
+{
+    OutdoorPvPMap::iterator itr = m_OutdoorPvPMap.find(zoneid);
+    if(itr == m_OutdoorPvPMap.end())
+        return;
+
+    // teleport: remove once in removefromworld, once in updatezone
+    if(!itr-&gt;second-&gt;HasPlayer(plr))
+        return;
+
+    itr-&gt;second-&gt;HandlePlayerLeaveZone(plr, zoneid);
+    sLog.outDebug("Player %u left outdoorpvp id %u",plr-&gt;GetGUIDLow(), itr-&gt;second-&gt;GetTypeId());
+}
+
+OutdoorPvP * OutdoorPvPMgr::GetOutdoorPvPToZoneId(uint32 zoneid)
+{
+    OutdoorPvPMap::iterator itr = m_OutdoorPvPMap.find(zoneid);
+    if(itr == m_OutdoorPvPMap.end())
+    {
+        // no handle for this zone, return
+        return NULL;
+    }
+    return itr-&gt;second;
+}
+
+void OutdoorPvPMgr::Update(uint32 diff)
+{
+    m_UpdateTimer += diff;
+    if(m_UpdateTimer &gt; OUTDOORPVP_OBJECTIVE_UPDATE_INTERVAL)
+    {
+        for (OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+            (*itr)-&gt;Update(m_UpdateTimer);
+        m_UpdateTimer = 0;
+    }
+}
+
+bool OutdoorPvPMgr::HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go)
+{
+    for (OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)-&gt;HandleCustomSpell(plr,spellId,go))
+            return true;
+    }
+    return false;
+}
+
+ZoneScript * OutdoorPvPMgr::GetZoneScript(uint32 zoneId)
+{
+    OutdoorPvPMap::iterator itr = m_OutdoorPvPMap.find(zoneId);
+    if(itr != m_OutdoorPvPMap.end())
+        return itr-&gt;second;
+    else
+        return NULL;
+}
+
+bool OutdoorPvPMgr::HandleOpenGo(Player *plr, uint64 guid)
+{
+    for (OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)-&gt;HandleOpenGo(plr,guid))
+            return true;
+    }
+    return false;
+}
+
+void OutdoorPvPMgr::HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid)
+{
+    for (OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)-&gt;HandleGossipOption(plr,guid,gossipid))
+            return;
+    }
+}
+
+bool OutdoorPvPMgr::CanTalkTo(Player * plr, Creature * c, GossipMenuItems gso)
+{
+    for (OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)-&gt;CanTalkTo(plr,c,gso))
+            return true;
+    }
+    return false;
+}
+
+void OutdoorPvPMgr::HandleDropFlag(Player *plr, uint32 spellId)
+{
+    for (OutdoorPvPSet::iterator itr = m_OutdoorPvPSet.begin(); itr != m_OutdoorPvPSet.end(); ++itr)
+    {
+        if((*itr)-&gt;HandleDropFlag(plr,spellId))
+            return;
+    }
+}
+
+void OutdoorPvPMgr::HandlePlayerResurrects(Player *plr, uint32 zoneid)
+{
+    OutdoorPvPMap::iterator itr = m_OutdoorPvPMap.find(zoneid);
+    if(itr == m_OutdoorPvPMap.end())
+        return;
+
+    if(itr-&gt;second-&gt;HasPlayer(plr))
+        itr-&gt;second-&gt;HandlePlayerResurrects(plr, zoneid);
+}
\ No newline at end of file
diff --git a/src/game/OutdoorPvPMgr.h b/src/game/OutdoorPvPMgr.h
new file mode 100644
index 0000000..df4040d
--- /dev/null
+++ b/src/game/OutdoorPvPMgr.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS &lt;http://www.MaNGOScore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef OUTDOOR_PVP_MGR_H_
+#define OUTDOOR_PVP_MGR_H_
+
+#define OUTDOORPVP_OBJECTIVE_UPDATE_INTERVAL 1000
+
+#include "OutdoorPvP.h"
+#include "Policies/Singleton.h"
+
+class Player;
+class GameObject;
+class Creature;
+class ZoneScript;
+struct GossipMenuItems;
+
+// class to handle player enter / leave / areatrigger / GO use events
+class OutdoorPvPMgr
+{
+public:
+    // ctor
+    OutdoorPvPMgr();
+    // dtor
+    ~OutdoorPvPMgr();
+
+    // create outdoor pvp events
+    void InitOutdoorPvP();
+    // called when a player enters an outdoor pvp area
+    void HandlePlayerEnterZone(Player * plr, uint32 areaflag);
+    // called when player leaves an outdoor pvp area
+    void HandlePlayerLeaveZone(Player * plr, uint32 areaflag);
+    // called when player resurrects
+    void HandlePlayerResurrects(Player * plr, uint32 areaflag);
+    // return assigned outdoor pvp
+    OutdoorPvP * GetOutdoorPvPToZoneId(uint32 zoneid);
+    // handle custom (non-exist in dbc) spell if registered
+    bool HandleCustomSpell(Player * plr, uint32 spellId, GameObject* go);
+    // handle custom go if registered
+    bool HandleOpenGo(Player * plr, uint64 guid);
+
+    ZoneScript * GetZoneScript(uint32 zoneId);
+
+    void AddZone(uint32 zoneid, OutdoorPvP * handle);
+
+    void Update(uint32 diff);
+
+    void HandleGossipOption(Player * player, uint64 guid, uint32 gossipid);
+
+    bool CanTalkTo(Player * player, Creature * creature, GossipMenuItems gso);
+
+    void HandleDropFlag(Player * plr, uint32 spellId);
+
+    typedef std::vector&lt;OutdoorPvP*&gt; OutdoorPvPSet;
+    typedef std::map&lt;uint32 /* zoneid */, OutdoorPvP*&gt; OutdoorPvPMap;
+private:
+    // contains all initiated outdoor pvp events
+    // used when initing / cleaning up
+    OutdoorPvPSet  m_OutdoorPvPSet;
+    // maps the zone ids to an outdoor pvp event
+    // used in player event handling
+    OutdoorPvPMap   m_OutdoorPvPMap;
+    // update interval
+    uint32 m_UpdateTimer;
+};
+
+#define sOutdoorPvPMgr MaNGOS::Singleton&lt;OutdoorPvPMgr&gt;::Instance()
+
+#endif /*OUTDOOR_PVP_MGR_H_*/
\ No newline at end of file
diff --git a/src/game/OutdoorPvPNA.cpp b/src/game/OutdoorPvPNA.cpp
new file mode 100644
index 0000000..de7add0
--- /dev/null
+++ b/src/game/OutdoorPvPNA.cpp
@@ -0,0 +1,666 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS &lt;http://www.MaNGOScore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvPNA.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "OutdoorPvPMgr.h"
+#include "WorldPacket.h"
+#include "Language.h"
+#include "World.h"
+
+OutdoorPvPNA::OutdoorPvPNA()
+{
+    m_TypeId = OUTDOOR_PVP_NA;
+}
+
+void OutdoorPvPNA::HandleKillImpl(Player *plr, Unit * killed)
+{
+    if(killed-&gt;GetTypeId() == TYPEID_PLAYER &amp;&amp; plr-&gt;GetTeam() != ((Player*)killed)-&gt;GetTeam())
+    {
+        plr-&gt;KilledMonsterCredit(NA_CREDIT_MARKER); // 0 guid, btw it isn't even used in killedmonster function :S
+        if(plr-&gt;GetTeam() == ALLIANCE)
+            plr-&gt;CastSpell(plr,NA_KILL_TOKEN_ALLIANCE,true);
+        else
+            plr-&gt;CastSpell(plr,NA_KILL_TOKEN_HORDE,true);
+    }
+}
+
+uint32 OPvPCapturePointNA::GetAliveGuardsCount()
+{
+    uint32 cnt = 0;
+    for (std::map&lt;uint32, uint64&gt;::iterator itr = m_Creatures.begin(); itr != m_Creatures.end(); ++itr)
+    {
+        switch(itr-&gt;first)
+        {
+        case NA_NPC_GUARD_01:
+        case NA_NPC_GUARD_02:
+        case NA_NPC_GUARD_03:
+        case NA_NPC_GUARD_04:
+        case NA_NPC_GUARD_05:
+        case NA_NPC_GUARD_06:
+        case NA_NPC_GUARD_07:
+        case NA_NPC_GUARD_08:
+        case NA_NPC_GUARD_09:
+        case NA_NPC_GUARD_10:
+        case NA_NPC_GUARD_11:
+        case NA_NPC_GUARD_12:
+        case NA_NPC_GUARD_13:
+        case NA_NPC_GUARD_14:
+        case NA_NPC_GUARD_15:
+            {
+                if(Creature * cr = ObjectAccessor::GetCreatureInWorld(itr-&gt;second))
+                {
+                    if(cr-&gt;isAlive())
+                        ++cnt;
+                }
+                else if (CreatureData const * cd = sObjectMgr.GetCreatureData(GUID_LOPART(itr-&gt;second)))
+                {
+                    if(!cd-&gt;is_dead)
+                        ++cnt;
+                }
+            }
+            break;
+        default:
+            break;
+        }
+    }
+    return cnt;
+}
+
+void OPvPCapturePointNA::SpawnNPCsForTeam(uint32 team)
+{
+    const creature_type * creatures = NULL;
+    if(team == ALLIANCE)
+        creatures=AllianceControlNPCs;
+    else if(team == HORDE)
+        creatures=HordeControlNPCs;
+    else
+        return;
+    for (int i = 0; i &lt; NA_CONTROL_NPC_NUM; ++i)
+        AddCreature(i,creatures[i].entry,creatures[i].teamval,creatures[i].map,creatures[i].x,creatures[i].y,creatures[i].z,creatures[i].o,1000000);
+}
+
+void OPvPCapturePointNA::DeSpawnNPCs()
+{
+    for (int i = 0; i &lt; NA_CONTROL_NPC_NUM; ++i)
+        DelCreature(i);
+}
+
+void OPvPCapturePointNA::SpawnGOsForTeam(uint32 team)
+{
+    const go_type * gos = NULL;
+    if(team == ALLIANCE)
+        gos=AllianceControlGOs;
+    else if(team == HORDE)
+        gos=HordeControlGOs;
+    else
+        return;
+    for (int i = 0; i &lt; NA_CONTROL_GO_NUM; ++i)
+    {
+        if( i == NA_ROOST_S ||
+            i == NA_ROOST_W ||
+            i == NA_ROOST_N ||
+            i == NA_ROOST_E ||
+            i == NA_BOMB_WAGON_S ||
+            i == NA_BOMB_WAGON_W ||
+            i == NA_BOMB_WAGON_N ||
+            i == NA_BOMB_WAGON_E )
+            continue;   // roosts and bomb wagons are spawned when someone uses the matching destroyed roost
+        AddObject(i,gos[i].entry,gos[i].map,gos[i].x,gos[i].y,gos[i].z,gos[i].o,gos[i].rot0,gos[i].rot1,gos[i].rot2,gos[i].rot3);
+    }
+}
+
+void OPvPCapturePointNA::DeSpawnGOs()
+{
+    for (int i = 0; i &lt; NA_CONTROL_GO_NUM; ++i)
+    {
+        DelObject(i);
+    }
+}
+
+void OPvPCapturePointNA::FactionTakeOver(uint32 team)
+{
+    if(m_ControllingFaction)
+        sObjectMgr.RemoveGraveYardLink(NA_HALAA_GRAVEYARD,NA_HALAA_GRAVEYARD_ZONE,m_ControllingFaction,false);
+    if(m_ControllingFaction == ALLIANCE)
+        sWorld.SendZoneText(NA_HALAA_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_NA_LOOSE_A));
+    else if(m_ControllingFaction == HORDE)
+        sWorld.SendZoneText(NA_HALAA_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_NA_LOOSE_H));
+
+    m_ControllingFaction = team;
+    if(m_ControllingFaction)
+        sObjectMgr.AddGraveYardLink(NA_HALAA_GRAVEYARD,NA_HALAA_GRAVEYARD_ZONE,m_ControllingFaction,false);
+    DeSpawnGOs();
+    DeSpawnNPCs();
+    SpawnGOsForTeam(team);
+    SpawnNPCsForTeam(team);
+    m_GuardsAlive = NA_GUARDS_MAX;
+    m_capturable = false;
+    this-&gt;UpdateHalaaWorldState();
+    if(team == ALLIANCE)
+    {
+        m_WyvernStateSouth = WYVERN_NEU_HORDE;
+        m_WyvernStateNorth = WYVERN_NEU_HORDE;
+        m_WyvernStateEast = WYVERN_NEU_HORDE;
+        m_WyvernStateWest = WYVERN_NEU_HORDE;
+        m_PvP-&gt;TeamApplyBuff(TEAM_ALLIANCE, NA_CAPTURE_BUFF);
+        m_PvP-&gt;SendUpdateWorldState(NA_UI_HORDE_GUARDS_SHOW, 0);
+        m_PvP-&gt;SendUpdateWorldState(NA_UI_ALLIANCE_GUARDS_SHOW, 1);
+        m_PvP-&gt;SendUpdateWorldState(NA_UI_GUARDS_LEFT, m_GuardsAlive);
+        sWorld.SendZoneText(NA_HALAA_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_NA_CAPTURE_A));
+    }
+    else
+    {
+        m_WyvernStateSouth = WYVERN_NEU_ALLIANCE;
+        m_WyvernStateNorth = WYVERN_NEU_ALLIANCE;
+        m_WyvernStateEast = WYVERN_NEU_ALLIANCE;
+        m_WyvernStateWest = WYVERN_NEU_ALLIANCE;
+        m_PvP-&gt;TeamApplyBuff(TEAM_HORDE, NA_CAPTURE_BUFF);
+        m_PvP-&gt;SendUpdateWorldState(NA_UI_HORDE_GUARDS_SHOW, 1);
+        m_PvP-&gt;SendUpdateWorldState(NA_UI_ALLIANCE_GUARDS_SHOW, 0);
+        m_PvP-&gt;SendUpdateWorldState(NA_UI_GUARDS_LEFT, m_GuardsAlive);
+        sWorld.SendZoneText(NA_HALAA_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_NA_CAPTURE_H));
+    }
+    UpdateWyvernRoostWorldState(NA_ROOST_S);
+    UpdateWyvernRoostWorldState(NA_ROOST_N);
+    UpdateWyvernRoostWorldState(NA_ROOST_W);
+    UpdateWyvernRoostWorldState(NA_ROOST_E);
+}
+
+bool OPvPCapturePointNA::HandlePlayerEnter(Player *plr)
+{
+    if(OPvPCapturePoint::HandlePlayerEnter(plr))
+    {
+        plr-&gt;SendUpdateWorldState(NA_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+        plr-&gt;SendUpdateWorldState(NA_UI_TOWER_SLIDER_POS, phase);
+        plr-&gt;SendUpdateWorldState(NA_UI_TOWER_SLIDER_N, m_neutralValuePct);
+        return true;
+    }
+    return false;
+}
+
+void OPvPCapturePointNA::HandlePlayerLeave(Player *plr)
+{
+    plr-&gt;SendUpdateWorldState(NA_UI_TOWER_SLIDER_DISPLAY, 0);
+    OPvPCapturePoint::HandlePlayerLeave(plr);
+}
+
+OPvPCapturePointNA::OPvPCapturePointNA(OutdoorPvP *pvp) :
+OPvPCapturePoint(pvp), m_capturable(true), m_GuardsAlive(0), m_ControllingFaction(0),
+m_HalaaState(HALAA_N), m_WyvernStateSouth(0), m_WyvernStateNorth(0), m_WyvernStateWest(0),
+m_WyvernStateEast(0), m_RespawnTimer(NA_RESPAWN_TIME), m_GuardCheckTimer(NA_GUARD_CHECK_TIME)
+{
+    SetCapturePointData(182210,530,-1572.57f,7945.3f,-22.475f,2.05949f,0,0,0.857167f,0.515038f);
+}
+
+bool OutdoorPvPNA::SetupOutdoorPvP()
+{
+//    m_TypeId = OUTDOOR_PVP_NA; _MUST_ be set in ctor, because of spawns cleanup
+    // add the zones affected by the pvp buff
+    RegisterZone(NA_BUFF_ZONE);
+
+    // halaa
+    m_obj = new OPvPCapturePointNA(this);
+    if(!m_obj)
+        return false;
+    AddCapturePoint(m_obj);
+
+    return true;
+}
+
+void OutdoorPvPNA::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    // add buffs
+    if(plr-&gt;GetTeam() == m_obj-&gt;m_ControllingFaction)
+        plr-&gt;CastSpell(plr,NA_CAPTURE_BUFF,true);
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPNA::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    plr-&gt;RemoveAurasDueToSpell(NA_CAPTURE_BUFF);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+void OutdoorPvPNA::FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count)
+{
+    m_obj-&gt;FillInitialWorldStates(data, count);
+}
+
+void OPvPCapturePointNA::FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count)
+{
+    if(m_ControllingFaction == ALLIANCE)
+    {
+        FillInitialWorldState(data, count, NA_UI_HORDE_GUARDS_SHOW,      0);
+        FillInitialWorldState(data, count, NA_UI_ALLIANCE_GUARDS_SHOW,   1);
+    }
+    else if(m_ControllingFaction == HORDE)
+    {
+        FillInitialWorldState(data, count, NA_UI_HORDE_GUARDS_SHOW,      1);
+        FillInitialWorldState(data, count, NA_UI_ALLIANCE_GUARDS_SHOW,   0);
+    }
+    else
+    {
+        FillInitialWorldState(data, count, NA_UI_HORDE_GUARDS_SHOW,      0);
+        FillInitialWorldState(data, count, NA_UI_ALLIANCE_GUARDS_SHOW,   0);
+    }
+
+    FillInitialWorldState(data, count, NA_UI_GUARDS_MAX,           NA_GUARDS_MAX);
+    FillInitialWorldState(data, count, NA_UI_GUARDS_LEFT,          m_GuardsAlive);
+
+    FillInitialWorldState(data, count, NA_UI_TOWER_SLIDER_DISPLAY, 0);
+    FillInitialWorldState(data, count, NA_UI_TOWER_SLIDER_POS,     50);
+    FillInitialWorldState(data, count, NA_UI_TOWER_SLIDER_N,       100);
+
+    FillInitialWorldState(data, count, NA_MAP_WYVERN_NORTH_NEU_H,  bool(m_WyvernStateNorth &amp; WYVERN_NEU_HORDE));
+    FillInitialWorldState(data, count, NA_MAP_WYVERN_NORTH_NEU_A,  bool(m_WyvernStateNorth &amp; WYVERN_NEU_ALLIANCE));
+    FillInitialWorldState(data, count, NA_MAP_WYVERN_NORTH_H,      bool(m_WyvernStateNorth &amp; WYVERN_HORDE));
+    FillInitialWorldState(data, count, NA_MAP_WYVERN_NORTH_A,      bool(m_WyvernStateNorth &amp; WYVERN_ALLIANCE));
+
+    FillInitialWorldState(data, count, NA_MAP_WYVERN_SOUTH_NEU_H,  bool(m_WyvernStateSouth &amp; WYVERN_NEU_HORDE));
+    FillInitialWorldState(data, count, NA_MAP_WYVERN_SOUTH_NEU_A,  bool(m_WyvernStateSouth &amp; WYVERN_NEU_ALLIANCE));
+    FillInitialWorldState(data, count, NA_MAP_WYVERN_SOUTH_H,      bool(m_WyvernStateSouth &amp; WYVERN_HORDE));
+    FillInitialWorldState(data, count, NA_MAP_WYVERN_SOUTH_A,      bool(m_WyvernStateSouth &amp; WYVERN_ALLIANCE));
+
+    FillInitialWorldState(data, count, NA_MAP_WYVERN_WEST_NEU_H,  bool(m_WyvernStateWest &amp; WYVERN_NEU_HORDE));
+    FillInitialWorldState(data, count, NA_MAP_WYVERN_WEST_NEU_A,  bool(m_WyvernStateWest &amp; WYVERN_NEU_ALLIANCE));
+    FillInitialWorldState(data, count, NA_MAP_WYVERN_WEST_H,      bool(m_WyvernStateWest &amp; WYVERN_HORDE));
+    FillInitialWorldState(data, count, NA_MAP_WYVERN_WEST_A,      bool(m_WyvernStateWest &amp; WYVERN_ALLIANCE));
+
+    FillInitialWorldState(data, count, NA_MAP_WYVERN_EAST_NEU_H,  bool(m_WyvernStateEast &amp; WYVERN_NEU_HORDE));
+    FillInitialWorldState(data, count, NA_MAP_WYVERN_EAST_NEU_A,  bool(m_WyvernStateEast &amp; WYVERN_NEU_ALLIANCE));
+    FillInitialWorldState(data, count, NA_MAP_WYVERN_EAST_H,      bool(m_WyvernStateEast &amp; WYVERN_HORDE));
+    FillInitialWorldState(data, count, NA_MAP_WYVERN_EAST_A,      bool(m_WyvernStateEast &amp; WYVERN_ALLIANCE));
+
+
+
+    FillInitialWorldState(data, count, NA_MAP_HALAA_NEUTRAL,  bool(m_HalaaState &amp; HALAA_N));
+    FillInitialWorldState(data, count, NA_MAP_HALAA_NEU_A,    bool(m_HalaaState &amp; HALAA_N_A));
+    FillInitialWorldState(data, count, NA_MAP_HALAA_NEU_H,    bool(m_HalaaState &amp; HALAA_N_H));
+    FillInitialWorldState(data, count, NA_MAP_HALAA_HORDE,    bool(m_HalaaState &amp; HALAA_H));
+    FillInitialWorldState(data, count, NA_MAP_HALAA_ALLIANCE, bool(m_HalaaState &amp; HALAA_A));
+}
+
+void OutdoorPvPNA::SendRemoveWorldStates(Player *plr)
+{
+    plr-&gt;SendUpdateWorldState(NA_UI_HORDE_GUARDS_SHOW,0);
+    plr-&gt;SendUpdateWorldState(NA_UI_ALLIANCE_GUARDS_SHOW,0);
+    plr-&gt;SendUpdateWorldState(NA_UI_GUARDS_MAX,0);
+    plr-&gt;SendUpdateWorldState(NA_UI_GUARDS_LEFT,0);
+    plr-&gt;SendUpdateWorldState(NA_UI_TOWER_SLIDER_DISPLAY,0);
+    plr-&gt;SendUpdateWorldState(NA_UI_TOWER_SLIDER_POS,0);
+    plr-&gt;SendUpdateWorldState(NA_UI_TOWER_SLIDER_N,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_WYVERN_NORTH_NEU_H,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_WYVERN_NORTH_NEU_A,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_WYVERN_NORTH_H,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_WYVERN_NORTH_A,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_NEU_H,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_NEU_A,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_H,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_A,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_WYVERN_WEST_NEU_H,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_WYVERN_WEST_NEU_A,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_WYVERN_WEST_H,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_WYVERN_WEST_A,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_WYVERN_EAST_NEU_H,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_WYVERN_EAST_NEU_A,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_WYVERN_EAST_H,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_WYVERN_EAST_A,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_HALAA_NEUTRAL,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_HALAA_NEU_A,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_HALAA_NEU_H,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_HALAA_HORDE,0);
+    plr-&gt;SendUpdateWorldState(NA_MAP_HALAA_ALLIANCE,0);
+}
+
+bool OutdoorPvPNA::Update(uint32 diff)
+{
+    return m_obj-&gt;Update(diff);
+}
+
+bool OPvPCapturePointNA::HandleCustomSpell(Player * plr, uint32 spellId, GameObject * go)
+{
+    std::vector&lt;uint32&gt; nodes;
+    nodes.resize(2);
+    bool retval = false;
+    switch(spellId)
+    {
+    case NA_SPELL_FLY_NORTH:
+        nodes[0] = FlightPathStartNodes[NA_ROOST_N];
+        nodes[1] = FlightPathEndNodes[NA_ROOST_N];
+        plr-&gt;ActivateTaxiPathTo(nodes);
+        plr-&gt;SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+        plr-&gt;UpdatePvP(true,true);
+        retval = true;
+        break;
+    case NA_SPELL_FLY_SOUTH:
+        nodes[0] = FlightPathStartNodes[NA_ROOST_S];
+        nodes[1] = FlightPathEndNodes[NA_ROOST_S];
+        plr-&gt;ActivateTaxiPathTo(nodes);
+        plr-&gt;SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+        plr-&gt;UpdatePvP(true,true);
+        retval = true;
+        break;
+    case NA_SPELL_FLY_WEST:
+        nodes[0] = FlightPathStartNodes[NA_ROOST_W];
+        nodes[1] = FlightPathEndNodes[NA_ROOST_W];
+        plr-&gt;ActivateTaxiPathTo(nodes);
+        plr-&gt;SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+        plr-&gt;UpdatePvP(true,true);
+        retval = true;
+        break;
+    case NA_SPELL_FLY_EAST:
+        nodes[0] = FlightPathStartNodes[NA_ROOST_E];
+        nodes[1] = FlightPathEndNodes[NA_ROOST_E];
+        plr-&gt;ActivateTaxiPathTo(nodes);
+        plr-&gt;SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+        plr-&gt;UpdatePvP(true,true);
+        retval = true;
+        break;
+    default:
+        break;
+    }
+
+    if(retval)
+    {
+        //Adding items
+        uint32 noSpaceForCount = 0;
+
+        // check space and find places
+        ItemPosCountVec dest;
+
+        int32 count = 10;
+        uint32 itemid = 24538;
+                                                                // bomb id count
+        uint8 msg = plr-&gt;CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, itemid, count, &amp;noSpaceForCount );
+        if( msg != EQUIP_ERR_OK )                               // convert to possible store amount
+            count -= noSpaceForCount;
+
+        if( count == 0 || dest.empty())                         // can't add any
+        {
+            return true;
+        }
+
+        Item* item = plr-&gt;StoreNewItem( dest, itemid, true);
+
+        if(count &gt; 0 &amp;&amp; item)
+        {
+            plr-&gt;SendNewItem(item,count,true,false);
+        }
+
+        return true;
+    }
+    return false;
+}
+
+int32 OPvPCapturePointNA::HandleOpenGo(Player *plr, uint64 guid)
+{
+    uint32 retval = OPvPCapturePoint::HandleOpenGo(plr, guid);
+    if(retval&gt;=0)
+    {
+        const go_type * gos = NULL;
+        if(m_ControllingFaction == ALLIANCE)
+            gos=AllianceControlGOs;
+        else if(m_ControllingFaction == HORDE)
+            gos=HordeControlGOs;
+        else
+            return -1;
+
+        int32 del = -1;
+        int32 del2 = -1;
+        int32 add = -1;
+        int32 add2 = -1;
+
+        switch(retval)
+        {
+        case NA_DESTROYED_ROOST_S:
+            del = NA_DESTROYED_ROOST_S;
+            add = NA_ROOST_S;
+            add2 = NA_BOMB_WAGON_S;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateSouth = WYVERN_ALLIANCE;
+            else
+                m_WyvernStateSouth = WYVERN_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_S);
+            break;
+        case NA_DESTROYED_ROOST_N:
+            del = NA_DESTROYED_ROOST_N;
+            add = NA_ROOST_N;
+            add2 = NA_BOMB_WAGON_N;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateNorth = WYVERN_ALLIANCE;
+            else
+                m_WyvernStateNorth = WYVERN_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_N);
+            break;
+        case NA_DESTROYED_ROOST_W:
+            del = NA_DESTROYED_ROOST_W;
+            add = NA_ROOST_W;
+            add2 = NA_BOMB_WAGON_W;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateWest = WYVERN_ALLIANCE;
+            else
+                m_WyvernStateWest = WYVERN_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_W);
+            break;
+        case NA_DESTROYED_ROOST_E:
+            del = NA_DESTROYED_ROOST_E;
+            add = NA_ROOST_E;
+            add2 = NA_BOMB_WAGON_E;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateEast = WYVERN_ALLIANCE;
+            else
+                m_WyvernStateEast = WYVERN_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_E);
+            break;
+        case NA_BOMB_WAGON_S:
+            del = NA_BOMB_WAGON_S;
+            del2 = NA_ROOST_S;
+            add = NA_DESTROYED_ROOST_S;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateSouth = WYVERN_NEU_ALLIANCE;
+            else
+                m_WyvernStateSouth = WYVERN_NEU_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_S);
+            break;
+        case NA_BOMB_WAGON_N:
+            del = NA_BOMB_WAGON_N;
+            del2 = NA_ROOST_N;
+            add = NA_DESTROYED_ROOST_N;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateNorth = WYVERN_NEU_ALLIANCE;
+            else
+                m_WyvernStateNorth = WYVERN_NEU_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_N);
+            break;
+        case NA_BOMB_WAGON_W:
+            del = NA_BOMB_WAGON_W;
+            del2 = NA_ROOST_W;
+            add = NA_DESTROYED_ROOST_W;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateWest = WYVERN_NEU_ALLIANCE;
+            else
+                m_WyvernStateWest = WYVERN_NEU_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_W);
+            break;
+        case NA_BOMB_WAGON_E:
+            del = NA_BOMB_WAGON_E;
+            del2 = NA_ROOST_E;
+            add = NA_DESTROYED_ROOST_E;
+            if(m_ControllingFaction == HORDE)
+                m_WyvernStateEast = WYVERN_NEU_ALLIANCE;
+            else
+                m_WyvernStateEast = WYVERN_NEU_HORDE;
+            UpdateWyvernRoostWorldState(NA_ROOST_E);
+            break;
+        default:
+            return -1;
+            break;
+        }
+
+        if(del&gt;-1)
+            DelObject(del);
+
+        if(del2&gt;-1)
+            DelObject(del2);
+
+        if(add&gt;-1)
+            AddObject(add,gos[add].entry,gos[add].map,gos[add].x,gos[add].y,gos[add].z,gos[add].o,gos[add].rot0,gos[add].rot1,gos[add].rot2,gos[add].rot3);
+
+        if(add2&gt;-1)
+            AddObject(add2,gos[add2].entry,gos[add2].map,gos[add2].x,gos[add2].y,gos[add2].z,gos[add2].o,gos[add2].rot0,gos[add2].rot1,gos[add2].rot2,gos[add2].rot3);
+
+        return retval;
+    }
+    return -1;
+}
+
+bool OPvPCapturePointNA::Update(uint32 diff)
+{
+    // let the controlling faction advance in phase
+    bool capturable = false;
+    if(m_ControllingFaction == ALLIANCE &amp;&amp; m_activePlayers[0].size() &gt; m_activePlayers[1].size())
+        capturable = true;
+    else if(m_ControllingFaction == HORDE &amp;&amp; m_activePlayers[0].size() &lt; m_activePlayers[1].size())
+        capturable = true;
+
+    if(m_GuardCheckTimer &lt; diff)
+    {
+        m_GuardCheckTimer = NA_GUARD_CHECK_TIME;
+        uint32 cnt = GetAliveGuardsCount();
+        if(cnt != m_GuardsAlive)
+        {
+            m_GuardsAlive = cnt;
+            if(m_GuardsAlive == 0)
+                m_capturable = true;
+            // update the guard count for the players in zone
+            m_PvP-&gt;SendUpdateWorldState(NA_UI_GUARDS_LEFT,m_GuardsAlive);
+        }
+    } else m_GuardCheckTimer -= diff;
+
+    if(m_capturable || capturable)
+    {
+        if(m_RespawnTimer &lt; diff)
+        {
+            // if the guards have been killed, then the challenger has one hour to take over halaa.
+            // in case they fail to do it, the guards are respawned, and they have to start again.
+            if(m_ControllingFaction)
+                FactionTakeOver(m_ControllingFaction);
+            m_RespawnTimer = NA_RESPAWN_TIME;
+        } else m_RespawnTimer -= diff;
+
+        return OPvPCapturePoint::Update(diff);
+    }
+    return false;
+}
+
+void OPvPCapturePointNA::ChangeState()
+{
+    uint32 artkit = 21;
+    switch(m_State)
+    {
+        case OBJECTIVESTATE_NEUTRAL:
+            m_HalaaState = HALAA_N;
+            break;
+        case OBJECTIVESTATE_ALLIANCE:
+            m_HalaaState = HALAA_A;
+            FactionTakeOver(ALLIANCE);
+            artkit = 2;
+            break;
+        case OBJECTIVESTATE_HORDE:
+            m_HalaaState = HALAA_H;
+            FactionTakeOver(HORDE);
+            artkit = 1;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+            m_HalaaState = HALAA_N_A;
+            break;
+        case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+            m_HalaaState = HALAA_N_H;
+            break;
+        case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+            m_HalaaState = HALAA_N_A;
+            artkit = 2;
+            break;
+        case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+            m_HalaaState = HALAA_N_H;
+            artkit = 1;
+        break;
+    }
+
+    GameObject * flag = ObjectAccessor::GetGameObjectInWorld(ObjectGuid(HIGHGUID_GAMEOBJECT, m_capturePointGUID));
+    if(flag)
+    {
+        flag-&gt;SetGoArtKit(artkit);
+    }
+
+    UpdateHalaaWorldState();
+}
+
+void OPvPCapturePointNA::SendChangePhase()
+{
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(NA_UI_TOWER_SLIDER_DISPLAY, 1);
+    // send these updates to only the ones in this objective
+    uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+    SendUpdateWorldState(NA_UI_TOWER_SLIDER_POS, phase);
+    SendUpdateWorldState(NA_UI_TOWER_SLIDER_N, m_neutralValuePct);
+}
+
+void OPvPCapturePointNA::UpdateHalaaWorldState()
+{
+    m_PvP-&gt;SendUpdateWorldState( NA_MAP_HALAA_NEUTRAL ,uint32(bool(m_HalaaState &amp; HALAA_N)));
+    m_PvP-&gt;SendUpdateWorldState( NA_MAP_HALAA_NEU_A ,uint32(bool(m_HalaaState &amp; HALAA_N_A)));
+    m_PvP-&gt;SendUpdateWorldState( NA_MAP_HALAA_NEU_H ,uint32(bool(m_HalaaState &amp; HALAA_N_H)));
+    m_PvP-&gt;SendUpdateWorldState( NA_MAP_HALAA_HORDE ,uint32(bool(m_HalaaState &amp; HALAA_H)));
+    m_PvP-&gt;SendUpdateWorldState( NA_MAP_HALAA_ALLIANCE ,uint32(bool(m_HalaaState &amp; HALAA_A)));
+}
+
+void OPvPCapturePointNA::UpdateWyvernRoostWorldState(uint32 roost)
+{
+    switch(roost)
+    {
+    case NA_ROOST_S:
+        m_PvP-&gt;SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_NEU_H,uint32(bool(m_WyvernStateSouth &amp; WYVERN_NEU_HORDE)));
+        m_PvP-&gt;SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_NEU_A,uint32(bool(m_WyvernStateSouth &amp; WYVERN_NEU_ALLIANCE)));
+        m_PvP-&gt;SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_H,uint32(bool(m_WyvernStateSouth &amp; WYVERN_HORDE)));
+        m_PvP-&gt;SendUpdateWorldState(NA_MAP_WYVERN_SOUTH_A,uint32(bool(m_WyvernStateSouth &amp; WYVERN_ALLIANCE)));
+        break;
+    case NA_ROOST_N:
+        m_PvP-&gt;SendUpdateWorldState(NA_MAP_WYVERN_NORTH_NEU_H,uint32(bool(m_WyvernStateNorth &amp; WYVERN_NEU_HORDE)));
+        m_PvP-&gt;SendUpdateWorldState(NA_MAP_WYVERN_NORTH_NEU_A,uint32(bool(m_WyvernStateNorth &amp; WYVERN_NEU_ALLIANCE)));
+        m_PvP-&gt;SendUpdateWorldState(NA_MAP_WYVERN_NORTH_H,uint32(bool(m_WyvernStateNorth &amp; WYVERN_HORDE)));
+        m_PvP-&gt;SendUpdateWorldState(NA_MAP_WYVERN_NORTH_A,uint32(bool(m_WyvernStateNorth &amp; WYVERN_ALLIANCE)));
+        break;
+    case NA_ROOST_W:
+        m_PvP-&gt;SendUpdateWorldState(NA_MAP_WYVERN_WEST_NEU_H,uint32(bool(m_WyvernStateWest &amp; WYVERN_NEU_HORDE)));
+        m_PvP-&gt;SendUpdateWorldState(NA_MAP_WYVERN_WEST_NEU_A,uint32(bool(m_WyvernStateWest &amp; WYVERN_NEU_ALLIANCE)));
+        m_PvP-&gt;SendUpdateWorldState(NA_MAP_WYVERN_WEST_H,uint32(bool(m_WyvernStateWest &amp; WYVERN_HORDE)));
+        m_PvP-&gt;SendUpdateWorldState(NA_MAP_WYVERN_WEST_A,uint32(bool(m_WyvernStateWest &amp; WYVERN_ALLIANCE)));
+        break;
+    case NA_ROOST_E:
+        m_PvP-&gt;SendUpdateWorldState(NA_MAP_WYVERN_EAST_NEU_H,uint32(bool(m_WyvernStateEast &amp; WYVERN_NEU_HORDE)));
+        m_PvP-&gt;SendUpdateWorldState(NA_MAP_WYVERN_EAST_NEU_A,uint32(bool(m_WyvernStateEast &amp; WYVERN_NEU_ALLIANCE)));
+        m_PvP-&gt;SendUpdateWorldState(NA_MAP_WYVERN_EAST_H,uint32(bool(m_WyvernStateEast &amp; WYVERN_HORDE)));
+        m_PvP-&gt;SendUpdateWorldState(NA_MAP_WYVERN_EAST_A,uint32(bool(m_WyvernStateEast &amp; WYVERN_ALLIANCE)));
+        break;
+    }
+}
\ No newline at end of file
diff --git a/src/game/OutdoorPvPNA.h b/src/game/OutdoorPvPNA.h
new file mode 100644
index 0000000..e432815
--- /dev/null
+++ b/src/game/OutdoorPvPNA.h
@@ -0,0 +1,296 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS &lt;http://www.MaNGOScore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef OUTDOOR_PVP_NA_
+#define OUTDOOR_PVP_NA_
+
+// TODO: "sometimes" set to neutral
+
+#include "OutdoorPvPImpl.h"
+enum OutdoorPvPNASpells
+{
+    NA_KILL_TOKEN_ALLIANCE = 33005,
+    NA_KILL_TOKEN_HORDE = 33004,
+    NA_CAPTURE_BUFF = 33795  // strength of the halaani
+};
+// kill credit for pks
+const uint32 NA_CREDIT_MARKER = 24867;
+const uint32 NA_GUARDS_MAX = 15;
+
+const uint32 NA_BUFF_ZONE = 3518;
+
+const uint32 NA_HALAA_GRAVEYARD = 993;
+
+const uint32 NA_HALAA_GRAVEYARD_ZONE = 3518; // need to add zone id, not area id
+
+const uint32 NA_RESPAWN_TIME = 3600000; // one hour to capture after defeating all guards
+
+const uint32 NA_GUARD_CHECK_TIME = 500; // every half second
+
+enum OutdoorPvPNAWorldStates{
+    NA_UI_HORDE_GUARDS_SHOW = 2503,
+    NA_UI_ALLIANCE_GUARDS_SHOW = 2502,
+    NA_UI_GUARDS_MAX = 2493,
+    NA_UI_GUARDS_LEFT = 2491,
+
+    NA_UI_TOWER_SLIDER_DISPLAY = 2495,
+    NA_UI_TOWER_SLIDER_POS = 2494,
+    NA_UI_TOWER_SLIDER_N = 2497,
+
+    NA_MAP_WYVERN_NORTH_NEU_H = 2762,
+    NA_MAP_WYVERN_NORTH_NEU_A = 2662,
+    NA_MAP_WYVERN_NORTH_H = 2663,
+    NA_MAP_WYVERN_NORTH_A = 2664,
+
+    NA_MAP_WYVERN_SOUTH_NEU_H = 2760,
+    NA_MAP_WYVERN_SOUTH_NEU_A = 2670,
+    NA_MAP_WYVERN_SOUTH_H = 2668,
+    NA_MAP_WYVERN_SOUTH_A = 2669,
+
+    NA_MAP_WYVERN_WEST_NEU_H = 2761,
+    NA_MAP_WYVERN_WEST_NEU_A = 2667,
+    NA_MAP_WYVERN_WEST_H = 2665,
+    NA_MAP_WYVERN_WEST_A = 2666,
+
+    NA_MAP_WYVERN_EAST_NEU_H = 2763,
+    NA_MAP_WYVERN_EAST_NEU_A = 2659,
+    NA_MAP_WYVERN_EAST_H = 2660,
+    NA_MAP_WYVERN_EAST_A = 2661,
+
+    NA_MAP_HALAA_NEUTRAL = 2671,
+    NA_MAP_HALAA_NEU_A = 2676,
+    NA_MAP_HALAA_NEU_H = 2677,
+    NA_MAP_HALAA_HORDE = 2672,
+    NA_MAP_HALAA_ALLIANCE = 2673
+};
+
+const uint32 FLIGHT_NODES_NUM = 4;
+
+// used to access the elements of Horde/AllyControlGOs
+enum ControlGOTypes{
+    NA_ROOST_S = 0,
+    NA_ROOST_W = 1,
+    NA_ROOST_N = 2,
+    NA_ROOST_E = 3,
+
+    NA_BOMB_WAGON_S = 4,
+    NA_BOMB_WAGON_W = 5,
+    NA_BOMB_WAGON_N = 6,
+    NA_BOMB_WAGON_E = 7,
+
+    NA_DESTROYED_ROOST_S = 8,
+    NA_DESTROYED_ROOST_W = 9,
+    NA_DESTROYED_ROOST_N = 10,
+    NA_DESTROYED_ROOST_E = 11,
+
+    NA_CONTROL_GO_NUM = 12
+};
+
+const uint32 FlightPathStartNodes[FLIGHT_NODES_NUM] = {103,105,107,109};
+const uint32 FlightPathEndNodes[FLIGHT_NODES_NUM] = {104,106,108,110};
+
+enum FlightSpellsNA{
+    NA_SPELL_FLY_SOUTH = 32059,
+    NA_SPELL_FLY_WEST = 32068,
+    NA_SPELL_FLY_NORTH = 32075,
+    NA_SPELL_FLY_EAST = 32081
+};
+
+// spawned when the alliance is attacking, horde is in control
+const go_type HordeControlGOs[NA_CONTROL_GO_NUM] = {
+    {182267,530,-1815.8f,8036.51f,-26.2354f,-2.89725f,0,0,0.992546f,-0.121869f}, //ALLY_ROOST_SOUTH
+    {182280,530,-1507.95f,8132.1f,-19.5585f,-1.3439f,0,0,0.622515f,-0.782608f}, //ALLY_ROOST_WEST
+    {182281,530,-1384.52f,7779.33f,-11.1663f,-0.575959f,0,0,0.284015f,-0.95882f}, //ALLY_ROOST_NORTH
+    {182282,530,-1650.11f,7732.56f,-15.4505f,-2.80998f,0,0,0.986286f,-0.165048f}, //ALLY_ROOST_EAST
+
+    {182222,530,-1825.4022f,8039.2602f,-26.08f,-2.89725f,0,0,0.992546f,-0.121869f}, //HORDE_BOMB_WAGON_SOUTH
+    {182272,530,-1515.37f,8136.91f,-20.42f,-1.3439f,0,0,0.622515f,-0.782608f}, //HORDE_BOMB_WAGON_WEST
+    {182273,530,-1377.95f,7773.44f,-10.31f,-0.575959f,0,0,0.284015f,-0.95882f}, //HORDE_BOMB_WAGON_NORTH
+    {182274,530,-1659.87f,7733.15f,-15.75f,-2.80998f,0,0,0.986286f,-0.165048f}, //HORDE_BOMB_WAGON_EAST
+
+    {182266,530,-1815.8f,8036.51f,-26.2354f,-2.89725f,0,0,0.992546f,-0.121869f}, //DESTROYED_ALLY_ROOST_SOUTH
+    {182275,530,-1507.95f,8132.1f,-19.5585f,-1.3439f,0,0,0.622515f,-0.782608f}, //DESTROYED_ALLY_ROOST_WEST
+    {182276,530,-1384.52f,7779.33f,-11.1663f,-0.575959f,0,0,0.284015f,-0.95882f}, //DESTROYED_ALLY_ROOST_NORTH
+    {182277,530,-1650.11f,7732.56f,-15.4505f,-2.80998f,0,0,0.986286f,-0.165048f}  //DESTROYED_ALLY_ROOST_EAST
+};
+
+// spawned when the horde is attacking, alliance is in control
+const go_type AllianceControlGOs[NA_CONTROL_GO_NUM] = {
+    {182301,530,-1815.8f,8036.51f,-26.2354f,-2.89725f,0,0,0.992546f,-0.121869f}, //HORDE_ROOST_SOUTH
+    {182302,530,-1507.95f,8132.1f,-19.5585f,-1.3439f,0,0,0.622515f,-0.782608f}, //HORDE_ROOST_WEST
+    {182303,530,-1384.52f,7779.33f,-11.1663f,-0.575959f,0,0,0.284015f,-0.95882f}, //HORDE_ROOST_NORTH
+    {182304,530,-1650.11f,7732.56f,-15.4505f,-2.80998f,0,0,0.986286f,-0.165048f}, //HORDE_ROOST_EAST
+
+    {182305,530,-1825.4022f,8039.2602f,-26.08f,-2.89725f,0,0,0.992546f,-0.121869f}, //ALLY_BOMB_WAGON_SOUTH
+    {182306,530,-1515.37f,8136.91f,-20.42f,-1.3439f,0,0,0.622515f,-0.782608f}, //ALLY_BOMB_WAGON_WEST
+    {182307,530,-1377.95f,7773.44f,-10.31f,-0.575959f,0,0,0.284015f,-0.95882f}, //ALLY_BOMB_WAGON_NORTH
+    {182308,530,-1659.87f,7733.15f,-15.75f,-2.80998f,0,0,0.986286f,-0.165048f}, //ALLY_BOMB_WAGON_EAST
+
+    {182297,530,-1815.8f,8036.51f,-26.2354f,-2.89725f,0,0,0.992546f,-0.121869f}, //DESTROYED_HORDE_ROOST_SOUTH
+    {182298,530,-1507.95f,8132.1f,-19.5585f,-1.3439f,0,0,0.622515f,-0.782608f}, //DESTROYED_HORDE_ROOST_WEST
+    {182299,530,-1384.52f,7779.33f,-11.1663f,-0.575959f,0,0,0.284015f,-0.95882f}, //DESTROYED_HORDE_ROOST_NORTH
+    {182300,530,-1650.11f,7732.56f,-15.4505f,-2.80998f,0,0,0.986286f,-0.165048f}  //DESTROYED_HORDE_ROOST_EAST
+};
+
+enum ControlNPCTypes{
+    NA_NPC_RESEARCHER = 0,
+    NA_NPC_QUARTERMASTER,
+    NA_NPC_BLADE_MERCHANT,
+    NA_NPC_FOOD_MERCHANT,
+    NA_NPC_AMMO,
+
+    NA_NPC_GUARD_01,
+    NA_NPC_GUARD_02,
+    NA_NPC_GUARD_03,
+    NA_NPC_GUARD_04,
+    NA_NPC_GUARD_05,
+    NA_NPC_GUARD_06,
+    NA_NPC_GUARD_07,
+    NA_NPC_GUARD_08,
+    NA_NPC_GUARD_09,
+    NA_NPC_GUARD_10,
+    NA_NPC_GUARD_11,
+    NA_NPC_GUARD_12,
+    NA_NPC_GUARD_13,
+    NA_NPC_GUARD_14,
+    NA_NPC_GUARD_15,
+
+    NA_CONTROL_NPC_NUM
+};
+
+const creature_type HordeControlNPCs[NA_CONTROL_NPC_NUM] = {
+    {18816,67,530,-1523.92f,7951.76f,-17.6942f,3.51172f},
+    {18821,67,530,-1527.75f,7952.46f,-17.6948f,3.99317f},
+    {21474,67,530,-1520.14f,7927.11f,-20.2527f,3.39389f},
+    {21484,67,530,-1524.84f,7930.34f,-20.182f,3.6405f},
+    {21483,67,530,-1570.01f,7993.8f,-22.4505f,5.02655f},
+    {18192,67,530,-1654.06f,8000.46f,-26.59f,3.37f},
+    {18192,67,530,-1487.18f,7899.1f,-19.53f,0.954f},
+    {18192,67,530,-1480.88f,7908.79f,-19.19f,4.485f},
+    {18192,67,530,-1540.56f,7995.44f,-20.45f,0.947f},
+    {18192,67,530,-1546.95f,8000.85f,-20.72f,6.035f},
+    {18192,67,530,-1595.31f,7860.53f,-21.51f,3.747f},
+    {18192,67,530,-1642.31f,7995.59f,-25.8f,3.317f},
+    {18192,67,530,-1545.46f,7995.35f,-20.63f,1.094f},
+    {18192,67,530,-1487.58f,7907.99f,-19.27f,5.567f},
+    {18192,67,530,-1651.54f,7988.56f,-26.5289f,2.98451f},
+    {18192,67,530,-1602.46f,7866.43f,-22.1177f,4.74729f},
+    {18192,67,530,-1591.22f,7875.29f,-22.3536f,4.34587f},
+    {18192,67,530,-1550.6f,7944.45f,-21.63f,3.559f},
+    {18192,67,530,-1545.57f,7935.83f,-21.13f,3.448f},
+    {18192,67,530,-1550.86f,7937.56f,-21.7f,3.801f}
+};
+
+const creature_type AllianceControlNPCs[NA_CONTROL_NPC_NUM] = {
+    {18817,469,530,-1591.18f,8020.39f,-22.2042f,4.59022f},
+    {18822,469,530,-1588.0f,8019.0f,-22.2042f,4.06662f},
+    {21485,469,530,-1521.93f,7927.37f,-20.2299f,3.24631f},
+    {21487,469,530,-1540.33f,7971.95f,-20.7186f,3.07178f},
+    {21488,469,530,-1570.01f,7993.8f,-22.4505f,5.02655f},
+    {18256,469,530,-1654.06f,8000.46f,-26.59f,3.37f},
+    {18256,469,530,-1487.18f,7899.1f,-19.53f,0.954f},
+    {18256,469,530,-1480.88f,7908.79f,-19.19f,4.485f},
+    {18256,469,530,-1540.56f,7995.44f,-20.45f,0.947f},
+    {18256,469,530,-1546.95f,8000.85f,-20.72f,6.035f},
+    {18256,469,530,-1595.31f,7860.53f,-21.51f,3.747f},
+    {18256,469,530,-1642.31f,7995.59f,-25.8f,3.317f},
+    {18256,469,530,-1545.46f,7995.35f,-20.63f,1.094f},
+    {18256,469,530,-1487.58f,7907.99f,-19.27f,5.567f},
+    {18256,469,530,-1651.54f,7988.56f,-26.5289f,2.98451f},
+    {18256,469,530,-1602.46f,7866.43f,-22.1177f,4.74729f},
+    {18256,469,530,-1591.22f,7875.29f,-22.3536f,4.34587f},
+    {18256,469,530,-1603.75f,8000.36f,-24.18f,4.516f},
+    {18256,469,530,-1585.73f,7994.68f,-23.29f,4.439f},
+    {18256,469,530,-1595.5f,7991.27f,-23.53f,4.738f}
+};
+
+enum WyvernStates{
+    WYVERN_NEU_HORDE = 1,
+    WYVERN_NEU_ALLIANCE = 2,
+    WYVERN_HORDE = 4,
+    WYVERN_ALLIANCE = 8
+};
+
+enum HalaaStates{
+    HALAA_N = 1,
+    HALAA_N_A = 2,
+    HALAA_A = 4,
+    HALAA_N_H = 8,
+    HALAA_H = 16
+};
+
+class Unit;
+class Creature;
+class OutdoorPvPNA;
+class OPvPCapturePointNA : public OPvPCapturePoint
+{
+friend class OutdoorPvPNA;
+public:
+    OPvPCapturePointNA(OutdoorPvP * pvp);
+    bool Update(uint32 diff);
+    void ChangeState();
+    void SendChangePhase();
+    void FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+    bool HandleCustomSpell(Player *plr, uint32 spellId, GameObject * go);
+    int32 HandleOpenGo(Player *plr, uint64 guid);
+    uint32 GetAliveGuardsCount();
+protected:
+    // called when a faction takes control
+    void FactionTakeOver(uint32 team);
+
+    void DeSpawnNPCs();
+    void DeSpawnGOs();
+    void SpawnNPCsForTeam(uint32 team);
+    void SpawnGOsForTeam(uint32 team);
+
+    void UpdateWyvernRoostWorldState(uint32 roost);
+    void UpdateHalaaWorldState();
+
+private:
+    bool m_capturable;
+    uint32 m_GuardsAlive;
+    uint32 m_ControllingFaction;
+    uint32 m_WyvernStateNorth;
+    uint32 m_WyvernStateSouth;
+    uint32 m_WyvernStateEast;
+    uint32 m_WyvernStateWest;
+    uint32 m_HalaaState;
+    uint32 m_RespawnTimer;
+    uint32 m_GuardCheckTimer;
+};
+
+class OutdoorPvPNA : public OutdoorPvP
+{
+friend class OPvPCapturePointNA;
+public:
+    OutdoorPvPNA();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count);
+    void SendRemoveWorldStates(Player * plr);
+    void HandleKillImpl(Player * plr, Unit * killed);
+private:
+    OPvPCapturePointNA * m_obj;
+};
+
+#endif
\ No newline at end of file
diff --git a/src/game/OutdoorPvPSI.cpp b/src/game/OutdoorPvPSI.cpp
new file mode 100644
index 0000000..e8c27c6
--- /dev/null
+++ b/src/game/OutdoorPvPSI.cpp
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS &lt;http://www.MaNGOScore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvPSI.h"
+#include "WorldPacket.h"
+#include "Player.h"
+#include "GameObject.h"
+#include "MapManager.h"
+#include "ObjectMgr.h"
+#include "OutdoorPvPMgr.h"
+#include "Language.h"
+#include "World.h"
+
+OutdoorPvPSI::OutdoorPvPSI()
+{
+    m_TypeId = OUTDOOR_PVP_SI;
+    m_Gathered_A = 0;
+    m_Gathered_H = 0;
+    m_LastController = 0;
+}
+
+void OutdoorPvPSI::FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count)
+{
+    FillInitialWorldState(data, count, SI_GATHERED_A,     m_Gathered_A);
+    FillInitialWorldState(data, count, SI_GATHERED_H,     m_Gathered_H);
+    FillInitialWorldState(data, count, SI_SILITHYST_MAX,  SI_MAX_RESOURCES);
+}
+
+void OutdoorPvPSI::SendRemoveWorldStates(Player *plr)
+{
+    plr-&gt;SendUpdateWorldState(SI_GATHERED_A,0);
+    plr-&gt;SendUpdateWorldState(SI_GATHERED_H,0);
+    plr-&gt;SendUpdateWorldState(SI_SILITHYST_MAX,0);
+}
+
+void OutdoorPvPSI::UpdateWorldState()
+{
+    SendUpdateWorldState(SI_GATHERED_A,m_Gathered_A);
+    SendUpdateWorldState(SI_GATHERED_H,m_Gathered_H);
+    SendUpdateWorldState(SI_SILITHYST_MAX,SI_MAX_RESOURCES);
+}
+
+bool OutdoorPvPSI::SetupOutdoorPvP()
+{
+    for (int i = 0; i &lt; OutdoorPvPSIBuffZonesNum; ++i)
+        RegisterZone(OutdoorPvPSIBuffZones[i]);
+    return true;
+}
+
+bool OutdoorPvPSI::Update(uint32 diff)
+{
+    return false;
+}
+
+void OutdoorPvPSI::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if(plr-&gt;GetTeam() == m_LastController)
+        plr-&gt;CastSpell(plr,SI_CENARION_FAVOR,true);
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPSI::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    plr-&gt;RemoveAurasDueToSpell(SI_CENARION_FAVOR);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+bool OutdoorPvPSI::HandleAreaTrigger(Player *plr, uint32 trigger)
+{
+    switch(trigger)
+    {
+    case SI_AREATRIGGER_A:
+        if(plr-&gt;GetTeam() == ALLIANCE &amp;&amp; plr-&gt;HasAura(SI_SILITHYST_FLAG))
+        {
+            // remove aura
+            plr-&gt;RemoveAurasDueToSpell(SI_SILITHYST_FLAG);
+            ++ m_Gathered_A;
+            if(m_Gathered_A &gt;= SI_MAX_RESOURCES)
+            {
+                TeamApplyBuff(TEAM_ALLIANCE, SI_CENARION_FAVOR);
+                sWorld.SendZoneText(OutdoorPvPSIBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_SI_CAPTURE_A));
+                m_LastController = ALLIANCE;
+                m_Gathered_A = 0;
+                m_Gathered_H = 0;
+            }
+            UpdateWorldState();
+            // reward player
+            plr-&gt;CastSpell(plr,SI_TRACES_OF_SILITHYST,true);
+            // add 19 honor
+            plr-&gt;RewardHonor(NULL,1,19);
+            // add 20 cenarion circle repu
+            plr-&gt;GetReputationMgr().ModifyReputation(sFactionStore.LookupEntry(609),20);
+            // complete quest
+            plr-&gt;KilledMonsterCredit(SI_TURNIN_QUEST_CM_A);
+        }
+        return true;
+    case SI_AREATRIGGER_H:
+        if(plr-&gt;GetTeam() == HORDE &amp;&amp; plr-&gt;HasAura(SI_SILITHYST_FLAG))
+        {
+            // remove aura
+            plr-&gt;RemoveAurasDueToSpell(SI_SILITHYST_FLAG);
+            ++ m_Gathered_H;
+            if(m_Gathered_H &gt;= SI_MAX_RESOURCES)
+            {
+                TeamApplyBuff(TEAM_HORDE, SI_CENARION_FAVOR);
+                sWorld.SendZoneText(OutdoorPvPSIBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_SI_CAPTURE_H));
+                m_LastController = HORDE;
+                m_Gathered_A = 0;
+                m_Gathered_H = 0;
+            }
+            UpdateWorldState();
+            // reward player
+            plr-&gt;CastSpell(plr,SI_TRACES_OF_SILITHYST,true);
+            // add 19 honor
+            plr-&gt;RewardHonor(NULL,1,19);
+            // add 20 cenarion circle repu
+            plr-&gt;GetReputationMgr().ModifyReputation(sFactionStore.LookupEntry(609),20);
+            // complete quest
+            plr-&gt;KilledMonsterCredit(SI_TURNIN_QUEST_CM_H);
+        }
+        return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPSI::HandleDropFlag(Player *plr, uint32 spellId)
+{
+    if(spellId == SI_SILITHYST_FLAG)
+    {
+        // if it was dropped away from the player's turn-in point, then create a silithyst mound, if it was dropped near the areatrigger, then it was dispelled by the outdoorpvp, so do nothing
+        switch(plr-&gt;GetTeam())
+        {
+        case ALLIANCE:
+            {
+                AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(SI_AREATRIGGER_A);
+                if(atEntry)
+                {
+                    // 5.0f is safe-distance
+                    if(plr-&gt;GetDistance(atEntry-&gt;x,atEntry-&gt;y,atEntry-&gt;z) &gt; 5.0f + atEntry-&gt;radius)
+                    {
+                        // he dropped it further, summon mound
+                        GameObject * go = new GameObject;
+                        Map * map = plr-&gt;GetMap();
+                        if(!map)
+                        {
+                            delete go;
+                            return true;
+                        }
+
+                        if(!go-&gt;Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT),SI_SILITHYST_MOUND, map, plr-&gt;GetPhaseMask(), plr-&gt;GetPositionX(),plr-&gt;GetPositionY(),plr-&gt;GetPositionZ(),plr-&gt;GetOrientation(),0,0,0,0,100,GO_STATE_READY))
+                        {
+                            delete go;
+                        }
+                        else
+                        {
+                            go-&gt;SetRespawnTime(0);
+                            map-&gt;Add(go);
+                        }
+                    }
+                }
+            }
+            break;
+        case HORDE:
+            {
+                AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(SI_AREATRIGGER_H);
+                if(atEntry)
+                {
+                    // 5.0f is safe-distance
+                    if(plr-&gt;GetDistance(atEntry-&gt;x,atEntry-&gt;y,atEntry-&gt;z) &gt; 5.0f + atEntry-&gt;radius)
+                    {
+                        // he dropped it further, summon mound
+                        GameObject * go = new GameObject;
+                        Map * map = plr-&gt;GetMap();
+                        if(!map)
+                        {
+                          delete go;
+                          return true;
+                          }
+                        if(!go-&gt;Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT),SI_SILITHYST_MOUND, map, plr-&gt;GetPhaseMask() ,plr-&gt;GetPositionX(),plr-&gt;GetPositionY(),plr-&gt;GetPositionZ(),plr-&gt;GetOrientation(),0,0,0,0,100,GO_STATE_READY))
+                        {
+                            delete go;
+                        }
+                        else
+                        {
+                            go-&gt;SetRespawnTime(0);
+                            map-&gt;Add(go);
+                        }
+                    }
+                }
+            }
+            break;
+        }
+        return true;
+    }
+    return false;
+}
+
+bool OutdoorPvPSI::HandleCustomSpell(Player *plr, uint32 spellId, GameObject *go)
+{
+    if(!go || spellId != SI_SILITHYST_FLAG_GO_SPELL)
+        return false;
+    plr-&gt;CastSpell(plr,SI_SILITHYST_FLAG,true);
+    if(go-&gt;GetGOInfo()-&gt;id == SI_SILITHYST_MOUND)
+    {
+        // despawn go
+        go-&gt;SetRespawnTime(0);
+        go-&gt;Delete();
+    }
+    return true;
+}
\ No newline at end of file
diff --git a/src/game/OutdoorPvPSI.h b/src/game/OutdoorPvPSI.h
new file mode 100644
index 0000000..0633132
--- /dev/null
+++ b/src/game/OutdoorPvPSI.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS &lt;http://www.MaNGOScore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef OUTDOOR_PVP_SI_
+#define OUTDOOR_PVP_SI_
+
+#include "OutdoorPvPImpl.h"
+
+enum OutdoorPvPSISpells
+{
+    SI_SILITHYST_FLAG_GO_SPELL = 29518,
+    SI_SILITHYST_FLAG = 29519,
+    SI_TRACES_OF_SILITHYST = 29534,
+    SI_CENARION_FAVOR = 30754
+};
+
+const uint32 SI_MAX_RESOURCES = 200;
+
+const uint32 OutdoorPvPSIBuffZonesNum = 3;
+
+const uint32 OutdoorPvPSIBuffZones[OutdoorPvPSIBuffZonesNum] = { 1377, 3428, 3429 };
+
+const uint32 SI_AREATRIGGER_H = 4168;
+
+const uint32 SI_AREATRIGGER_A = 4162;
+
+const uint32 SI_TURNIN_QUEST_CM_A = 17090;
+
+const uint32 SI_TURNIN_QUEST_CM_H = 18199;
+
+const uint32 SI_SILITHYST_MOUND = 181597;
+
+enum SI_WorldStates{
+    SI_GATHERED_A = 2313,
+    SI_GATHERED_H = 2314,
+    SI_SILITHYST_MAX = 2317
+};
+
+class OutdoorPvPSI : public OutdoorPvP
+{
+public:
+    OutdoorPvPSI();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count);
+    void SendRemoveWorldStates(Player * plr);
+    bool HandleAreaTrigger(Player * plr, uint32 trigger);
+    bool HandleDropFlag(Player * plr, uint32 spellId);
+    bool HandleCustomSpell(Player * plr, uint32 spellId, GameObject *go);
+    void UpdateWorldState();
+private:
+    uint32 m_Gathered_A;
+    uint32 m_Gathered_H;
+    uint32 m_LastController;
+};
+
+#endif
\ No newline at end of file
diff --git a/src/game/OutdoorPvPTF.cpp b/src/game/OutdoorPvPTF.cpp
new file mode 100644
index 0000000..697c855
--- /dev/null
+++ b/src/game/OutdoorPvPTF.cpp
@@ -0,0 +1,311 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS &lt;http://www.MaNGOScore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvPTF.h"
+#include "OutdoorPvPMgr.h"
+#include "WorldPacket.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "Language.h"
+#include "World.h"
+
+OutdoorPvPTF::OutdoorPvPTF()
+{
+    m_TypeId = OUTDOOR_PVP_TF;
+}
+
+OPvPCapturePointTF::OPvPCapturePointTF(OutdoorPvP *pvp, OutdoorPvPTF_TowerType type)
+: OPvPCapturePoint(pvp), m_TowerType(type), m_TowerState(TF_TOWERSTATE_N)
+{
+    SetCapturePointData(TFCapturePoints[type].entry,TFCapturePoints[type].map,TFCapturePoints[type].x,TFCapturePoints[type].y,TFCapturePoints[type].z,TFCapturePoints[type].o,TFCapturePoints[type].rot0,TFCapturePoints[type].rot1,TFCapturePoints[type].rot2,TFCapturePoints[type].rot3);
+}
+
+void OPvPCapturePointTF::FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count)
+{
+    data &lt;&lt; uint32(TFTowerWorldStates[m_TowerType].n) &lt;&lt; uint32(bool(m_TowerState &amp; TF_TOWERSTATE_N));
+    data &lt;&lt; uint32(TFTowerWorldStates[m_TowerType].h) &lt;&lt; uint32(bool(m_TowerState &amp; TF_TOWERSTATE_H));
+    data &lt;&lt; uint32(TFTowerWorldStates[m_TowerType].a) &lt;&lt; uint32(bool(m_TowerState &amp; TF_TOWERSTATE_A));
+
+    FillInitialWorldState(data, count, TFTowerWorldStates[m_TowerType].n,     bool(m_TowerState &amp; TF_TOWERSTATE_N));
+    FillInitialWorldState(data, count, TFTowerWorldStates[m_TowerType].h,     bool(m_TowerState &amp; TF_TOWERSTATE_H));
+    FillInitialWorldState(data, count, TFTowerWorldStates[m_TowerType].a,     bool(m_TowerState &amp; TF_TOWERSTATE_A));
+}
+
+void OutdoorPvPTF::FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count)
+{
+    FillInitialWorldState(data, count, TF_UI_TOWER_SLIDER_POS,         50);
+    FillInitialWorldState(data, count, TF_UI_TOWER_SLIDER_N,           100);
+    FillInitialWorldState(data, count, TF_UI_TOWER_SLIDER_DISPLAY,     0);
+
+    FillInitialWorldState(data, count, TF_UI_TOWER_COUNT_H,             m_HordeTowersControlled);
+    FillInitialWorldState(data, count, TF_UI_TOWER_COUNT_A,             m_AllianceTowersControlled);
+    FillInitialWorldState(data, count, TF_UI_TOWERS_CONTROLLED_DISPLAY, !m_IsLocked);
+
+    FillInitialWorldState(data, count, TF_UI_LOCKED_TIME_MINUTES_FIRST_DIGIT,     first_digit);
+    FillInitialWorldState(data, count, TF_UI_LOCKED_TIME_MINUTES_SECOND_DIGIT,    second_digit);
+    FillInitialWorldState(data, count, TF_UI_LOCKED_TIME_HOURS,                   hours_left);
+
+    FillInitialWorldState(data, count, TF_UI_LOCKED_DISPLAY_NEUTRAL,     m_IsLocked &amp;&amp; (!m_HordeTowersControlled &amp;&amp; !m_AllianceTowersControlled));
+    FillInitialWorldState(data, count, TF_UI_LOCKED_DISPLAY_HORDE,       m_IsLocked &amp;&amp; (m_HordeTowersControlled &gt; m_AllianceTowersControlled));
+    FillInitialWorldState(data, count, TF_UI_LOCKED_DISPLAY_ALLIANCE,    m_IsLocked &amp;&amp; (m_HordeTowersControlled &lt; m_AllianceTowersControlled));
+
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+    {
+        itr-&gt;second-&gt;FillInitialWorldStates(data, count);
+    }
+}
+
+void OutdoorPvPTF::SendRemoveWorldStates(Player * plr)
+{
+    plr-&gt;SendUpdateWorldState(TF_UI_TOWER_SLIDER_POS,uint32(0));
+    plr-&gt;SendUpdateWorldState(TF_UI_TOWER_SLIDER_N,uint32(0));
+    plr-&gt;SendUpdateWorldState(TF_UI_TOWER_SLIDER_DISPLAY,uint32(0));
+
+    plr-&gt;SendUpdateWorldState(TF_UI_TOWER_COUNT_H,uint32(0));
+    plr-&gt;SendUpdateWorldState(TF_UI_TOWER_COUNT_A,uint32(0));
+    plr-&gt;SendUpdateWorldState(TF_UI_TOWERS_CONTROLLED_DISPLAY,uint32(0));
+
+    plr-&gt;SendUpdateWorldState(TF_UI_LOCKED_TIME_MINUTES_FIRST_DIGIT,uint32(0));
+    plr-&gt;SendUpdateWorldState(TF_UI_LOCKED_TIME_MINUTES_SECOND_DIGIT,uint32(0));
+    plr-&gt;SendUpdateWorldState(TF_UI_LOCKED_TIME_HOURS,uint32(0));
+
+    plr-&gt;SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_NEUTRAL,uint32(0));
+    plr-&gt;SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_HORDE,uint32(0));
+    plr-&gt;SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_ALLIANCE,uint32(0));
+
+    for (int i = 0; i &lt; TF_TOWER_NUM; ++i)
+    {
+        plr-&gt;SendUpdateWorldState(uint32(TFTowerWorldStates[i].n),uint32(0));
+        plr-&gt;SendUpdateWorldState(uint32(TFTowerWorldStates[i].h),uint32(0));
+        plr-&gt;SendUpdateWorldState(uint32(TFTowerWorldStates[i].a),uint32(0));
+    }
+}
+
+void OPvPCapturePointTF::UpdateTowerState()
+{
+    m_PvP-&gt;SendUpdateWorldState(uint32(TFTowerWorldStates[m_TowerType].n),uint32(bool(m_TowerState &amp; TF_TOWERSTATE_N)));
+    m_PvP-&gt;SendUpdateWorldState(uint32(TFTowerWorldStates[m_TowerType].h),uint32(bool(m_TowerState &amp; TF_TOWERSTATE_H)));
+    m_PvP-&gt;SendUpdateWorldState(uint32(TFTowerWorldStates[m_TowerType].a),uint32(bool(m_TowerState &amp; TF_TOWERSTATE_A)));
+}
+
+bool OPvPCapturePointTF::HandlePlayerEnter(Player *plr)
+{
+    if(OPvPCapturePoint::HandlePlayerEnter(plr))
+    {
+        plr-&gt;SendUpdateWorldState(TF_UI_TOWER_SLIDER_DISPLAY, 1);
+        uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+        plr-&gt;SendUpdateWorldState(TF_UI_TOWER_SLIDER_POS, phase);
+        plr-&gt;SendUpdateWorldState(TF_UI_TOWER_SLIDER_N, m_neutralValuePct);
+        return true;
+    }
+    return false;
+}
+
+void OPvPCapturePointTF::HandlePlayerLeave(Player *plr)
+{
+    plr-&gt;SendUpdateWorldState(TF_UI_TOWER_SLIDER_DISPLAY, 0);
+    OPvPCapturePoint::HandlePlayerLeave(plr);
+}
+
+bool OutdoorPvPTF::Update(uint32 diff)
+{
+    bool changed = false;
+
+    if(changed = OutdoorPvP::Update(diff))
+    {
+        if(m_AllianceTowersControlled == TF_TOWER_NUM)
+        {
+            TeamApplyBuff(TEAM_ALLIANCE, TF_CAPTURE_BUFF);
+            m_IsLocked = true;
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_NEUTRAL,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_HORDE,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_ALLIANCE,uint32(1));
+            SendUpdateWorldState(TF_UI_TOWERS_CONTROLLED_DISPLAY, uint32(0));
+        }
+        else if(m_HordeTowersControlled == TF_TOWER_NUM)
+        {
+            TeamApplyBuff(TEAM_HORDE, TF_CAPTURE_BUFF);
+            m_IsLocked = true;
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_NEUTRAL,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_HORDE,uint32(1));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_ALLIANCE,uint32(0));
+            SendUpdateWorldState(TF_UI_TOWERS_CONTROLLED_DISPLAY, uint32(0));
+        }
+        else
+        {
+            TeamCastSpell(TEAM_ALLIANCE, -TF_CAPTURE_BUFF);
+            TeamCastSpell(TEAM_HORDE, -TF_CAPTURE_BUFF);
+        }
+        SendUpdateWorldState(TF_UI_TOWER_COUNT_A, m_AllianceTowersControlled);
+        SendUpdateWorldState(TF_UI_TOWER_COUNT_H, m_HordeTowersControlled);
+    }
+    if(m_IsLocked)
+    {
+        // lock timer is down, release lock
+        if(m_LockTimer &lt; diff)
+        {
+            m_LockTimer = TF_LOCK_TIME;
+            m_LockTimerUpdate = 0;
+            m_IsLocked = false;
+            SendUpdateWorldState(TF_UI_TOWERS_CONTROLLED_DISPLAY, uint32(1));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_NEUTRAL,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_HORDE,uint32(0));
+            SendUpdateWorldState(TF_UI_LOCKED_DISPLAY_ALLIANCE,uint32(0));
+        }
+        else
+        {
+            // worldstateui update timer is down, update ui with new time data
+            if(m_LockTimerUpdate &lt; diff)
+            {
+                m_LockTimerUpdate = TF_LOCK_TIME_UPDATE;
+                uint32 minutes_left = m_LockTimer / 60000;
+                hours_left = minutes_left / 60;
+                minutes_left -= hours_left * 60;
+                second_digit = minutes_left % 10;
+                first_digit = minutes_left / 10;
+
+                SendUpdateWorldState(TF_UI_LOCKED_TIME_MINUTES_FIRST_DIGIT,first_digit);
+                SendUpdateWorldState(TF_UI_LOCKED_TIME_MINUTES_SECOND_DIGIT,second_digit);
+                SendUpdateWorldState(TF_UI_LOCKED_TIME_HOURS,hours_left);
+            } else m_LockTimerUpdate -= diff;
+            m_LockTimer -= diff;
+        }
+    }
+    return changed;
+}
+
+void OutdoorPvPTF::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if(plr-&gt;GetTeam() == ALLIANCE)
+    {
+        if(m_AllianceTowersControlled &gt;= TF_TOWER_NUM)
+            plr-&gt;CastSpell(plr,TF_CAPTURE_BUFF,true);
+    }
+    else
+    {
+        if(m_HordeTowersControlled &gt;= TF_TOWER_NUM)
+            plr-&gt;CastSpell(plr,TF_CAPTURE_BUFF,true);
+    }
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPTF::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    plr-&gt;RemoveAurasDueToSpell(TF_CAPTURE_BUFF);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+bool OutdoorPvPTF::SetupOutdoorPvP()
+{
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+
+    m_IsLocked = false;
+    m_LockTimer = TF_LOCK_TIME;
+    m_LockTimerUpdate = 0;
+    hours_left = 6;
+    second_digit = 0;
+    first_digit = 0;
+
+    // add the zones affected by the pvp buff
+    for (int i = 0; i &lt; OutdoorPvPTFBuffZonesNum; ++i)
+        RegisterZone(OutdoorPvPTFBuffZones[i]);
+
+    AddCapturePoint(new OPvPCapturePointTF(this,TF_TOWER_NW));
+    AddCapturePoint(new OPvPCapturePointTF(this,TF_TOWER_N));
+    AddCapturePoint(new OPvPCapturePointTF(this,TF_TOWER_NE));
+    AddCapturePoint(new OPvPCapturePointTF(this,TF_TOWER_SE));
+    AddCapturePoint(new OPvPCapturePointTF(this,TF_TOWER_S));
+
+    return true;
+}
+
+bool OPvPCapturePointTF::Update(uint32 diff)
+{
+    // can update even in locked state if gathers the controlling faction
+    bool canupdate = ((((OutdoorPvPTF*)m_PvP)-&gt;m_AllianceTowersControlled &gt; 0) &amp;&amp; m_activePlayers[0].size() &gt; m_activePlayers[1].size()) ||
+            ((((OutdoorPvPTF*)m_PvP)-&gt;m_HordeTowersControlled &gt; 0) &amp;&amp; m_activePlayers[0].size() &lt; m_activePlayers[1].size());
+    // if gathers the other faction, then only update if the pvp is unlocked
+    canupdate = canupdate || !((OutdoorPvPTF*)m_PvP)-&gt;m_IsLocked;
+    return canupdate &amp;&amp; OPvPCapturePoint::Update(diff);
+}
+
+void OPvPCapturePointTF::ChangeState()
+{
+    // if changing from controlling alliance to horde
+    if( m_OldState == OBJECTIVESTATE_ALLIANCE )
+    {
+        if(((OutdoorPvPTF*)m_PvP)-&gt;m_AllianceTowersControlled)
+            ((OutdoorPvPTF*)m_PvP)-&gt;m_AllianceTowersControlled--;
+        sWorld.SendZoneText(OutdoorPvPTFBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_TF_LOOSE_A));
+    }
+    // if changing from controlling horde to alliance
+    else if ( m_OldState == OBJECTIVESTATE_HORDE )
+    {
+        if(((OutdoorPvPTF*)m_PvP)-&gt;m_HordeTowersControlled)
+            ((OutdoorPvPTF*)m_PvP)-&gt;m_HordeTowersControlled--;
+        sWorld.SendZoneText(OutdoorPvPTFBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_TF_LOOSE_H));
+    }
+
+    uint32 artkit = 21;
+
+    switch(m_State)
+    {
+    case OBJECTIVESTATE_ALLIANCE:
+        m_TowerState = TF_TOWERSTATE_A;
+        artkit = 2;
+        if(((OutdoorPvPTF*)m_PvP)-&gt;m_AllianceTowersControlled&lt;TF_TOWER_NUM)
+            ((OutdoorPvPTF*)m_PvP)-&gt;m_AllianceTowersControlled++;
+        sWorld.SendZoneText(OutdoorPvPTFBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_TF_CAPTURE_A));
+        break;
+    case OBJECTIVESTATE_HORDE:
+        m_TowerState = TF_TOWERSTATE_H;
+        artkit = 1;
+        if(((OutdoorPvPTF*)m_PvP)-&gt;m_HordeTowersControlled&lt;TF_TOWER_NUM)
+            ((OutdoorPvPTF*)m_PvP)-&gt;m_HordeTowersControlled++;
+        sWorld.SendZoneText(OutdoorPvPTFBuffZones[0],sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_TF_CAPTURE_H));
+        break;
+    case OBJECTIVESTATE_NEUTRAL:
+    case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+    case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+    case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+    case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+        m_TowerState = TF_TOWERSTATE_N;
+        break;
+    }
+
+    GameObject * flag = ObjectAccessor::GetGameObjectInWorld(ObjectGuid(HIGHGUID_GAMEOBJECT, m_capturePointGUID));
+    if(flag)
+    {
+        flag-&gt;SetGoArtKit(artkit);
+    }
+
+    UpdateTowerState();
+}
+
+void OPvPCapturePointTF::SendChangePhase()
+{
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(TF_UI_TOWER_SLIDER_DISPLAY, 1);
+    // send these updates to only the ones in this objective
+    uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+    SendUpdateWorldState(TF_UI_TOWER_SLIDER_POS, phase);
+    // send this too, sometimes it resets :S
+    SendUpdateWorldState(TF_UI_TOWER_SLIDER_N, m_neutralValuePct);
+}
\ No newline at end of file
diff --git a/src/game/OutdoorPvPTF.h b/src/game/OutdoorPvPTF.h
new file mode 100644
index 0000000..3de197b
--- /dev/null
+++ b/src/game/OutdoorPvPTF.h
@@ -0,0 +1,116 @@
+#ifndef OUTDOOR_PVP_TF_
+#define OUTDOOR_PVP_TF_
+
+#include "OutdoorPvPImpl.h"
+
+const uint32 OutdoorPvPTFBuffZonesNum = 5;
+
+const uint32 OutdoorPvPTFBuffZones[OutdoorPvPTFBuffZonesNum] = { 3519 /*Terokkar Forest*/, 3791 /*Sethekk Halls*/, 3789 /*Shadow Labyrinth*/, 3792 /*Mana-Tombs*/, 3790 /*Auchenai Crypts*/ };
+
+// locked for 6 hours after capture
+const uint32 TF_LOCK_TIME = 3600 * 6 * 1000;
+// update lock timer every 1/4 minute (overkill, but this way it's sure the timer won't "jump" 2 minutes at once.)
+const uint32 TF_LOCK_TIME_UPDATE = 15000;
+
+// blessing of auchindoun
+#define TF_CAPTURE_BUFF 33377
+
+const uint32 TF_ALLY_QUEST = 11505;
+const uint32 TF_HORDE_QUEST = 11506;
+
+enum OutdoorPvPTF_TowerType{
+    TF_TOWER_NW = 0,
+    TF_TOWER_N,
+    TF_TOWER_NE,
+    TF_TOWER_SE,
+    TF_TOWER_S,
+    TF_TOWER_NUM
+};
+
+const go_type TFCapturePoints[TF_TOWER_NUM] = {
+    {183104,530,-3081.65f,5335.03f,17.1853f,-2.14675f,0,0,0.878817f,-0.477159f},
+    {183411,530,-2939.9f,4788.73f,18.987f,2.77507f,0,0,0.983255f,0.182236f},
+    {183412,530,-3174.94f,4440.97f,16.2281f,1.86750f,0,0.803857f,0.594823f},
+    {183413,530,-3603.31f,4529.15f,20.9077f,0.994838f,0,0,0.477159f,0.878817f},
+    {183414,530,-3812.37f,4899.3f,17.7249f,0.087266f,0,0,0.043619f,0.999048f}
+};
+
+struct tf_tower_world_state{
+    uint32 n;
+    uint32 h;
+    uint32 a;
+};
+
+const tf_tower_world_state TFTowerWorldStates[TF_TOWER_NUM] = {
+    {0xa79,0xa7a,0xa7b},
+    {0xa7e,0xa7d,0xa7c},
+    {0xa82,0xa81,0xa80},
+    {0xa88,0xa87,0xa86},
+    {0xa85,0xa84,0xa83}
+};
+
+const uint32 TFTowerPlayerEnterEvents[TF_TOWER_NUM] = {12226, 12497, 12486, 12499, 12501};
+
+const uint32 TFTowerPlayerLeaveEvents[TF_TOWER_NUM] = {12225, 12496, 12487, 12498, 12500};
+
+enum TFWorldStates{
+    TF_UI_TOWER_SLIDER_POS = 0xa41,
+    TF_UI_TOWER_SLIDER_N = 0xa40,
+    TF_UI_TOWER_SLIDER_DISPLAY = 0xa3f,
+
+    TF_UI_TOWER_COUNT_H = 0xa3e,
+    TF_UI_TOWER_COUNT_A = 0xa3d,
+    TF_UI_TOWERS_CONTROLLED_DISPLAY = 0xa3c,
+
+    TF_UI_LOCKED_TIME_MINUTES_FIRST_DIGIT = 0x9d0,
+    TF_UI_LOCKED_TIME_MINUTES_SECOND_DIGIT = 0x9ce,
+    TF_UI_LOCKED_TIME_HOURS = 0x9cd,
+    TF_UI_LOCKED_DISPLAY_NEUTRAL = 0x9cc,
+    TF_UI_LOCKED_DISPLAY_HORDE = 0xad0,
+    TF_UI_LOCKED_DISPLAY_ALLIANCE = 0xacf
+};
+
+enum TFTowerStates {
+    TF_TOWERSTATE_N = 1,
+    TF_TOWERSTATE_H = 2,
+    TF_TOWERSTATE_A = 4
+};
+
+class OPvPCapturePointTF : public OPvPCapturePoint
+{
+public:
+    OPvPCapturePointTF(OutdoorPvP * pvp, OutdoorPvPTF_TowerType type);
+    bool Update(uint32 diff);
+    void ChangeState();
+    void SendChangePhase();
+    void FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+    void UpdateTowerState();
+protected:
+    OutdoorPvPTF_TowerType m_TowerType;
+    uint32 m_TowerState;
+};
+
+class OutdoorPvPTF : public OutdoorPvP
+{
+friend class OPvPCapturePointTF;
+public:
+    OutdoorPvPTF();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count);
+    void SendRemoveWorldStates(Player * plr);
+private:
+    bool m_IsLocked;
+    uint32 m_LockTimer;
+    uint32 m_LockTimerUpdate;
+    uint32 m_AllianceTowersControlled;
+    uint32 m_HordeTowersControlled;
+    uint32 hours_left, second_digit, first_digit;
+};
+
+#endif
\ No newline at end of file
diff --git a/src/game/OutdoorPvPZM.cpp b/src/game/OutdoorPvPZM.cpp
new file mode 100644
index 0000000..80ee726
--- /dev/null
+++ b/src/game/OutdoorPvPZM.cpp
@@ -0,0 +1,430 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS &lt;http://www.MaNGOScore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "OutdoorPvPZM.h"
+#include "ObjectMgr.h"
+#include "OutdoorPvPMgr.h"
+#include "Player.h"
+#include "Creature.h"
+#include "ObjectAccessor.h"
+#include "WorldPacket.h"
+#include "GossipDef.h"
+#include "World.h"
+
+OPvPCapturePointZM_Beacon::OPvPCapturePointZM_Beacon(OutdoorPvP *pvp, ZM_BeaconType type)
+: OPvPCapturePoint(pvp), m_TowerType(type), m_TowerState(ZM_TOWERSTATE_N)
+{
+    SetCapturePointData(ZMCapturePoints[type].entry,ZMCapturePoints[type].map,ZMCapturePoints[type].x,ZMCapturePoints[type].y,ZMCapturePoints[type].z,ZMCapturePoints[type].o,ZMCapturePoints[type].rot0,ZMCapturePoints[type].rot1,ZMCapturePoints[type].rot2,ZMCapturePoints[type].rot3);
+}
+
+void OPvPCapturePointZM_Beacon::FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count)
+{
+    data &lt;&lt; uint32(ZMBeaconInfo[m_TowerType].ui_tower_n) &lt;&lt; uint32(bool(m_TowerState &amp; ZM_TOWERSTATE_N));
+    data &lt;&lt; uint32(ZMBeaconInfo[m_TowerType].map_tower_n) &lt;&lt; uint32(bool(m_TowerState &amp; ZM_TOWERSTATE_N));
+    data &lt;&lt; uint32(ZMBeaconInfo[m_TowerType].ui_tower_a) &lt;&lt; uint32(bool(m_TowerState &amp; ZM_TOWERSTATE_A));
+    data &lt;&lt; uint32(ZMBeaconInfo[m_TowerType].map_tower_a) &lt;&lt; uint32(bool(m_TowerState &amp; ZM_TOWERSTATE_A));
+    data &lt;&lt; uint32(ZMBeaconInfo[m_TowerType].ui_tower_h) &lt;&lt; uint32(bool(m_TowerState &amp; ZM_TOWERSTATE_H));
+    data &lt;&lt; uint32(ZMBeaconInfo[m_TowerType].map_tower_h) &lt;&lt; uint32(bool(m_TowerState &amp; ZM_TOWERSTATE_H));
+
+
+    FillInitialWorldState(data, count, ZMBeaconInfo[m_TowerType].ui_tower_n,   bool(m_TowerState &amp; ZM_TOWERSTATE_N));
+    FillInitialWorldState(data, count, ZMBeaconInfo[m_TowerType].map_tower_n,  bool(m_TowerState &amp; ZM_TOWERSTATE_N));
+    FillInitialWorldState(data, count, ZMBeaconInfo[m_TowerType].ui_tower_a,   bool(m_TowerState &amp; ZM_TOWERSTATE_A));
+    FillInitialWorldState(data, count, ZMBeaconInfo[m_TowerType].map_tower_a,  bool(m_TowerState &amp; ZM_TOWERSTATE_A));
+    FillInitialWorldState(data, count, ZMBeaconInfo[m_TowerType].ui_tower_h,   bool(m_TowerState &amp; ZM_TOWERSTATE_H));
+    FillInitialWorldState(data, count, ZMBeaconInfo[m_TowerType].map_tower_h,  bool(m_TowerState &amp; ZM_TOWERSTATE_H));
+}
+
+void OPvPCapturePointZM_Beacon::UpdateTowerState()
+{
+    m_PvP-&gt;SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].ui_tower_n),uint32(bool(m_TowerState &amp; ZM_TOWERSTATE_N)));
+    m_PvP-&gt;SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].map_tower_n),uint32(bool(m_TowerState &amp; ZM_TOWERSTATE_N)));
+    m_PvP-&gt;SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].ui_tower_a),uint32(bool(m_TowerState &amp; ZM_TOWERSTATE_A)));
+    m_PvP-&gt;SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].map_tower_a),uint32(bool(m_TowerState &amp; ZM_TOWERSTATE_A)));
+    m_PvP-&gt;SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].ui_tower_h),uint32(bool(m_TowerState &amp; ZM_TOWERSTATE_H)));
+    m_PvP-&gt;SendUpdateWorldState(uint32(ZMBeaconInfo[m_TowerType].map_tower_h),uint32(bool(m_TowerState &amp; ZM_TOWERSTATE_H)));
+}
+
+bool OPvPCapturePointZM_Beacon::HandlePlayerEnter(Player *plr)
+{
+    if(OPvPCapturePoint::HandlePlayerEnter(plr))
+    {
+        plr-&gt;SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_disp, 1);
+        uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+        plr-&gt;SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_pos, phase);
+        plr-&gt;SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_n, m_neutralValuePct);
+        return true;
+    }
+    return false;
+}
+
+void OPvPCapturePointZM_Beacon::HandlePlayerLeave(Player *plr)
+{
+    plr-&gt;SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_disp, 0);
+    OPvPCapturePoint::HandlePlayerLeave(plr);
+}
+
+void OPvPCapturePointZM_Beacon::ChangeState()
+{
+    // if changing from controlling alliance to horde
+    if( m_OldState == OBJECTIVESTATE_ALLIANCE )
+    {
+        if(((OutdoorPvPZM*)m_PvP)-&gt;m_AllianceTowersControlled)
+            ((OutdoorPvPZM*)m_PvP)-&gt;m_AllianceTowersControlled--;
+        sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(ZMBeaconLooseA[m_TowerType]));
+    }
+    // if changing from controlling horde to alliance
+    else if ( m_OldState == OBJECTIVESTATE_HORDE )
+    {
+        if(((OutdoorPvPZM*)m_PvP)-&gt;m_HordeTowersControlled)
+            ((OutdoorPvPZM*)m_PvP)-&gt;m_HordeTowersControlled--;
+        sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(ZMBeaconLooseH[m_TowerType]));
+    }
+
+    switch(m_State)
+    {
+        case OBJECTIVESTATE_ALLIANCE:
+            m_TowerState = ZM_TOWERSTATE_A;
+            if(((OutdoorPvPZM*)m_PvP)-&gt;m_AllianceTowersControlled&lt;ZM_NUM_BEACONS)
+                ((OutdoorPvPZM*)m_PvP)-&gt;m_AllianceTowersControlled++;
+            sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(ZMBeaconCaptureA[m_TowerType]));
+            break;
+        case OBJECTIVESTATE_HORDE:
+            m_TowerState = ZM_TOWERSTATE_H;
+            if(((OutdoorPvPZM*)m_PvP)-&gt;m_HordeTowersControlled&lt;ZM_NUM_BEACONS)
+                ((OutdoorPvPZM*)m_PvP)-&gt;m_HordeTowersControlled++;
+            sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(ZMBeaconCaptureH[m_TowerType]));
+            break;
+        case OBJECTIVESTATE_NEUTRAL:
+        case OBJECTIVESTATE_NEUTRAL_ALLIANCE_CHALLENGE:
+        case OBJECTIVESTATE_NEUTRAL_HORDE_CHALLENGE:
+        case OBJECTIVESTATE_ALLIANCE_HORDE_CHALLENGE:
+        case OBJECTIVESTATE_HORDE_ALLIANCE_CHALLENGE:
+            m_TowerState = ZM_TOWERSTATE_N;
+            break;
+    }
+
+    UpdateTowerState();
+}
+
+void OPvPCapturePointZM_Beacon::SendChangePhase()
+{
+    // send this too, sometimes the slider disappears, dunno why :(
+    SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_disp, 1);
+    // send these updates to only the ones in this objective
+    uint32 phase = (uint32)ceil(( m_value + m_maxValue) / ( 2 * m_maxValue ) * 100.0f);
+    SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_pos, phase);
+    SendUpdateWorldState(ZMBeaconInfo[m_TowerType].slider_n, m_neutralValuePct);
+}
+
+bool OutdoorPvPZM::Update(uint32 diff)
+{
+    bool changed = false;
+    if(changed = OutdoorPvP::Update(diff))
+    {
+        if(m_AllianceTowersControlled == ZM_NUM_BEACONS)
+            m_GraveYard-&gt;SetBeaconState(ALLIANCE);
+        else if(m_HordeTowersControlled == ZM_NUM_BEACONS)
+            m_GraveYard-&gt;SetBeaconState(HORDE);
+        else
+            m_GraveYard-&gt;SetBeaconState(0);
+    }
+    return changed;
+}
+
+void OutdoorPvPZM::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if(plr-&gt;GetTeam() == ALLIANCE)
+    {
+        if(m_GraveYard-&gt;m_GraveYardState &amp; ZM_GRAVEYARD_A)
+            plr-&gt;CastSpell(plr,ZM_CAPTURE_BUFF,true);
+    }
+    else
+    {
+        if(m_GraveYard-&gt;m_GraveYardState &amp; ZM_GRAVEYARD_H)
+            plr-&gt;CastSpell(plr,ZM_CAPTURE_BUFF,true);
+    }
+    OutdoorPvP::HandlePlayerEnterZone(plr,zone);
+}
+
+void OutdoorPvPZM::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    // remove buffs
+    plr-&gt;RemoveAurasDueToSpell(ZM_CAPTURE_BUFF);
+    // remove flag
+    plr-&gt;RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_A);
+    plr-&gt;RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_H);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+}
+
+OutdoorPvPZM::OutdoorPvPZM()
+{
+    m_TypeId = OUTDOOR_PVP_ZM;
+    m_GraveYard = NULL;
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+
+}
+
+bool OutdoorPvPZM::SetupOutdoorPvP()
+{
+    m_AllianceTowersControlled = 0;
+    m_HordeTowersControlled = 0;
+
+    // add the zones affected by the pvp buff
+    for (int i = 0; i &lt; OutdoorPvPZMBuffZonesNum; ++i)
+        RegisterZone(OutdoorPvPZMBuffZones[i]);
+
+    AddCapturePoint(new OPvPCapturePointZM_Beacon(this,ZM_BEACON_WEST));
+    AddCapturePoint(new OPvPCapturePointZM_Beacon(this,ZM_BEACON_EAST));
+    m_GraveYard = new OPvPCapturePointZM_GraveYard(this);
+    AddCapturePoint(m_GraveYard); // though the update function isn't used, the handleusego is!
+
+    return true;
+}
+
+void OutdoorPvPZM::HandleKillImpl(Player *plr, Unit * killed)
+{
+    if(killed-&gt;GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    if(plr-&gt;GetTeam() == ALLIANCE &amp;&amp; ((Player*)killed)-&gt;GetTeam() != ALLIANCE)
+        plr-&gt;CastSpell(plr,ZM_AlliancePlayerKillReward,true);
+    else if(plr-&gt;GetTeam() == HORDE &amp;&amp; ((Player*)killed)-&gt;GetTeam() != HORDE)
+        plr-&gt;CastSpell(plr,ZM_HordePlayerKillReward,true);
+}
+
+bool OPvPCapturePointZM_GraveYard::Update(uint32 diff)
+{
+    bool retval = m_State != m_OldState;
+    m_State = m_OldState;
+    return retval;
+}
+
+int32 OPvPCapturePointZM_GraveYard::HandleOpenGo(Player *plr, uint64 guid)
+{
+    uint32 retval = OPvPCapturePoint::HandleOpenGo(plr, guid);
+    if(retval&gt;=0)
+    {
+        if(plr-&gt;HasAura(ZM_BATTLE_STANDARD_A) &amp;&amp; m_GraveYardState != ZM_GRAVEYARD_A)
+        {
+            if(m_GraveYardState == ZM_GRAVEYARD_H)
+                sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_ZM_LOOSE_GY_H));
+            m_GraveYardState = ZM_GRAVEYARD_A;
+            DelObject(0);   // only one gotype is used in the whole outdoor pvp, no need to call it a constant
+            AddObject(0,ZM_Banner_A.entry,ZM_Banner_A.map,ZM_Banner_A.x,ZM_Banner_A.y,ZM_Banner_A.z,ZM_Banner_A.o,ZM_Banner_A.rot0,ZM_Banner_A.rot1,ZM_Banner_A.rot2,ZM_Banner_A.rot3);
+            sObjectMgr.RemoveGraveYardLink(ZM_GRAVEYARD_ID, ZM_GRAVEYARD_ZONE, HORDE);          // rem gy
+            sObjectMgr.AddGraveYardLink(ZM_GRAVEYARD_ID, ZM_GRAVEYARD_ZONE, ALLIANCE, false);   // add gy
+            m_PvP-&gt;TeamApplyBuff(TEAM_ALLIANCE, ZM_CAPTURE_BUFF);
+            plr-&gt;RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_A);
+            sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_ZM_CAPTURE_GY_A));
+        }
+        else if(plr-&gt;HasAura(ZM_BATTLE_STANDARD_H) &amp;&amp; m_GraveYardState != ZM_GRAVEYARD_H)
+        {
+            if(m_GraveYardState == ZM_GRAVEYARD_A)
+                sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_ZM_LOOSE_GY_A));
+            m_GraveYardState = ZM_GRAVEYARD_H;
+            DelObject(0);   // only one gotype is used in the whole outdoor pvp, no need to call it a constant
+            AddObject(0,ZM_Banner_H.entry,ZM_Banner_H.map,ZM_Banner_H.x,ZM_Banner_H.y,ZM_Banner_H.z,ZM_Banner_H.o,ZM_Banner_H.rot0,ZM_Banner_H.rot1,ZM_Banner_H.rot2,ZM_Banner_H.rot3);
+            sObjectMgr.RemoveGraveYardLink(ZM_GRAVEYARD_ID, ZM_GRAVEYARD_ZONE, ALLIANCE);          // rem gy
+            sObjectMgr.AddGraveYardLink(ZM_GRAVEYARD_ID, ZM_GRAVEYARD_ZONE, HORDE, false);   // add gy
+            m_PvP-&gt;TeamApplyBuff(TEAM_HORDE, ZM_CAPTURE_BUFF);
+            plr-&gt;RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_H);
+            sWorld.SendZoneText(ZM_GRAVEYARD_ZONE,sObjectMgr.GetMangosStringForDBCLocale(LANG_OPVP_ZM_CAPTURE_GY_H));
+        }
+        UpdateTowerState();
+    }
+    return retval;
+}
+
+OPvPCapturePointZM_GraveYard::OPvPCapturePointZM_GraveYard(OutdoorPvP *pvp)
+: OPvPCapturePoint(pvp)
+{
+    m_BothControllingFaction = 0;
+    m_GraveYardState = ZM_GRAVEYARD_N;
+    m_FlagCarrierGUID = 0;
+    // add field scouts here
+    AddCreature(ZM_ALLIANCE_FIELD_SCOUT,ZM_AllianceFieldScout.entry,ZM_AllianceFieldScout.teamval,ZM_AllianceFieldScout.map,ZM_AllianceFieldScout.x,ZM_AllianceFieldScout.y,ZM_AllianceFieldScout.z,ZM_AllianceFieldScout.o);
+    AddCreature(ZM_HORDE_FIELD_SCOUT,ZM_HordeFieldScout.entry,ZM_HordeFieldScout.teamval,ZM_HordeFieldScout.map,ZM_HordeFieldScout.x,ZM_HordeFieldScout.y,ZM_HordeFieldScout.z,ZM_HordeFieldScout.o);
+    // add neutral banner
+    AddObject(0,ZM_Banner_N.entry,ZM_Banner_N.map,ZM_Banner_N.x,ZM_Banner_N.y,ZM_Banner_N.z,ZM_Banner_N.o,ZM_Banner_N.rot0,ZM_Banner_N.rot1,ZM_Banner_N.rot2,ZM_Banner_N.rot3);
+}
+
+void OPvPCapturePointZM_GraveYard::UpdateTowerState()
+{
+    m_PvP-&gt;SendUpdateWorldState(ZM_MAP_GRAVEYARD_N,uint32(bool(m_GraveYardState &amp; ZM_GRAVEYARD_N)));
+    m_PvP-&gt;SendUpdateWorldState(ZM_MAP_GRAVEYARD_H,uint32(bool(m_GraveYardState &amp; ZM_GRAVEYARD_H)));
+    m_PvP-&gt;SendUpdateWorldState(ZM_MAP_GRAVEYARD_A,uint32(bool(m_GraveYardState &amp; ZM_GRAVEYARD_A)));
+
+    m_PvP-&gt;SendUpdateWorldState(ZM_MAP_ALLIANCE_FLAG_READY,uint32(m_BothControllingFaction == ALLIANCE));
+    m_PvP-&gt;SendUpdateWorldState(ZM_MAP_ALLIANCE_FLAG_NOT_READY,uint32(m_BothControllingFaction != ALLIANCE));
+    m_PvP-&gt;SendUpdateWorldState(ZM_MAP_HORDE_FLAG_READY,uint32(m_BothControllingFaction == HORDE));
+    m_PvP-&gt;SendUpdateWorldState(ZM_MAP_HORDE_FLAG_NOT_READY,uint32(m_BothControllingFaction != HORDE));
+}
+
+void OPvPCapturePointZM_GraveYard::FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count)
+{
+    FillInitialWorldState(data, count, ZM_MAP_GRAVEYARD_N,   bool(m_GraveYardState &amp; ZM_GRAVEYARD_N));
+    FillInitialWorldState(data, count, ZM_MAP_GRAVEYARD_H,   bool(m_GraveYardState &amp; ZM_GRAVEYARD_H));
+    FillInitialWorldState(data, count, ZM_MAP_GRAVEYARD_A,   bool(m_GraveYardState &amp; ZM_GRAVEYARD_A));
+
+    FillInitialWorldState(data, count, ZM_MAP_ALLIANCE_FLAG_READY,     m_BothControllingFaction == ALLIANCE);
+    FillInitialWorldState(data, count, ZM_MAP_ALLIANCE_FLAG_NOT_READY, m_BothControllingFaction != ALLIANCE);
+    FillInitialWorldState(data, count, ZM_MAP_HORDE_FLAG_READY,        m_BothControllingFaction == HORDE);
+    FillInitialWorldState(data, count, ZM_MAP_HORDE_FLAG_NOT_READY,    m_BothControllingFaction != HORDE);
+}
+
+void OPvPCapturePointZM_GraveYard::SetBeaconState(uint32 controlling_faction)
+{
+    // nothing to do here
+    if(m_BothControllingFaction == controlling_faction)
+        return;
+    m_BothControllingFaction = controlling_faction;
+
+    switch(controlling_faction)
+    {
+    case ALLIANCE:
+        // if ally already controls the gy and taken back both beacons, return, nothing to do for us
+        if(m_GraveYardState &amp; ZM_GRAVEYARD_A)
+            return;
+        // ally doesn't control the gy, but controls the side beacons -&gt; add gossip option, add neutral banner
+        break;
+    case HORDE:
+        // if horde already controls the gy and taken back both beacons, return, nothing to do for us
+        if(m_GraveYardState &amp; ZM_GRAVEYARD_H)
+            return;
+        // horde doesn't control the gy, but controls the side beacons -&gt; add gossip option, add neutral banner
+        break;
+    default:
+        // if the graveyard is not neutral, then leave it that way
+        // if the graveyard is neutral, then we have to dispel the buff from the flag carrier
+        if(m_GraveYardState &amp; ZM_GRAVEYARD_N)
+        {
+            // gy was neutral, thus neutral banner was spawned, it is possible that someone was taking the flag to the gy
+            if(m_FlagCarrierGUID)
+            {
+                // remove flag from carrier, reset flag carrier guid
+                Player * p = sObjectMgr.GetPlayer(m_FlagCarrierGUID);
+                if(p)
+                {
+                   p-&gt;RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_A);
+                   p-&gt;RemoveAurasDueToSpell(ZM_BATTLE_STANDARD_H);
+                }
+                m_FlagCarrierGUID = 0;
+            }
+        }
+        break;
+    }
+    // send worldstateupdate
+    UpdateTowerState();
+}
+
+bool OPvPCapturePointZM_GraveYard::CanTalkTo(Player * plr, Creature * c, GossipMenuItems gso)
+{
+    uint64 guid = c-&gt;GetGUID();
+    std::map&lt;uint64,uint32&gt;::iterator itr = m_CreatureTypes.find(guid);
+    if(itr != m_CreatureTypes.end())
+    {
+        if(itr-&gt;second == ZM_ALLIANCE_FIELD_SCOUT &amp;&amp; plr-&gt;GetTeam() == ALLIANCE &amp;&amp; m_BothControllingFaction == ALLIANCE &amp;&amp; !m_FlagCarrierGUID &amp;&amp; m_GraveYardState != ZM_GRAVEYARD_A)
+            return true;
+        else if(itr-&gt;second == ZM_HORDE_FIELD_SCOUT &amp;&amp; plr-&gt;GetTeam() == HORDE &amp;&amp; m_BothControllingFaction == HORDE &amp;&amp; !m_FlagCarrierGUID &amp;&amp; m_GraveYardState != ZM_GRAVEYARD_H)
+            return true;
+    }
+    return false;
+}
+
+bool OPvPCapturePointZM_GraveYard::HandleGossipOption(Player *plr, uint64 guid, uint32 gossipid)
+{
+    std::map&lt;uint64,uint32&gt;::iterator itr = m_CreatureTypes.find(guid);
+    if(itr != m_CreatureTypes.end())
+    {
+        Creature * cr = ObjectAccessor::GetCreatureInWorld(guid);
+        if(!cr)
+            return true;
+        // if the flag is already taken, then return
+        if(m_FlagCarrierGUID)
+            return true;
+        if(itr-&gt;second == ZM_ALLIANCE_FIELD_SCOUT)
+        {
+            cr-&gt;CastSpell(plr,ZM_BATTLE_STANDARD_A,true);
+            m_FlagCarrierGUID = plr-&gt;GetGUID();
+        }
+        else if(itr-&gt;second == ZM_HORDE_FIELD_SCOUT)
+        {
+            cr-&gt;CastSpell(plr,ZM_BATTLE_STANDARD_H,true);
+            m_FlagCarrierGUID = plr-&gt;GetGUID();
+        }
+        UpdateTowerState();
+        plr-&gt;PlayerTalkClass-&gt;CloseGossip();
+        return true;
+    }
+    return false;
+}
+
+bool OPvPCapturePointZM_GraveYard::HandleDropFlag(Player * plr, uint32 spellId)
+{
+    switch(spellId)
+    {
+    case ZM_BATTLE_STANDARD_A:
+        m_FlagCarrierGUID = 0;
+        return true;
+    case ZM_BATTLE_STANDARD_H:
+        m_FlagCarrierGUID = 0;
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPZM::FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count)
+{
+    FillInitialWorldState(data, count,  ZM_WORLDSTATE_UNK_1,   1);
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+    {
+        itr-&gt;second-&gt;FillInitialWorldStates(data, count);
+    }
+}
+
+void OutdoorPvPZM::SendRemoveWorldStates(Player *plr)
+{
+    plr-&gt;SendUpdateWorldState(ZM_UI_TOWER_SLIDER_N_W,0);
+    plr-&gt;SendUpdateWorldState(ZM_UI_TOWER_SLIDER_POS_W,0);
+    plr-&gt;SendUpdateWorldState(ZM_UI_TOWER_SLIDER_DISPLAY_W,0);
+    plr-&gt;SendUpdateWorldState(ZM_UI_TOWER_SLIDER_N_E,0);
+    plr-&gt;SendUpdateWorldState(ZM_UI_TOWER_SLIDER_POS_E,0);
+    plr-&gt;SendUpdateWorldState(ZM_UI_TOWER_SLIDER_DISPLAY_E,0);
+    plr-&gt;SendUpdateWorldState(ZM_WORLDSTATE_UNK_1,1);
+    plr-&gt;SendUpdateWorldState(ZM_UI_TOWER_EAST_N,0);
+    plr-&gt;SendUpdateWorldState(ZM_UI_TOWER_EAST_H,0);
+    plr-&gt;SendUpdateWorldState(ZM_UI_TOWER_EAST_A,0);
+    plr-&gt;SendUpdateWorldState(ZM_UI_TOWER_WEST_N,0);
+    plr-&gt;SendUpdateWorldState(ZM_UI_TOWER_WEST_H,0);
+    plr-&gt;SendUpdateWorldState(ZM_UI_TOWER_WEST_A,0);
+    plr-&gt;SendUpdateWorldState(ZM_MAP_TOWER_EAST_N,0);
+    plr-&gt;SendUpdateWorldState(ZM_MAP_TOWER_EAST_H,0);
+    plr-&gt;SendUpdateWorldState(ZM_MAP_TOWER_EAST_A,0);
+    plr-&gt;SendUpdateWorldState(ZM_MAP_GRAVEYARD_H,0);
+    plr-&gt;SendUpdateWorldState(ZM_MAP_GRAVEYARD_A,0);
+    plr-&gt;SendUpdateWorldState(ZM_MAP_GRAVEYARD_N,0);
+    plr-&gt;SendUpdateWorldState(ZM_MAP_TOWER_WEST_N,0);
+    plr-&gt;SendUpdateWorldState(ZM_MAP_TOWER_WEST_H,0);
+    plr-&gt;SendUpdateWorldState(ZM_MAP_TOWER_WEST_A,0);
+    plr-&gt;SendUpdateWorldState(ZM_MAP_HORDE_FLAG_READY,0);
+    plr-&gt;SendUpdateWorldState(ZM_MAP_HORDE_FLAG_NOT_READY,0);
+    plr-&gt;SendUpdateWorldState(ZM_MAP_ALLIANCE_FLAG_NOT_READY,0);
+    plr-&gt;SendUpdateWorldState(ZM_MAP_ALLIANCE_FLAG_READY,0);
+}
\ No newline at end of file
diff --git a/src/game/OutdoorPvPZM.h b/src/game/OutdoorPvPZM.h
new file mode 100644
index 0000000..0d73970
--- /dev/null
+++ b/src/game/OutdoorPvPZM.h
@@ -0,0 +1,218 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS &lt;http://www.MaNGOScore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef OUTDOOR_PVP_ZM_
+#define OUTDOOR_PVP_ZM_
+
+#include "OutdoorPvPImpl.h"
+#include "Language.h"
+
+const uint32 OutdoorPvPZMBuffZonesNum = 5;
+// the buff is cast in these zones
+const uint32 OutdoorPvPZMBuffZones[OutdoorPvPZMBuffZonesNum] = {3521,3607,3717,3715,3716};
+// linked when the central tower is controlled
+const uint32 ZM_GRAVEYARD_ZONE = 3521;
+// linked when the central tower is controlled
+const uint32 ZM_GRAVEYARD_ID = 969;
+
+enum OutdoorPvPZMSpells
+{
+    // cast on the players of the controlling faction
+    ZM_CAPTURE_BUFF = 33779,  // twin spire blessing
+    // spell that the field scout casts on the player to carry the flag
+    ZM_BATTLE_STANDARD_A = 32430,
+    // spell that the field scout casts on the player to carry the flag
+    ZM_BATTLE_STANDARD_H = 32431,
+    // token create spell
+    ZM_AlliancePlayerKillReward = 32155,
+    // token create spell
+    ZM_HordePlayerKillReward = 32158
+};
+
+// banners 182527, 182528, 182529, gotta check them ingame
+const go_type ZM_Banner_A = { 182527,530,253.54f,7083.81f,36.7728f,-0.017453f,0,0,0.008727f,-0.999962f };
+const go_type ZM_Banner_H = { 182528,530,253.54f,7083.81f,36.7728f,-0.017453f,0,0,0.008727f,-0.999962f };
+const go_type ZM_Banner_N = { 182529,530,253.54f,7083.81f,36.7728f,-0.017453f,0,0,0.008727f,-0.999962f };
+
+// horde field scout spawn data
+const creature_type ZM_HordeFieldScout = {18564,67,530,296.625f,7818.4f,42.6294f,5.18363f};
+// alliance field scout spawn data
+const creature_type ZM_AllianceFieldScout = {18581,469,530,374.395f,6230.08f,22.8351f,0.593412f};
+
+enum ZMCreatureTypes{
+    ZM_ALLIANCE_FIELD_SCOUT = 0,
+    ZM_HORDE_FIELD_SCOUT,
+    ZM_CREATURE_NUM
+};
+
+struct zm_beacon {
+    uint32 slider_disp;
+    uint32 slider_n;
+    uint32 slider_pos;
+    uint32 ui_tower_n;
+    uint32 ui_tower_h;
+    uint32 ui_tower_a;
+    uint32 map_tower_n;
+    uint32 map_tower_h;
+    uint32 map_tower_a;
+    uint32 event_enter;
+    uint32 event_leave;
+};
+
+enum ZM_BeaconType{
+    ZM_BEACON_EAST = 0,
+    ZM_BEACON_WEST,
+    ZM_NUM_BEACONS
+};
+
+const zm_beacon ZMBeaconInfo[ZM_NUM_BEACONS] = {
+    {2533,2535,2534,2560,2559,2558,2652,2651,2650,11807,11806},
+    {2527,2529,2528,2557,2556,2555,2646,2645,2644,11805,11804}
+};
+
+const uint32 ZMBeaconCaptureA[ZM_NUM_BEACONS] = {
+    LANG_OPVP_ZM_CAPTURE_EAST_A,
+    LANG_OPVP_ZM_CAPTURE_WEST_A
+};
+
+const uint32 ZMBeaconCaptureH[ZM_NUM_BEACONS] = {
+    LANG_OPVP_ZM_CAPTURE_EAST_H,
+    LANG_OPVP_ZM_CAPTURE_WEST_H
+};
+
+const uint32 ZMBeaconLooseA[ZM_NUM_BEACONS] = {
+    LANG_OPVP_ZM_LOOSE_EAST_A,
+    LANG_OPVP_ZM_LOOSE_WEST_A
+};
+
+const uint32 ZMBeaconLooseH[ZM_NUM_BEACONS] = {
+    LANG_OPVP_ZM_LOOSE_EAST_H,
+    LANG_OPVP_ZM_LOOSE_WEST_H
+};
+
+const go_type ZMCapturePoints[ZM_NUM_BEACONS] = {
+    {182523,530,303.243f,6841.36f,40.1245f,-1.58825f,0,0,0.71325f,-0.700909f},
+    {182522,530,336.466f,7340.26f,41.4984f,-1.58825f,0,0,0.71325f,-0.700909f}
+};
+
+enum OutdoorPvPZMWorldStates
+{
+    ZM_UI_TOWER_SLIDER_N_W = 2529,
+    ZM_UI_TOWER_SLIDER_POS_W = 2528,
+    ZM_UI_TOWER_SLIDER_DISPLAY_W = 2527,
+
+    ZM_UI_TOWER_SLIDER_N_E = 2535,
+    ZM_UI_TOWER_SLIDER_POS_E = 2534,
+    ZM_UI_TOWER_SLIDER_DISPLAY_E = 2533,
+
+    ZM_WORLDSTATE_UNK_1 = 2653,
+
+    ZM_UI_TOWER_EAST_N = 2560,
+    ZM_UI_TOWER_EAST_H = 2559,
+    ZM_UI_TOWER_EAST_A = 2558,
+    ZM_UI_TOWER_WEST_N = 2557,
+    ZM_UI_TOWER_WEST_H = 2556,
+    ZM_UI_TOWER_WEST_A = 2555,
+
+    ZM_MAP_TOWER_EAST_N = 2652,
+    ZM_MAP_TOWER_EAST_H = 2651,
+    ZM_MAP_TOWER_EAST_A = 2650,
+    ZM_MAP_GRAVEYARD_H = 2649,
+    ZM_MAP_GRAVEYARD_A = 2648,
+    ZM_MAP_GRAVEYARD_N = 2647,
+    ZM_MAP_TOWER_WEST_N = 2646,
+    ZM_MAP_TOWER_WEST_H = 2645,
+    ZM_MAP_TOWER_WEST_A = 2644,
+
+    ZM_MAP_HORDE_FLAG_READY = 2658,
+    ZM_MAP_HORDE_FLAG_NOT_READY = 2657,
+    ZM_MAP_ALLIANCE_FLAG_NOT_READY = 2656,
+    ZM_MAP_ALLIANCE_FLAG_READY = 2655
+};
+
+enum ZM_TowerStateMask{
+    ZM_TOWERSTATE_N = 1,
+    ZM_TOWERSTATE_A = 2,
+    ZM_TOWERSTATE_H = 4
+};
+
+class OutdoorPvPZM;
+class OPvPCapturePointZM_Beacon : public OPvPCapturePoint
+{
+friend class OutdoorPvPZM;
+public:
+    OPvPCapturePointZM_Beacon(OutdoorPvP * pvp, ZM_BeaconType type);
+    void ChangeState();
+    void SendChangePhase();
+    void FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count);
+    // used when player is activated/inactivated in the area
+    bool HandlePlayerEnter(Player * plr);
+    void HandlePlayerLeave(Player * plr);
+    void UpdateTowerState();
+protected:
+    ZM_BeaconType m_TowerType;
+    uint32 m_TowerState;
+};
+
+enum ZM_GraveYardState{
+    ZM_GRAVEYARD_N = 1,
+    ZM_GRAVEYARD_A = 2,
+    ZM_GRAVEYARD_H = 4
+};
+
+class OPvPCapturePointZM_GraveYard : public OPvPCapturePoint
+{
+friend class OutdoorPvPZM;
+public:
+    OPvPCapturePointZM_GraveYard(OutdoorPvP * pvp);
+    bool Update(uint32 diff);
+    void ChangeState() {}
+    void FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count);
+    void UpdateTowerState();
+    int32 HandleOpenGo(Player *plr, uint64 guid);
+    void SetBeaconState(uint32 controlling_team); // not good atm
+    bool HandleGossipOption(Player * plr, uint64 guid, uint32 gossipid);
+    bool HandleDropFlag(Player * plr, uint32 spellId);
+    bool CanTalkTo(Player * plr, Creature * c, GossipMenuItems gso);
+private:
+    uint32 m_GraveYardState;
+protected:
+    uint32 m_BothControllingFaction;
+    uint64 m_FlagCarrierGUID;
+};
+
+class OutdoorPvPZM : public OutdoorPvP
+{
+friend class OPvPCapturePointZM_Beacon;
+public:
+    OutdoorPvPZM();
+    bool SetupOutdoorPvP();
+    void HandlePlayerEnterZone(Player *plr, uint32 zone);
+    void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+    bool Update(uint32 diff);
+    void FillInitialWorldStates(WorldPacket&amp; data, uint32&amp; count);
+    void SendRemoveWorldStates(Player * plr);
+    void HandleKillImpl(Player * plr, Unit * killed);
+private:
+    OPvPCapturePointZM_GraveYard * m_GraveYard;
+    uint32 m_AllianceTowersControlled;
+    uint32 m_HordeTowersControlled;
+};
+
+// todo: flag carrier death/leave/mount/activitychange should give back the gossip options
+#endif
\ No newline at end of file
diff --git a/src/game/Player.cpp b/src/game/Player.cpp
index 0c50c56..f0815fa 100644
--- a/src/game/Player.cpp
+++ b/src/game/Player.cpp
@@ -52,6 +52,8 @@
 #include "BattleGround.h"
 #include "BattleGroundAV.h"
 #include "BattleGroundMgr.h"
+#include "OutdoorPvP.h"
+#include "OutdoorPvPMgr.h"
 #include "ArenaTeam.h"
 #include "Chat.h"
 #include "Database/DatabaseImpl.h"
@@ -1495,6 +1497,9 @@ void Player::SetDeathState(DeathState s)
         // remove uncontrolled pets
         RemoveMiniPet();
 
+        // update outdoor pvp zone
+        sOutdoorPvPMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
+
         // save value before aura remove in Unit::SetDeathState
         ressSpellId = GetUInt32Value(PLAYER_SELF_RES_SPELL);
 
@@ -4493,6 +4498,7 @@ void Player::ResurrectPlayer(float restore_percent, bool applySickness)
     uint32 newzone, newarea;
     GetZoneAndAreaId(newzone,newarea);
     UpdateZone(newzone,newarea);
+    sOutdoorPvPMgr.HandlePlayerResurrects(this, newzone);
 
     // update visibility of world around viewpoint
     m_camera.UpdateVisibilityForOwner();
@@ -6731,6 +6737,8 @@ void Player::UpdateZone(uint32 newZone, uint32 newArea)
 
     if(m_zoneUpdateId != newZone)
     {
+        sOutdoorPvPMgr.HandlePlayerLeaveZone(this, m_zoneUpdateId);
+        sOutdoorPvPMgr.HandlePlayerEnterZone(this, newZone);
         SendInitWorldStates(newZone, newArea);              // only if really enters to new zone, not just area change, works strange...
 
         if (sWorld.getConfig(CONFIG_BOOL_WEATHER))
@@ -6853,6 +6861,16 @@ void Player::CheckDuelDistance(time_t currTime)
     }
 }
 
+OutdoorPvP * Player::GetOutdoorPvP() const
+{
+    return sOutdoorPvPMgr.GetOutdoorPvPToZoneId(GetZoneId());
+}
+
+bool Player::IsOutdoorPvPActive()
+{
+    return isAlive() &amp;&amp; !HasInvisibilityAura() &amp;&amp; !HasStealthAura() &amp;&amp; (IsPvP() || sWorld.IsPvPRealm())  &amp;&amp; !HasMovementFlag(MOVEFLAG_FLYING) &amp;&amp; !IsTaxiFlying();
+}
+
 void Player::DuelComplete(DuelCompleteType type)
 {
     // duel not requested
@@ -8311,6 +8329,43 @@ static WorldStatePair EY_world_states[] =
     { 0x0,   0x0 }
 };
 
+static WorldStatePair EP_world_states[] =
+{
+    { 0x97a, 0x0 },     // 10 2426
+    { 0x917, 0x0 },     // 11 2327
+    { 0x918, 0x0 },     // 12 2328
+    { 0x97b, 0x32 },     // 13 2427
+    { 0x97c, 0x32 },     // 14 2428
+    { 0x933, 0x1 },     // 15 2355
+    { 0x946, 0x0 },     // 16 2374
+    { 0x947, 0x0 },     // 17 2375
+    { 0x948, 0x0 },     // 18 2376
+    { 0x949, 0x0 },     // 19 2377
+    { 0x94a, 0x0 },     // 20 2378
+    { 0x94b, 0x0 },     // 21 2379
+    { 0x932, 0x0 },     // 22 2354
+    { 0x934, 0x0 },     // 23 2356
+    { 0x935, 0x0 },     // 24 2357
+    { 0x936, 0x0 },     // 25 2358
+    { 0x937, 0x0 },     // 26 2359
+    { 0x938, 0x0 },     // 27 2360
+    { 0x939, 0x1 },     // 28 2361
+    { 0x930, 0x1 },     // 29 2352
+    { 0x93a, 0x0 },     // 30 2362
+    { 0x93b, 0x0 },     // 31 2363
+    { 0x93c, 0x0 },     // 32 2364
+    { 0x93d, 0x0 },     // 33 2365
+    { 0x944, 0x0 },     // 34 2372
+    { 0x945, 0x0 },     // 35 2373
+    { 0x931, 0x1 },     // 36 2353
+    { 0x93e, 0x0 },     // 37 2366
+    { 0x931, 0x1 },     // 38 2367 ??  grey horde not in dbc! send for consistency's sake, and to match field count
+    { 0x940, 0x0 },     // 39 2368
+    { 0x941, 0x0 },     // 7 2369
+    { 0x942, 0x0 },     // 8 2370
+    { 0x943, 0x0 }      // 9 2371
+};
+
 static WorldStatePair HP_world_states[] =                   // Hellfire Peninsula
 {
     { 0x9ba, 0x1 },                                         // 2490 10
@@ -8329,67 +8384,111 @@ static WorldStatePair HP_world_states[] =                   // Hellfire Peninsul
     { 0x0,   0x0 }
 };
 
+static WorldStatePair SI_world_states[] =                   // Hellfire Peninsula
+{
+                     // states are always shown
+    { 2313, 0x0 },   // 7 ally silityst gathered
+    { 2314, 0x0 },   // 8 horde silityst gathered
+    { 2317, 0x0 }   // 9 max silithyst
+};
+
+static WorldStatePair NA_world_states[] =
+{
+    { 2503, 0x0 },  // 10
+    { 2502, 0x0 },  // 11
+    { 2493, 0x0 },  // 12
+    { 2491, 0x0 },  // 13
+
+    { 2495, 0x0 },  // 14
+    { 2494, 0x0 },  // 15
+    { 2497, 0x0 },  // 16
+
+    { 2762, 0x0 },  // 17
+    { 2662, 0x0 },  // 18
+    { 2663, 0x0 },  // 19
+    { 2664, 0x0 },  // 20
+
+    { 2760, 0x0 },  // 21
+    { 2670, 0x0 },  // 22
+    { 2668, 0x0 },  // 23
+    { 2669, 0x0 },  // 24
+
+    { 2761, 0x0 },  // 25
+    { 2667, 0x0 },  // 26
+    { 2665, 0x0 },  // 27
+    { 2666, 0x0 },  // 28
+
+    { 2763, 0x0 },  // 29
+    { 2659, 0x0 },  // 30
+    { 2660, 0x0 },  // 31
+    { 2661, 0x0 },  // 32
+
+    { 2671, 0x0 },  // 33
+    { 2676, 0x0 },  // 34
+    { 2677, 0x0 },  // 35
+    { 2672, 0x0 },  // 36
+    { 2673, 0x0 }  // 37
+};
+
 static WorldStatePair TF_world_states[] =                   // Terokkar Forest
 {
-    { 0xa41, 0x0 },                                         // 2625 10
-    { 0xa40, 0x14 },                                        // 2624 11
-    { 0xa3f, 0x0 },                                         // 2623 12
-    { 0xa3e, 0x0 },                                         // 2622 13
-    { 0xa3d, 0x5 },                                         // 2621 14
-    { 0xa3c, 0x0 },                                         // 2620 15
-    { 0xa87, 0x0 },                                         // 2695 16
-    { 0xa86, 0x0 },                                         // 2694 17
-    { 0xa85, 0x0 },                                         // 2693 18
-    { 0xa84, 0x0 },                                         // 2692 19
-    { 0xa83, 0x0 },                                         // 2691 20
-    { 0xa82, 0x0 },                                         // 2690 21
-    { 0xa81, 0x0 },                                         // 2689 22
-    { 0xa80, 0x0 },                                         // 2688 23
-    { 0xa7e, 0x0 },                                         // 2686 24
-    { 0xa7d, 0x0 },                                         // 2685 25
-    { 0xa7c, 0x0 },                                         // 2684 26
-    { 0xa7b, 0x0 },                                         // 2683 27
-    { 0xa7a, 0x0 },                                         // 2682 28
-    { 0xa79, 0x0 },                                         // 2681 29
-    { 0x9d0, 0x5 },                                         // 2512 30
-    { 0x9ce, 0x0 },                                         // 2510 31
-    { 0x9cd, 0x0 },                                         // 2509 32
-    { 0x9cc, 0x0 },                                         // 2508 33
-    { 0xa88, 0x0 },                                         // 2696 34
-    { 0xad0, 0x0 },                                         // 2768 35
-    { 0xacf, 0x1 },                                         // 2767 36
-    { 0x0,   0x0 }
+    { 0xa41, 0x0 },                // 10 // 2625 capture bar pos
+    { 0xa40, 0x14 },               // 11 // 2624 capture bar neutral
+    { 0xa3f, 0x0 },                // 12 // 2623 show capture bar
+    { 0xa3e, 0x0 },                // 13 // 2622 horde towers controlled
+    { 0xa3d, 0x5 },                // 14 // 2621 ally towers controlled
+    { 0xa3c, 0x0 },                // 15 // 2620 show towers controlled
+    { 0xa88, 0x0 },                // 16 // 2696 SE Neu
+    { 0xa87, 0x0 },                // 17 // SE Horde
+    { 0xa86, 0x0 },                // 18 // SE Ally
+    { 0xa85, 0x0 },                // 19 //S Neu
+    { 0xa84, 0x0 },                // 20 S Horde
+    { 0xa83, 0x0 },                // 21 S Ally
+    { 0xa82, 0x0 },                // 22 NE Neu
+    { 0xa81, 0x0 },                // 23 NE Horde
+    { 0xa80, 0x0 },                // 24 NE Ally
+    { 0xa7e, 0x0 },                // 25 // 2686 N Neu
+    { 0xa7d, 0x0 },                // 26 N Horde
+    { 0xa7c, 0x0 },                // 27 N Ally
+    { 0xa7b, 0x0 },                // 28 NW Ally
+    { 0xa7a, 0x0 },                // 29 NW Horde
+    { 0xa79, 0x0 },                // 30 NW Neutral
+    { 0x9d0, 0x5 },                // 31 // 2512 locked time remaining seconds first digit
+    { 0x9ce, 0x0 },                // 32 // 2510 locked time remaining seconds second digit
+    { 0x9cd, 0x0 },                // 33 // 2509 locked time remaining minutes
+    { 0x9cc, 0x0 },                // 34 // 2508 neutral locked time show
+    { 0xad0, 0x0 },                // 35 // 2768 horde locked time show
+    { 0xacf, 0x1 }                // 36 // 2767 ally locked time show
 };
 
 static WorldStatePair ZM_world_states[] =                   // Zangarmarsh
 {
-    { 0x9e1, 0x0 },                                         // 2529 10
-    { 0x9e0, 0x0 },                                         // 2528 11
-    { 0x9df, 0x0 },                                         // 2527 12
-    { 0xa5d, 0x1 },                                         // 2526 13
-    { 0xa5c, 0x0 },                                         // 2525 14
-    { 0xa5b, 0x1 },                                         // 2524 15
-    { 0xa5a, 0x0 },                                         // 2523 16
-    { 0xa59, 0x1 },                                         // 2649 17
-    { 0xa58, 0x0 },                                         // 2648 18
-    { 0xa57, 0x0 },                                         // 2647 19
-    { 0xa56, 0x0 },                                         // 2646 20
-    { 0xa55, 0x1 },                                         // 2645 21
-    { 0xa54, 0x0 },                                         // 2644 22
-    { 0x9e7, 0x0 },                                         // 2535 23
-    { 0x9e6, 0x0 },                                         // 2534 24
-    { 0x9e5, 0x0 },                                         // 2533 25
-    { 0xa00, 0x0 },                                         // 2560 26
-    { 0x9ff, 0x1 },                                         // 2559 27
-    { 0x9fe, 0x0 },                                         // 2558 28
-    { 0x9fd, 0x0 },                                         // 2557 29
-    { 0x9fc, 0x1 },                                         // 2556 30
-    { 0x9fb, 0x0 },                                         // 2555 31
-    { 0xa62, 0x0 },                                         // 2658 32
-    { 0xa61, 0x1 },                                         // 2657 33
-    { 0xa60, 0x1 },                                         // 2656 34
-    { 0xa5f, 0x0 },                                         // 2655 35
-    { 0x0,   0x0 }
+    { 0x9e1, 0x0 },           // 10 //2529
+    { 0x9e0, 0x0 },           // 11
+    { 0x9df, 0x0 },           // 12
+    { 0xa5d, 0x1 },           // 13 //2653
+    { 0xa5c, 0x0 },           // 14 //2652 east beacon neutral
+    { 0xa5b, 0x1 },           // 15 horde
+    { 0xa5a, 0x0 },           // 16 ally
+    { 0xa59, 0x1 },           // 17 // 2649 Twin spire graveyard horde  12???
+    { 0xa58, 0x0 },           // 18 ally     14 ???
+    { 0xa57, 0x0 },           // 19 neutral  7???
+    { 0xa56, 0x0 },           // 20 // 2646 west beacon neutral
+    { 0xa55, 0x1 },           // 21 horde
+    { 0xa54, 0x0 },           // 22 ally
+    { 0x9e7, 0x0 },           // 23 // 2535
+    { 0x9e6, 0x0 },           // 24
+    { 0x9e5, 0x0 },           // 25
+    { 0xa00, 0x0 },           // 26 // 2560
+    { 0x9ff, 0x1 },           // 27
+    { 0x9fe, 0x0 },           // 28
+    { 0x9fd, 0x0 },           // 29
+    { 0x9fc, 0x1 },           // 30
+    { 0x9fb, 0x0 },           // 31
+    { 0xa62, 0x0 },           // 32 // 2658
+    { 0xa61, 0x1 },           // 33
+    { 0xa60, 0x1 },           // 34
+    { 0xa5f, 0x0 }           // 35
 };
 
 void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
@@ -8397,6 +8496,7 @@ void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
     // data depends on zoneid/mapid...
     BattleGround* bg = GetBattleGround();
     uint32 mapid = GetMapId();
+    OutdoorPvP * pvp = sOutdoorPvPMgr.GetOutdoorPvPToZoneId(zoneid);
 
     DEBUG_LOG("Sending SMSG_INIT_WORLD_STATES to Map:%u, Zone: %u", mapid, zoneid);
 
@@ -8435,6 +8535,26 @@ void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
         case 38:
         case 40:
         case 51:
+        case 139: // EPL
+            if(pvp &amp;&amp; pvp-&gt;GetTypeId() == OUTDOOR_PVP_EP)
+                pvp-&gt;FillInitialWorldStates(data, count);
+            else
+                FillInitialWorldState(data,count, EP_world_states);
+            break;
+        case 1377:                                          // Silithus
+            {
+                if(pvp &amp;&amp; pvp-&gt;GetTypeId() == OUTDOOR_PVP_SI)
+                    pvp-&gt;FillInitialWorldStates(data, count);
+                else
+                {
+                    FillInitialWorldState(data,count, SI_world_states);
+                }
+                FillInitialWorldState(data,count,2322, 0x0 ); // 10 sandworm N
+                FillInitialWorldState(data,count,2323, 0x0 ); // 11 sandworm S
+                FillInitialWorldState(data,count,2324, 0x0 ); // 12 sandworm SW
+                FillInitialWorldState(data,count,2325, 0x0 ); // 13 sandworm E
+            }
+            break;
         case 1519:
         case 1537:
         case 2257:
@@ -8464,13 +8584,20 @@ void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
                 FillInitialWorldState(data,count, EY_world_states);
             break;
         case 3483:                                          // Hellfire Peninsula
-            FillInitialWorldState(data,count, HP_world_states);
+            if(pvp &amp;&amp; pvp-&gt;GetTypeId() == OUTDOOR_PVP_HP)
+                FillInitialWorldState(data,count, HP_world_states);
             break;
         case 3519:                                          // Terokkar Forest
-            FillInitialWorldState(data,count, TF_world_states);
+            if(pvp &amp;&amp; pvp-&gt;GetTypeId() == OUTDOOR_PVP_TF)
+                FillInitialWorldState(data,count, TF_world_states);
             break;
         case 3521:                                          // Zangarmarsh
-            FillInitialWorldState(data,count, ZM_world_states);
+            if(pvp &amp;&amp; pvp-&gt;GetTypeId() == OUTDOOR_PVP_ZM)
+                FillInitialWorldState(data,count, ZM_world_states);
+            break;
+        case 3518:                                          // Haala
+            if(pvp &amp;&amp; pvp-&gt;GetTypeId() == OUTDOOR_PVP_NA)
+                FillInitialWorldState(data,count, NA_world_states);
             break;
         case 3698:                                          // Nagrand Arena
             if (bg &amp;&amp; bg-&gt;GetTypeID() == BATTLEGROUND_NA)
@@ -12797,6 +12924,10 @@ void Player::PrepareGossipMenu(WorldObject *pSource, uint32 menuId)
                 case GOSSIP_OPTION_TABARDDESIGNER:
                 case GOSSIP_OPTION_AUCTIONEER:
                     break;                                  // no checks
+                case GOSSIP_OPTION_OUTDOORPVP:
+                    if (!sOutdoorPvPMgr.CanTalkTo(this, pCreature, itr-&gt;second))
+                        hasMenuItem = false;
+                    break;
                 default:
                     sLog.outErrorDb("Creature entry %u have unknown gossip option %u for menu %u", pCreature-&gt;GetEntry(), itr-&gt;second.option_id, itr-&gt;second.menu_id);
                     hasMenuItem = false;
@@ -12974,6 +13105,9 @@ void Player::OnGossipSelect(WorldObject* pSource, uint32 gossipListId, uint32 me
 
             break;
         }
+        case GOSSIP_OPTION_OUTDOORPVP:
+            sOutdoorPvPMgr.HandleGossipOption(this, pSource-&gt;GetGUID(), gossipListId);
+            break;
         case GOSSIP_OPTION_SPIRITHEALER:
             if (isDead())
                 ((Creature*)pSource)-&gt;CastSpell(((Creature*)pSource),17251,true,NULL,NULL,GetGUID());
diff --git a/src/game/Player.h b/src/game/Player.h
index cfa3eff..f222ca4 100644
--- a/src/game/Player.h
+++ b/src/game/Player.h
@@ -55,6 +55,7 @@ class Vehicle;
 class InstanceSave;
 class Spell;
 class Item;
+class OutdoorPvP;
 
 typedef std::deque&lt;Mail*&gt; PlayerMails;
 
@@ -1993,6 +1994,7 @@ class MANGOS_DLL_SPEC Player : public Unit
 
         static uint32 TeamForRace(uint8 race);
         uint32 GetTeam() const { return m_team; }
+        TeamId GetTeamId() const { return m_team == ALLIANCE ? TEAM_ALLIANCE : TEAM_HORDE; }
         static uint32 getFactionForRace(uint8 race);
         void setFactionForRace(uint8 race);
 
@@ -2205,6 +2207,14 @@ class MANGOS_DLL_SPEC Player : public Unit
         bool CanCaptureTowerPoint();
 
         /*********************************************************/
+        /***               OUTDOOR PVP SYSTEM                  ***/
+        /*********************************************************/
+
+        OutdoorPvP * GetOutdoorPvP() const;
+        // returns true if the player is in active state for outdoor pvp objective capturing, false otherwise
+        bool IsOutdoorPvPActive();
+
+        /*********************************************************/
         /***                    REST SYSTEM                    ***/
         /*********************************************************/
 
diff --git a/src/game/SharedDefines.h b/src/game/SharedDefines.h
index e390eed..7299c19 100644
--- a/src/game/SharedDefines.h
+++ b/src/game/SharedDefines.h
@@ -519,6 +519,13 @@ enum Language
 
 #define LANGUAGES_COUNT   19
 
+enum TeamId
+{
+    TEAM_ALLIANCE = 0,
+    TEAM_HORDE,
+    TEAM_NEUTRAL,
+};
+
 enum Team
 {
     HORDE               = 67,
@@ -528,9 +535,11 @@ enum Team
     //TEAM_HORDE_FORCES        = 892,
     //TEAM_SANCTUARY           = 936,
     //TEAM_OUTLAND             = 980,
-    //TEAM_OTHER               = 0,                         // if ReputationListId &gt; 0 &amp;&amp; Flags != FACTION_FLAG_TEAM_HEADER
+    TEAM_OTHER               = 0,                         // if ReputationListId &gt; 0 &amp;&amp; Flags != FACTION_FLAG_TEAM_HEADER
 };
 
+const Team TeamId2Team[3] = {ALLIANCE, HORDE, TEAM_OTHER};
+
 enum SpellEffects
 {
     SPELL_EFFECT_NONE                      = 0,
diff --git a/src/game/SpellAuras.cpp b/src/game/SpellAuras.cpp
index c046869..ba9b05a 100644
--- a/src/game/SpellAuras.cpp
+++ b/src/game/SpellAuras.cpp
@@ -38,6 +38,7 @@
 #include "Creature.h"
 #include "Formulas.h"
 #include "BattleGround.h"
+#include "OutdoorPvPMgr.h"
 #include "CreatureAI.h"
 #include "ScriptCalls.h"
 #include "Util.h"
@@ -4483,6 +4484,8 @@ void Aura::HandleAuraModEffectImmunity(bool apply, bool /*Real*/)
     {
         if( BattleGround *bg = ((Player*)target)-&gt;GetBattleGround() )
             bg-&gt;EventPlayerDroppedFlag(((Player*)target));
+        else
+            sOutdoorPvPMgr.HandleDropFlag((Player*)target,GetSpellProto()-&gt;Id);
     }
 
     target-&gt;ApplySpellImmune(GetId(), IMMUNITY_EFFECT, m_modifier.m_miscvalue, apply);
diff --git a/src/game/SpellEffects.cpp b/src/game/SpellEffects.cpp
index c7d9c24..58713aa 100644
--- a/src/game/SpellEffects.cpp
+++ b/src/game/SpellEffects.cpp
@@ -46,6 +46,8 @@
 #include "BattleGround.h"
 #include "BattleGroundEY.h"
 #include "BattleGroundWS.h"
+#include "OutdoorPvPMgr.h"
+#include "VMapFactory.h"
 #include "Language.h"
 #include "SocialMgr.h"
 #include "VMapFactory.h"
@@ -3862,6 +3864,12 @@ void Spell::EffectOpenLock(SpellEffectIndex eff_idx)
                 return;
             }
         }
+        // TODO: Add script for spell 41920 - Filling, becouse server it freze when use this spell
+        // handle outdoor pvp object opening, return true if go was registered for handling
+        // these objects must have been spawned by outdoorpvp!
+        else if(gameObjTarget-&gt;GetGOInfo()-&gt;type == GAMEOBJECT_TYPE_GOOBER &amp;&amp; sOutdoorPvPMgr.HandleOpenGo(player, gameObjTarget-&gt;GetGUID()))
+            return;
+
         lockId = goInfo-&gt;GetLockId();
         guid = gameObjTarget-&gt;GetGUID();
     }
diff --git a/src/game/Unit.cpp b/src/game/Unit.cpp
index 5f6bc7a..e4f29f1 100644
--- a/src/game/Unit.cpp
+++ b/src/game/Unit.cpp
@@ -41,6 +41,7 @@
 #include "Totem.h"
 #include "BattleGround.h"
 #include "InstanceData.h"
+#include "OutdoorPvP.h"
 #include "InstanceSaveMgr.h"
 #include "GridNotifiersImpl.h"
 #include "CellImpl.h"
@@ -886,6 +887,10 @@ uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDa
             he-&gt;DuelComplete(DUEL_INTERUPTED);
         }
 
+        if (player_tap &amp;&amp; this != pVictim)
+            if (OutdoorPvP * pvp = player_tap-&gt;GetOutdoorPvP())
+                pvp-&gt;HandleKill(player_tap, pVictim);
+
         // battleground things (do this at the end, so the death state flag will be properly set to handle in the bg-&gt;handlekill)
         if(pVictim-&gt;GetTypeId() == TYPEID_PLAYER &amp;&amp; ((Player*)pVictim)-&gt;InBattleGround())
         {
diff --git a/src/game/Unit.h b/src/game/Unit.h
index 9c36a83..3008193 100644
--- a/src/game/Unit.h
+++ b/src/game/Unit.h
@@ -614,7 +614,8 @@ enum NPCFlags
     UNIT_NPC_FLAG_STABLEMASTER          = 0x00400000,       // 100%
     UNIT_NPC_FLAG_GUILD_BANKER          = 0x00800000,       // cause client to send 997 opcode
     UNIT_NPC_FLAG_SPELLCLICK            = 0x01000000,       // cause client to send 1015 opcode (spell click), dynamic, set at loading and don't must be set in DB
-    UNIT_NPC_FLAG_GUARD                 = 0x10000000        // custom flag for guards
+    UNIT_NPC_FLAG_GUARD                 = 0x10000000,       // custom flag for guards
+    UNIT_NPC_FLAG_OUTDOORPVP            = 0x20000000        // custom flag for outdoor pvp creatures
 };
 
 // used in most movement packets (send and received)
diff --git a/src/game/World.cpp b/src/game/World.cpp
index f04c397..8eb911f 100644
--- a/src/game/World.cpp
+++ b/src/game/World.cpp
@@ -48,6 +48,8 @@
 #include "CreatureAIRegistry.h"
 #include "Policies/SingletonImp.h"
 #include "BattleGroundMgr.h"
+#include "Language.h"
+#include "OutdoorPvPMgr.h"
 #include "TemporarySummon.h"
 #include "VMapFactory.h"
 #include "GameEventMgr.h"
@@ -1303,6 +1305,10 @@ void World::SetInitialWorldSettings()
     sBattleGroundMgr.CreateInitialBattleGrounds();
     sBattleGroundMgr.InitAutomaticArenaPointDistribution();
 
+    ///- Initialize outdoor pvp
+    sLog.outString( "Starting Outdoor PvP System" );
+    sOutdoorPvPMgr.InitOutdoorPvP();
+
     //Not sure if this can be moved up in the sequence (with static data loading) as it uses MapManager
     sLog.outString( "Loading Transports..." );
     sMapMgr.LoadTransports();
@@ -1469,6 +1475,7 @@ void World::Update(uint32 diff)
         sMapMgr.Update(diff);                // As interval = 0
 
         sBattleGroundMgr.Update(diff);
+        sOutdoorPvPMgr.Update(diff);
     }
 
     ///- Delete all characters which have been deleted X days before
diff --git a/src/game/ZoneScript.h b/src/game/ZoneScript.h
new file mode 100644
index 0000000..43aeef2
--- /dev/null
+++ b/src/game/ZoneScript.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2008-2010 MaNGOS &lt;http://www.MaNGOScore.org/&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef ZONE_SCRIPT_H_
+#define ZONE_SCRIPT_H_
+
+#include "Common.h"
+#include "Creature.h"
+
+//struct CreatureData;
+class Creature;
+class GameObject;
+
+class ZoneScript
+{
+    public:
+        explicit ZoneScript() {}
+
+        virtual uint32 GetCreatureEntry(uint32 guidlow, const CreatureData *data) { return data-&gt;id; }
+        virtual uint32 GetGameObjectEntry(uint32 guidlow, uint32 entry) { return entry; }
+
+        virtual void OnCreatureCreate(Creature *, bool add) {}
+        virtual void OnGameObjectCreate(GameObject *go, bool add) {}
+
+        //All-purpose data storage 64 bit
+        virtual uint64 GetData64(uint32 /*DataId*/) { return 0; }
+        virtual void SetData64(uint32 /*DataId*/, uint64 /*Value*/) {}
+
+        //All-purpose data storage 32 bit
+        virtual uint32 GetData(uint32 /*DataId*/) { return 0; }
+        virtual void SetData(uint32 /*DataId*/, uint32 /*Value*/) {}
+
+        virtual void ProcessEvent(GameObject *obj, uint32 eventId) {}
+};
+
+#endif
\ No newline at end of file
diff --git a/win/VC90/game.vcproj b/win/VC90/game.vcproj
index f279ab3..d4f9917 100644
--- a/win/VC90/game.vcproj
+++ b/win/VC90/game.vcproj
@@ -867,6 +867,82 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvP.cpp"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvP.h"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvPEP.cpp"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvPEP.h"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvPGH.cpp"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvPGH.h"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvPHP.cpp"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvPHP.h"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvPImpl.h"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvPMgr.cpp"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvPMgr.h"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvPNA.cpp"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvPNA.h"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvPSI.cpp"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvPSI.h"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvPTF.cpp"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvPTF.h"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvPZM.cpp"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\OutdoorPvPZM.h"
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath="..\..\src\game\Path.h"
 				&gt;
 			&lt;/File&gt;
@@ -1014,6 +1090,10 @@
 				RelativePath="..\..\src\game\World.h"
 				&gt;
 			&lt;/File&gt;
+			&lt;File
+				RelativePath="..\..\src\game\ZoneScript.h"
+				&gt;
+			&lt;/File&gt;
 		&lt;/Filter&gt;
 		&lt;Filter
 			Name="Motion generators"
-- 
1.7.0.2

</pre></body></html>