diff --git a/Makefile.am b/Makefile.am
index 87c550f..4606ed7 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -342,6 +342,9 @@ scripts/northrend/icecrown_citadel/frozen_halls/halls_of_reflection/boss_marwyn.
 scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/boss_forgemaster_gafrost.cpp \
 scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/boss_krick_and_ick.cpp \
 scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/boss_scourgelord_tyrannus.cpp \
+scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/instance_pit_of_saron.cpp \
+scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/pit_of_saron.cpp \
+scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/pit_of_saron.h \
 scripts/northrend/icecrown_citadel/frozen_halls/forge_of_souls/boss_bronjahm.cpp \
 scripts/northrend/icecrown_citadel/frozen_halls/forge_of_souls/boss_devourer_of_souls.cpp \
 scripts/northrend/icecrown_citadel/frozen_halls/forge_of_souls/forge_of_souls.cpp \
diff --git a/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/boss_forgemaster_gafrost.cpp b/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/boss_forgemaster_gafrost.cpp
index 73fbae7..a17ae49 100644
--- a/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/boss_forgemaster_gafrost.cpp
+++ b/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/boss_forgemaster_gafrost.cpp
@@ -1,18 +1,18 @@
 /* Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 /* ScriptData
 SDName: boss_forgemaster_gafrost
@@ -22,3 +22,419 @@ SDCategory: Pit of Saron
 EndScriptData */
 
 #include "precompiled.h"
+#include "pit_of_saron.h"
+
+enum
+{
+
+    SAY_AGGRO           = -1610051,
+    SAY_SLAY1           = -1610052,
+    SAY_SLAY2           = -1610054,
+    SAY_PHASE2          = -1610055,
+    SAY_PHASE3          = -1610056,
+    EMOTE_SARONITE      = -1610053,
+    SAY_DEATH           = -1610057,
+
+    SPELL_PERMAFROST                 = 70326,
+    SPELL_PERMAFROST_TRIG            = 68786,
+    SPELL_THROW_SARONITE             = 68788,
+    SPELL_THUNDERING_STOMP           = 68771,
+    SPELL_CHILLING_WAVE              = 68778,
+    SPELL_CHILLING_WAVE_H            = 70333, 
+    SPELL_DEEP_FREEZE                = 70381,
+    SPELL_DEEP_FREEZE_H              = 72930,
+    SPELL_FORGE_MACE                 = 68785,
+    SPELL_FORGE_MACE_H               = 70335,
+    SPELL_FORGE_BLADE                = 68774,
+    SPELL_FORGE_BLADE_H              = 70334,
+
+    EQUIP_ID_SWORD  = 49345,
+    EQUIP_ID_MACE   = 49344,
+
+    SAY_FREE_SLAVE                  = -1610059,
+    SAY_TYRANNUS_OUTRO              = -1610058,
+
+    ACHIEV_DOESNT_GO_TO_ELEVEN      = 4524,
+};
+
+//Positional defines 
+struct LocationsXY
+{
+    float x, y, z, o;
+    uint32 id;
+};
+static LocationsXY SummonLoc[]=
+{
+    {719.812f, -167.183f, 526.721f,},
+    {698.703f, -165.497f, 527.464f,},
+    {671.455f, -167.968f, 526.741f,},
+};
+
+static LocationsXY MoveLoc[]=
+{
+    {677.445f, -186.521f, 526.702f},
+    {708.190f, -194.619f, 526.805f},
+    {687.257f, -193.644f, 526.717f}, 
+};
+
+#define HOME_X                      712.927f
+#define HOME_Y                      -231.605f
+
+struct MANGOS_DLL_DECL npc_martin_gorkunAI: public ScriptedAI
+{
+    npc_martin_gorkunAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+
+    uint32 m_uiSpeech_Timer;
+    uint8 m_uiOutro_Phase;
+    bool m_bIsOutro;
+    uint32 creatureEntry;
+
+    uint64 m_uiTyrannusGuid;
+
+    void Reset()
+    {
+        m_uiOutro_Phase     = 0;
+        m_uiSpeech_Timer    = 1000;
+        m_bIsOutro          = true;
+        m_uiTyrannusGuid    = 0;
+        creatureEntry = m_creature->GetEntry();
+    }
+
+    void SummonHordeSlaves()
+    {
+        for (uint8 i = 0; i < 5; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_SLAVE_HORDE_1, SummonLoc[0].x + urand(0, 20), SummonLoc[0].y + urand(0, 20), SummonLoc[0].z, SummonLoc[0].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[0].x + urand(0, 20), MoveLoc[0].y + urand(0, 20), MoveLoc[0].z);
+        }
+
+        for (uint8 i = 5; i < 10; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_SLAVE_HORDE_2, SummonLoc[1].x + urand(0, 10), SummonLoc[1].y - urand(0, 10), SummonLoc[1].z, SummonLoc[1].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[2].x + urand(0, 20), MoveLoc[2].y - urand(0, 20), MoveLoc[2].z);
+        }
+
+        for (uint8 i = 10; i < 15; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_SLAVE_HORDE_3, SummonLoc[2].x - urand(0, 20), SummonLoc[2].y - urand(0, 20), SummonLoc[2].z, SummonLoc[2].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[1].x - urand(0, 20), MoveLoc[1].y - urand(0, 20), MoveLoc[1].z);
+        }
+    }
+
+    void SummonAlySlaves()
+    {
+        for (uint8 i = 0; i < 5; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_SLAVE_ALY_1, SummonLoc[0].x + urand(0, 20), SummonLoc[0].y + urand(0, 20), SummonLoc[0].z, SummonLoc[0].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[0].x + urand(0, 20), MoveLoc[0].y + urand(0, 20), MoveLoc[0].z);
+        }
+
+        for (uint8 i = 5; i < 10; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_SLAVE_ALY_2, SummonLoc[1].x + urand(0, 10), SummonLoc[1].y - urand(0, 10), SummonLoc[1].z, SummonLoc[1].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[2].x + urand(0, 20), MoveLoc[2].y - urand(0, 20), MoveLoc[2].z);
+        }
+
+        for (uint8 i = 10; i < 15; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_SLAVE_ALY_3, SummonLoc[2].x - urand(0, 20), SummonLoc[2].y - urand(0, 20), SummonLoc[2].z, SummonLoc[2].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[1].x - urand(0, 20), MoveLoc[1].y - urand(0, 20), MoveLoc[1].z);
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_bIsOutro)
+        {
+            if(m_uiSpeech_Timer < uiDiff)
+            {
+                switch(m_uiOutro_Phase)
+                {
+                case 0:
+                    switch (creatureEntry)
+                    {
+                    case NPC_MARTIN_VICTUS_SLAVE:
+                        SummonAlySlaves();
+                        break;
+                    case NPC_GORKUN_IRONSKULL_SLAVE:
+                        SummonHordeSlaves();
+                        break;
+                    }
+                    ++m_uiOutro_Phase;
+                    m_uiSpeech_Timer = 2000;
+                    break;
+                case 1:
+                    switch (creatureEntry)
+                    {
+                    case NPC_MARTIN_VICTUS_SLAVE:
+                        DoScriptText(SAY_FREE_SLAVE,m_creature);
+                        break;
+                    case NPC_GORKUN_IRONSKULL_SLAVE:
+                        DoScriptText(SAY_FREE_SLAVE,m_creature);
+                        break;
+                    }
+                    ++m_uiOutro_Phase;
+                    m_uiSpeech_Timer = 10000;
+                    break;
+                case 2:
+                    if(Creature* pTyrannus = m_creature->SummonCreature(NPC_TYRANNUS_INTRO, 695.46f, -156.31f, 546.061f, 4.77f, TEMPSUMMON_TIMED_DESPAWN, 10000))
+                    {
+                        pTyrannus->GetMotionMaster()->MoveIdle();
+                        pTyrannus->SetUInt64Value(UNIT_FIELD_TARGET, m_creature->GetGUID());
+                        pTyrannus->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        pTyrannus->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                        pTyrannus->SetUInt32Value(UNIT_FIELD_BYTES_0, 50331648);
+                        pTyrannus->SetUInt32Value(UNIT_FIELD_BYTES_1, 50331648);
+                        pTyrannus->GetMotionMaster()->MoveIdle();
+                        pTyrannus->GetMap()->CreatureRelocation(pTyrannus, 695.46f, -156.31f, 546.061f, 4.77f);
+                        pTyrannus->SendMonsterMove(695.46f, -156.31f, 546.061f, SPLINETYPE_NORMAL, pTyrannus->GetSplineFlags(), 1);
+                        m_uiTyrannusGuid = pTyrannus->GetGUID();
+                    }
+                    ++m_uiOutro_Phase;
+                    m_uiSpeech_Timer = 3000;
+                    break;
+                case 3:
+                    if(Creature* pTyrannus = m_pInstance->instance->GetCreature(m_uiTyrannusGuid))
+                        DoScriptText(SAY_TYRANNUS_OUTRO, pTyrannus);
+                    m_bIsOutro = false;
+                    ++m_uiOutro_Phase;
+                    m_uiSpeech_Timer = 10000;
+                    break;
+
+                default:
+                    m_uiSpeech_Timer = 100000;
+                }
+            }else m_uiSpeech_Timer -= uiDiff;
+        }
+    }
+};
+
+struct MANGOS_DLL_DECL boss_GarfrostAI : public ScriptedAI
+{
+    boss_GarfrostAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    bool phase2;
+    bool phase3;
+    uint32 m_uiThrowSaroniteTimer;
+    uint32 m_uiThunderingStompTimer;
+    uint32 m_uiDeepFreezeTimer;
+    uint32 m_uiChillingWaveTimer;
+
+    uint32 TeamInInstance;
+
+    uint32 CheckAura;
+    bool hasMoreThanTen;
+
+    void Reset()
+    {
+        m_uiThrowSaroniteTimer      = 45000;
+        m_uiThunderingStompTimer    = 40000;
+        m_uiDeepFreezeTimer         = 30000;
+        m_uiChillingWaveTimer       = 25000;
+
+        phase2 = false;
+        phase3 = false;
+
+        TeamInInstance = GetFaction();
+
+        CheckAura           = 1000;
+        hasMoreThanTen      = false;
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_GARFROST, NOT_STARTED);
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_GARFROST, IN_PROGRESS);
+
+        DoScriptText(SAY_AGGRO, m_creature);
+
+        DoCast(m_creature, SPELL_PERMAFROST);
+    }
+
+    void DamageTaken(Unit* pDoneBy, uint32& uiDamage)
+    {
+        if (m_creature->GetHealthPercent() < 66.0f && !phase2)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_FORGE_BLADE : SPELL_FORGE_BLADE_H);
+            DoScriptText(SAY_PHASE2, m_creature);
+            SetEquipmentSlots(false, EQUIP_ID_SWORD, -1, -1);
+            m_creature->SetByteValue(UNIT_FIELD_BYTES_2, 0, SHEATH_STATE_MELEE);
+            m_uiChillingWaveTimer = 10000;
+            phase2 = true;
+        }
+
+        if (m_creature->GetHealthPercent() < 33.0f && !phase3)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_FORGE_MACE : SPELL_FORGE_MACE_H);
+            DoScriptText(SAY_PHASE3, m_creature);
+            SetEquipmentSlots(false, EQUIP_ID_MACE, -1, -1);
+            m_creature->SetByteValue(UNIT_FIELD_BYTES_2, 0, SHEATH_STATE_MELEE);
+            m_uiDeepFreezeTimer = 10000;
+            phase3 = true;
+        }
+    }
+
+    uint32 GetFaction()
+    {
+        uint32 faction = 0;
+        Map *map = m_creature->GetMap();
+        if (map->IsDungeon())
+        {
+            Map::PlayerList const &PlayerList = map->GetPlayers();
+
+            if (!PlayerList.isEmpty())
+            {
+                if (Player* pPlayer = PlayerList.begin()->getSource())
+                    faction = pPlayer->GetTeam();
+            }
+        }
+        return faction;
+    }
+
+    void KilledUnit(Unit *victim)
+    {
+        if(irand(0,1))
+            DoScriptText(SAY_SLAY1, m_creature);
+        else
+            DoScriptText(SAY_SLAY2, m_creature);
+    }
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (CheckAura < uiDiff && !hasMoreThanTen)
+        {
+            ThreatList const& tList = m_creature->getThreatManager().getThreatList();
+            for (ThreatList::const_iterator iter = tList.begin();iter != tList.end(); ++iter)
+            {
+                Unit *pTarget = Unit::GetUnit(*m_creature, (*iter)->getUnitGuid());
+                if (!pTarget || pTarget->GetTypeId() != TYPEID_PLAYER)
+                    continue;
+
+                Aura *AuraFrost = pTarget->GetAura(SPELL_PERMAFROST_TRIG, EFFECT_INDEX_0);
+                if (AuraFrost && AuraFrost->GetStackAmount() > 10)
+                {
+                    hasMoreThanTen = true;
+                    break;
+                }
+            }
+            CheckAura = 1000;
+        } else CheckAura -= uiDiff;
+
+        if (m_uiThrowSaroniteTimer < uiDiff)
+        {
+            DoScriptText(EMOTE_SARONITE, m_creature);
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, SPELL_THROW_SARONITE);
+            m_uiThrowSaroniteTimer = 35000;
+        }
+        else
+            m_uiThrowSaroniteTimer -= uiDiff;
+
+        if (m_uiThunderingStompTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, SPELL_THUNDERING_STOMP);
+            m_uiThunderingStompTimer = 20000;
+        }
+        else
+            m_uiThunderingStompTimer -= uiDiff;
+
+        if (m_uiDeepFreezeTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_DEEP_FREEZE : SPELL_DEEP_FREEZE_H);
+            m_uiDeepFreezeTimer = 35000;
+        }
+        else
+            m_uiDeepFreezeTimer -= uiDiff;
+
+        if (m_uiChillingWaveTimer < uiDiff)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_CHILLING_WAVE : SPELL_CHILLING_WAVE_H);
+            m_uiChillingWaveTimer = 40000;
+        }
+        else
+            m_uiChillingWaveTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+
+        if (m_creature->GetDistance2d(HOME_X, HOME_Y) > 80)
+            EnterEvadeMode();
+    }
+    void JustDied(Unit* killer)  
+    {
+        DoScriptText(SAY_DEATH, m_creature);
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_GARFROST, DONE);
+
+            /* fix this!!! -> invalid aura id
+            if(!m_bIsRegularMode && !hasMoreThanTen)
+                m_pInstance->DoCompleteAchievement(ACHIEV_DOESNT_GO_TO_ELEVEN);*/
+        }
+
+        if(TeamInInstance == ALLIANCE)
+        {
+            Creature *pMartin = m_creature->SummonCreature(NPC_MARTIN_VICTUS_SLAVE, 695.46f, -156.31f, 528.061f, 4.77f, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pMartin)
+                pMartin->GetMotionMaster()->MovePoint(0, m_creature->GetPositionX() + 15, m_creature->GetPositionY() - 5, m_creature->GetPositionZ());
+        }
+
+        if(TeamInInstance == HORDE)
+        {
+            Creature *pGorkun = m_creature->SummonCreature(NPC_GORKUN_IRONSKULL_SLAVE, 695.46f, -156.31f, 528.061f, 4.77f, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pGorkun)
+                pGorkun->GetMotionMaster()->MovePoint(0, m_creature->GetPositionX() + 15, m_creature->GetPositionY() - 5, m_creature->GetPositionZ());
+        }
+    }
+};
+
+CreatureAI* GetAI_boss_Garfrost(Creature* pCreature)
+{
+    return new boss_GarfrostAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_martin_gorkun(Creature* pCreature)
+{
+    return new npc_martin_gorkunAI (pCreature);
+}
+
+void AddSC_boss_Garfrost()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name="boss_Garfrost";
+    newscript->GetAI = &GetAI_boss_Garfrost;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="npc_martin_gorkun";
+    newscript->GetAI = &GetAI_npc_martin_gorkun;
+    newscript->RegisterSelf();
+}
\ No newline at end of file
diff --git a/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/boss_krick_and_ick.cpp b/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/boss_krick_and_ick.cpp
index 7be678b..9e8944a 100644
--- a/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/boss_krick_and_ick.cpp
+++ b/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/boss_krick_and_ick.cpp
@@ -1,18 +1,18 @@
 /* Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 /* ScriptData
 SDName: boss_krick_and_ick
@@ -22,3 +22,504 @@ SDCategory: Pit of Saron
 EndScriptData */
 
 #include "precompiled.h"
+#include "pit_of_saron.h"
+
+enum
+{
+    SPELL_PURSUED                 = 68987,
+    SPELL_CONFUSION               = 69029,
+    SPELL_EXPLOSIVE_BARRAGE       = 69263,
+    NPC_EXPLOSIVE_ORB             = 36610,
+    SPELL_EXPLOSIVE_BARRAGE_ORB   = 69019,
+    SPELL_EXPLOSIVE_BARRAGE_ORB_H = 70433,
+    SPELL_MIGHTY_KICK             = 69021,
+    SPELL_POISON_NOVA             = 68989,
+    SPELL_POISON_NOVA_H           = 70434,
+    SPELL_SHADOW_BOLT             = 69028,
+    SPELL_TOXIC_WASTE             = 69024,
+    SPELL_TOXIC_WASTE_H           = 70436,
+
+    SAY_KRICK_CHASE_1             = -1610064,
+    SAY_KRICK_CHASE_2             = -1610065,
+    SAY_KRICK_CHASE_3             = -1610066,
+    SAY_ICK_CHASE                 = -1609334, // invalid
+    SAY_KRICK_POISON              = -1610061,
+    SAY_ICK_POISON                = -1609336, // invalid
+    SAY_KRICK_BARRAGE             = -1610062,
+    SAY_KRICK_BARRAGE_EMOTE       = -1610063,
+    SAY_AGGRO                     = -1610060,
+    SAY_SLAY1                     = -1610067,
+    SAY_SLAY2                     = -1610068,
+
+    SAY_OUTRO1              = -1610069,
+    SAY_OUTRO2_ALY          = -1610070,
+    SAY_OUTRO2_HORDE        = -1610071,
+    SAY_OUTRO3              = -1610072,
+    SAY_OUTRO4_ALY          = -1610073,
+    SAY_OUTRO4_HORDE        = -1610074,
+    SAY_OUTRO5              = -1610075,
+    SAY_OUTRO6_TYRANNUS     = -1610076,
+    SAY_OUTRO7              = -1610077,
+    SAY_OUTRO8_TYRANNUS     = -1610078,
+    SAY_OUTRO9_ALY          = -1610079,
+    SAY_OUTRO9_HORDE        = -1610080,
+};
+
+const float KrickPos[4] = {856.237f, 120.484f, 510.01f, 3.48f};
+
+#define HOME_X                      852.322f
+#define HOME_Y                      127.969f
+
+struct MANGOS_DLL_DECL boss_IckAI : public ScriptedAI
+{
+    boss_IckAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    Creature* pKrick;
+    Creature* pIck;
+
+    uint32 m_uiPoisonNovaTimer;
+    uint32 m_uiPursueTimer;
+    uint32 m_uiMightKickTimer;
+
+    void Reset()
+    {
+        m_uiPoisonNovaTimer = 30000;
+        m_uiPursueTimer     = 10000;
+        m_uiMightKickTimer  = 20000;
+    }
+
+    void KilledUnit(Unit *victim)
+    {
+        if(pKrick)
+        {
+            if(irand(0,1))
+                DoScriptText(SAY_SLAY1, pKrick);
+            else
+                DoScriptText(SAY_SLAY2, pKrick);
+        }
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_KRICK_AND_ICK, IN_PROGRESS);
+
+        if(!GetClosestCreatureWithEntry(m_creature, NPC_KRICK, 50.0f))
+        {
+            pKrick = m_creature->SummonCreature(NPC_KRICK, KrickPos[0], KrickPos[1], KrickPos[2], KrickPos[3], TEMPSUMMON_CORPSE_TIMED_DESPAWN, 60000);
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                pKrick->AddThreat(pTarget, 0.0f);
+            DoScriptText(SAY_AGGRO, pKrick);
+        }
+        else
+        {
+            pKrick = GetClosestCreatureWithEntry(m_creature, NPC_KRICK, 80.0f);
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                pKrick->AddThreat(pTarget, 0.0f);
+            DoScriptText(SAY_AGGRO, pKrick);
+        }
+    }
+
+    // TODO: effect 0 and effect 1 may be on different target
+    void SpellHitTarget(Unit *pTarget, const SpellEntry *spell)
+    {
+        if (spell->Id == SPELL_PURSUED)
+            AttackStart(pTarget);
+    }
+
+    void JustDied(Unit *victim)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_KRICK_AND_ICK, DONE);
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiPoisonNovaTimer < uiDiff)
+        {
+            if (pKrick)
+                DoScriptText(SAY_KRICK_POISON, pKrick);
+            //DoScriptText(SAY_ICK_POISON, m_creature);
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_POISON_NOVA : SPELL_POISON_NOVA_H);
+            m_uiPoisonNovaTimer = 30000;
+        }
+        else
+            m_uiPoisonNovaTimer -= uiDiff;
+
+        if (m_uiPursueTimer < uiDiff)
+        {
+            if (pKrick)
+            {
+                switch (urand(0, 2))
+                {
+                case 0: 
+                    DoScriptText(SAY_KRICK_CHASE_1, pKrick);
+                    break;
+                case 1: 
+                    DoScriptText(SAY_KRICK_CHASE_2, pKrick);
+                    break;
+                case 2: 
+                    DoScriptText(SAY_KRICK_CHASE_3, pKrick);
+                    break;
+                }
+            }
+            //DoScriptText(SAY_ICK_CHASE, m_creature);
+
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, SPELL_PURSUED);
+            DoCast(m_creature, SPELL_CONFUSION);
+            m_uiPursueTimer = 13000;
+        }
+        else
+            m_uiPursueTimer -= uiDiff;
+
+        if (m_uiMightKickTimer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_MIGHTY_KICK);
+            m_uiMightKickTimer = 25000;
+        }
+        else
+            m_uiMightKickTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+
+        if (m_creature->GetDistance2d(HOME_X, HOME_Y) > 80)
+            EnterEvadeMode();
+    }
+};
+
+struct MANGOS_DLL_DECL boss_KrickAI : public ScriptedAI
+{
+    boss_KrickAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiToxicWasteTimer;
+    uint32 m_uiShadowboltTimer;
+    uint32 m_uiExplosivBarrageTimer;
+
+    uint32 m_uiSummonOrbsTimer;
+    uint32 m_uiSummonOverTimer;
+    bool m_bIsSummoning;
+
+    bool m_bIsOutro;
+    uint32 OutroTimer;
+    uint32 Step;
+
+    uint32 TeamInInstance;
+
+    uint64 m_uiJainaGuid;
+    uint64 m_uiSylvanasGuid;
+    uint64 m_uiTyrannusGuid;
+
+    void Reset()
+    {
+        m_uiJainaGuid       = 0;
+        m_uiSylvanasGuid    = 0;
+        m_uiTyrannusGuid    = 0;
+
+        m_uiToxicWasteTimer      = 5000;
+        m_uiShadowboltTimer      = 15000;
+        m_uiExplosivBarrageTimer = 35000;
+        m_uiSummonOrbsTimer     = 600000;
+        m_uiSummonOverTimer     = 600000;
+        m_bIsSummoning          = false;
+
+        TeamInInstance = GetFaction();
+
+        m_bIsOutro = false;
+        OutroTimer = 10000;
+        Step       = 1;
+    }
+
+    uint32 GetFaction()
+    {
+        uint32 faction = 0;
+        Map *map = m_creature->GetMap();
+        if (map->IsDungeon())
+        {
+            Map::PlayerList const &PlayerList = map->GetPlayers();
+
+            if (!PlayerList.isEmpty())
+            {
+                if (Player* pPlayer = PlayerList.begin()->getSource())
+                    faction = pPlayer->GetTeam();
+            }
+        }
+        return faction;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if(!m_bIsOutro)
+        {
+            if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+                return;
+
+            if (m_uiToxicWasteTimer < uiDiff)
+            {
+                DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_TOXIC_WASTE : SPELL_TOXIC_WASTE_H);
+                m_uiToxicWasteTimer = 10000;
+            }
+            else
+                m_uiToxicWasteTimer -= uiDiff;
+
+            if (m_uiShadowboltTimer < uiDiff)
+            {
+                DoCast(m_creature->getVictim(), SPELL_SHADOW_BOLT);
+                m_uiShadowboltTimer = 15000;
+            }
+            else
+                m_uiShadowboltTimer -= uiDiff;
+
+            if (m_uiExplosivBarrageTimer < uiDiff)
+            {
+                DoScriptText(SAY_KRICK_BARRAGE, m_creature);
+                DoScriptText(SAY_KRICK_BARRAGE_EMOTE, m_creature);
+
+                DoCast(m_creature, SPELL_EXPLOSIVE_BARRAGE);
+                m_uiSummonOrbsTimer = 3000;
+                m_uiSummonOverTimer = 18000;
+                m_bIsSummoning = true;
+                m_uiExplosivBarrageTimer = 45000;
+            }
+            else
+                m_uiExplosivBarrageTimer -= uiDiff;
+
+            if (m_uiSummonOrbsTimer < uiDiff && m_bIsSummoning)
+            {
+                for(uint8 i = 0; i < 4; i++)
+                {
+                    if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                        m_creature->SummonCreature(NPC_EXPLOSIVE_ORB, pTarget->GetPositionX() + urand(0, 3), pTarget->GetPositionY() + urand(0, 3), pTarget->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 4000);
+                }
+                m_uiSummonOrbsTimer = 1500;
+            }
+            else
+                m_uiSummonOrbsTimer -= uiDiff;
+
+            if (m_uiSummonOverTimer < uiDiff && m_bIsSummoning)
+            {
+                m_bIsSummoning = false;
+                m_uiSummonOverTimer = 60000;
+            }
+            else
+                m_uiSummonOverTimer -= uiDiff;
+
+            if(!GetClosestCreatureWithEntry(m_creature, NPC_ICK, 100.0f))
+                m_bIsOutro = true;
+
+            if (m_creature->GetDistance2d(HOME_X, HOME_Y) > 80)
+                EnterEvadeMode();
+        }
+        if(m_bIsOutro)
+        {
+            switch(Step)
+            {
+            case 1:
+                m_creature->RemoveAllAuras();
+                m_creature->DeleteThreatList();
+                m_creature->CombatStop(true);
+                m_creature->InterruptNonMeleeSpells(false);
+                m_creature->GetMotionMaster()->MoveIdle();
+                DoScriptText(SAY_OUTRO1, m_creature);
+
+                if(TeamInInstance == ALLIANCE)
+                {
+                    if(Creature* pJaina = m_creature->SummonCreature(NPC_JAINA_START, 783.565f, 112.559f, 509.461f, 0, TEMPSUMMON_TIMED_DESPAWN, 80000))
+                    {
+                        pJaina->GetMotionMaster()->MovePoint(0, m_creature->GetPositionX() - 15, m_creature->GetPositionY(), m_creature->GetPositionZ());
+                        m_uiJainaGuid = pJaina->GetGUID();
+                    }
+                }
+
+                if(TeamInInstance == HORDE)
+                {
+                    if(Creature* pSylvanas = m_creature->SummonCreature(NPC_SYLVANAS_START, 783.565f, 112.559f, 509.461f, 0, TEMPSUMMON_TIMED_DESPAWN, 80000))
+                    {
+                        pSylvanas->GetMotionMaster()->MovePoint(0, m_creature->GetPositionX() - 15, m_creature->GetPositionY(), m_creature->GetPositionZ());
+                        m_uiSylvanasGuid = pSylvanas->GetGUID();
+                    }
+                }
+                ++Step;
+                OutroTimer = 15000;
+                break;
+            case 3:
+                if(TeamInInstance == ALLIANCE)
+                {
+                    if(Creature* pJaina = m_pInstance->instance->GetCreature(m_uiJainaGuid))
+                    {
+                        DoScriptText(SAY_OUTRO2_ALY, pJaina);
+                        pJaina->SetUInt64Value(UNIT_FIELD_TARGET, m_creature->GetGUID());
+                    }
+                }
+                if(TeamInInstance == HORDE)
+                {
+                    if(Creature* pSylvanas = m_pInstance->instance->GetCreature(m_uiSylvanasGuid))
+                    {
+                        DoScriptText(SAY_OUTRO2_HORDE, pSylvanas);
+                        pSylvanas->SetUInt64Value(UNIT_FIELD_TARGET, m_creature->GetGUID());
+                    }
+                }
+                ++Step;
+                OutroTimer = 5000;
+                break;
+            case 5:
+                DoScriptText(SAY_OUTRO3, m_creature);
+                ++Step;
+                OutroTimer = 15000;
+                break;
+            case 7:
+                if(TeamInInstance == ALLIANCE)
+                    if(Creature* pJaina = m_pInstance->instance->GetCreature(m_uiJainaGuid))
+                        DoScriptText(SAY_OUTRO4_ALY, pJaina);
+                if(TeamInInstance == HORDE)
+                    if(Creature* pSylvanas = m_pInstance->instance->GetCreature(m_uiSylvanasGuid))
+                        DoScriptText(SAY_OUTRO4_HORDE, pSylvanas);
+                ++Step;
+                OutroTimer = 5000;
+                break;
+            case 9:
+                DoScriptText(SAY_OUTRO5, m_creature);
+                if(Creature* pTyrannus = m_creature->SummonCreature(NPC_TYRANNUS_INTRO, 860.649f, 124.863f, 536.019f, 3.43f, TEMPSUMMON_TIMED_DESPAWN, 20000))
+                {
+                    pTyrannus->GetMotionMaster()->MoveIdle();
+                    pTyrannus->SetUInt64Value(UNIT_FIELD_TARGET, m_creature->GetGUID());
+                    pTyrannus->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    pTyrannus->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                    pTyrannus->SetUInt32Value(UNIT_FIELD_BYTES_0, 50331648);
+                    pTyrannus->SetUInt32Value(UNIT_FIELD_BYTES_1, 50331648);
+                    pTyrannus->GetMotionMaster()->MoveIdle();
+                    pTyrannus->GetMap()->CreatureRelocation(pTyrannus, 860.649f, 124.863f, 536.019f, 3.43f);
+                    pTyrannus->SendMonsterMove(860.649f, 124.863f, 536.019f, SPLINETYPE_NORMAL, pTyrannus->GetSplineFlags(), 1);
+                    m_uiTyrannusGuid = pTyrannus->GetGUID();
+                }
+                ++Step;
+                OutroTimer = 4000;
+                break;
+            case 11:
+                if(Creature* pTyrannus = m_pInstance->instance->GetCreature(m_uiTyrannusGuid))
+                    DoScriptText(SAY_OUTRO6_TYRANNUS, pTyrannus);
+                ++Step;
+                OutroTimer = 4000;
+                break;
+            case 13:
+                DoScriptText(SAY_OUTRO7, m_creature);
+                ++Step;
+                OutroTimer = 3000;
+                break;
+            case 15:
+                m_creature->SetHealth(0);
+                m_creature->SetStandFlags(UNIT_STAND_STATE_DEAD);
+                if(Creature* pTyrannus = m_pInstance->instance->GetCreature(m_uiTyrannusGuid))
+                    DoScriptText(SAY_OUTRO8_TYRANNUS, pTyrannus);
+                ++Step;
+                OutroTimer = 10000;
+                break;
+            case 17:
+                if(TeamInInstance == ALLIANCE)
+                    if(Creature* pJaina = m_pInstance->instance->GetCreature(m_uiJainaGuid))
+                        DoScriptText(SAY_OUTRO9_ALY, pJaina);
+                if(TeamInInstance == HORDE)
+                    if(Creature* pSylvanas = m_pInstance->instance->GetCreature(m_uiSylvanasGuid))
+                        DoScriptText(SAY_OUTRO9_HORDE, pSylvanas);
+                m_creature->DealDamage(m_creature, m_creature->GetMaxHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                ++Step;
+                OutroTimer = 3000;
+                break;
+            }
+            if (OutroTimer <= uiDiff)
+            {
+                ++Step;
+                OutroTimer = 330000;
+            } OutroTimer -= uiDiff;
+        }
+    }
+};
+
+struct MANGOS_DLL_DECL mob_explosive_orbAI : public ScriptedAI
+{
+    mob_explosive_orbAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiExplosiveBarrageTimer;
+
+    void Reset()
+    {
+        m_uiExplosiveBarrageTimer = 3000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+
+        if (m_uiExplosiveBarrageTimer < uiDiff)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_EXPLOSIVE_BARRAGE_ORB : SPELL_EXPLOSIVE_BARRAGE_ORB_H);
+            m_uiExplosiveBarrageTimer = 10000;
+        }
+        else
+            m_uiExplosiveBarrageTimer -= uiDiff;      
+    }
+};
+
+CreatureAI* GetAI_mob_explosive_orb(Creature* pCreature)
+{
+    return new mob_explosive_orbAI (pCreature);
+}
+
+CreatureAI* GetAI_boss_Ick(Creature* pCreature)
+{
+    return new boss_IckAI (pCreature);
+}
+
+CreatureAI* GetAI_boss_Krick(Creature* pCreature)
+{
+    return new boss_KrickAI (pCreature);
+}
+
+void AddSC_boss_Ick_and_Krick()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_Ick";
+    newscript->GetAI = &GetAI_boss_Ick;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "boss_Krick";
+    newscript->GetAI = &GetAI_boss_Krick;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_explosive_orb";
+    newscript->GetAI = &GetAI_mob_explosive_orb;
+    newscript->RegisterSelf();
+}
diff --git a/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/boss_scourgelord_tyrannus.cpp b/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/boss_scourgelord_tyrannus.cpp
index a023c3d..7c6ba9e 100644
--- a/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/boss_scourgelord_tyrannus.cpp
+++ b/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/boss_scourgelord_tyrannus.cpp
@@ -1,18 +1,18 @@
 /* Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 /* ScriptData
 SDName: boss_scourgelord_tyrannus
@@ -22,3 +22,677 @@ SDCategory: Pit of Saron
 EndScriptData */
 
 #include "precompiled.h"
+#include "pit_of_saron.h"
+
+enum
+{
+    SPELL_FORCEFUL_SMASH        = 69155,
+    SPELL_FORCEFUL_SMASH_H      = 69627,
+    SPELL_OVERLORDS_BRAND       = 69172,
+    SPELL_DARK_MIGHT            = 69167,
+    SPELL_DARK_MIGHT_H          = 69629,
+    SPELL_HOARFROST             = 69246,
+    SPELL_MARK_OF_RIMEFANG      = 69275,
+    SPELL_ICY_BLAST             = 69233,
+    SPELL_ICY_BLAST_H           = 69646,
+    SPELL_ICY_BLAST_SLOW        = 69238,
+    SPELL_ICY_BLAST_SLOW_H      = 69628,
+
+    SAY_CHASE1              = -1610081,
+    SAY_CHASE2              = -1610082,
+    SAY_GAUNTLET            = -1610083,
+
+    SAY_INTRO1              = -1610084,
+    SAY_INTRO2_SLAVES       = -1610085,
+    SAY_INTRO3              = -1610086,
+
+    SAY_DARK_MIGHT                = -1610089,
+    SAY_DARK_MIGHT_EMOTE          = -1610088,
+    SAY_MARK_OF_RIMEFANG          = -1610090,
+    SAY_AGGRO                     = -1610087,
+    SAY_SLAY_1                    = -1610091,
+    SAY_SLAY_2                    = -1610092,
+    SAY_DEATH                     = -1610093,
+
+    SAY_OUTRO1_SLAVE              = -1610094,
+    SAY_OUTRO2_SLAVE              = -1610095,
+    SAY_OUTRO3_HORDE              = -1610096,
+    SAY_OUTRO3_ALY                = -1610097,
+    SAY_OUTRO4_HORDE              = -1610098,
+    SAY_OUTRO4_ALY                = -1610099,
+    SAY_OUTRO5_ALY                = -1610100,
+
+    NPC_SINDRAGOSA                = 37755,
+    SPELL_FROST_BOMB              = 70521,
+
+    EQUIP_ID                      = 51796,
+};
+
+#define HOME_X                      1014.51f
+#define HOME_Y                      170.423f
+
+const float RimefangSummon[4] = {1013.827f, 169.71f, 628.157f, 5.31f};
+
+//Positional defines 
+struct LocationsXY
+{
+    float x, y, z, o;
+    uint32 id;
+};
+static LocationsXY SummonLoc[]=
+{
+    {1060.955f, 107.274f, 628.424f},
+    {1052.122f, 103.916f, 628.454f},
+    {1068.363f, 110.432f, 629.009f},
+};
+
+static LocationsXY MoveLoc[]=
+{
+    {1019.006f, 129.684f, 628.156f}, 
+    {1003.889f, 159.652f, 628.159f},
+    {1015.389f, 183.650f, 628.156f},
+    {1065.827f, 210.836f, 628.156f},
+    {1072.659f, 204.432f, 628.156f},
+};
+
+struct MANGOS_DLL_DECL npc_sylvanas_jaina_pos_endAI: public ScriptedAI
+{
+    npc_sylvanas_jaina_pos_endAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+
+    uint32 m_uiSpeech_Timer;
+    uint8 m_uiOutro_Phase;
+    bool m_bIsOutro;
+    uint32 creatureEntry;
+
+    uint64 m_uiMartinGuid;
+    uint64 m_uiGorkunGuid;
+    uint64 m_uiTyrannusGuid;
+    uint64 m_uiSindragosaGuid;
+
+    std::list<Creature*> lSlavesList;
+
+    void Reset()
+    {
+        lSlavesList.clear();
+        m_uiOutro_Phase     = 0;
+        m_uiSpeech_Timer    = 1000;
+        m_bIsOutro          = true;
+        creatureEntry = m_creature->GetEntry();
+
+        m_uiMartinGuid      = 0;
+        m_uiGorkunGuid      = 0;
+        m_uiTyrannusGuid    = 0;
+        m_uiSindragosaGuid  = 0;
+    }
+
+    void TeleportPlayers()
+    {
+        Map* pMap = m_creature->GetMap();
+        if(pMap)
+        {
+            Map::PlayerList const &lPlayers = pMap->GetPlayers();
+            if (!lPlayers.isEmpty())
+            {
+                for(Map::PlayerList::const_iterator itr = lPlayers.begin(); itr != lPlayers.end(); ++itr)
+                {
+                    if (Player* pPlayer = itr->getSource())
+                        pPlayer->TeleportTo(m_creature->GetMapId(), 1065.983f, 94.954f, 630.997f, 2.247f);
+                }
+            }
+        }
+    }
+
+    void SummonHordeSlaves()
+    {
+        for (uint8 i = 0; i < 5; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_SLAVE_HORDE_1, SummonLoc[0].x + urand(0, 20), SummonLoc[0].y + urand(0, 20), SummonLoc[0].z, SummonLoc[0].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[0].x + urand(0, 20), MoveLoc[0].y + urand(0, 20), MoveLoc[0].z);
+        }
+
+        for (uint8 i = 5; i < 10; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_SLAVE_HORDE_2, SummonLoc[1].x + urand(0, 10), SummonLoc[1].y - urand(0, 10), SummonLoc[1].z, SummonLoc[1].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[2].x + urand(0, 20), MoveLoc[2].y - urand(0, 20), MoveLoc[2].z);
+        }
+
+        for (uint8 i = 10; i < 15; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_SLAVE_HORDE_3, SummonLoc[2].x - urand(0, 20), SummonLoc[2].y - urand(0, 20), SummonLoc[2].z, SummonLoc[2].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[1].x - urand(0, 20), MoveLoc[1].y - urand(0, 20), MoveLoc[1].z);
+        }
+    }
+
+    void SummonAlySlaves()
+    {
+        for (uint8 i = 0; i < 5; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_SLAVE_ALY_1, SummonLoc[0].x + urand(0, 20), SummonLoc[0].y + urand(0, 20), SummonLoc[0].z, SummonLoc[0].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[0].x + urand(0, 20), MoveLoc[0].y + urand(0, 20), MoveLoc[0].z);
+        }
+
+        for (uint8 i = 5; i < 10; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_SLAVE_ALY_2, SummonLoc[1].x + urand(0, 10), SummonLoc[1].y - urand(0, 10), SummonLoc[1].z, SummonLoc[1].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[2].x + urand(0, 20), MoveLoc[2].y - urand(0, 20), MoveLoc[2].z);
+        }
+
+        for (uint8 i = 10; i < 15; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_SLAVE_ALY_3, SummonLoc[2].x - urand(0, 20), SummonLoc[2].y - urand(0, 20), SummonLoc[2].z, SummonLoc[2].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[1].x - urand(0, 20), MoveLoc[1].y - urand(0, 20), MoveLoc[1].z);
+        }
+    }
+
+    void SummonAlyAssist()
+    {
+        Creature *pElandra = m_creature->SummonCreature(NPC_ELANDRA, SummonLoc[0].x, SummonLoc[0].y, SummonLoc[0].z, SummonLoc[20].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+        if (pElandra)
+            pElandra->GetMotionMaster()->MovePoint(0, MoveLoc[3].x, MoveLoc[3].y, MoveLoc[3].z);
+        Creature *pKoreln = m_creature->SummonCreature(NPC_KORELN, SummonLoc[1].x, SummonLoc[1].y, SummonLoc[1].z, SummonLoc[21].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+        if (pKoreln)
+            pKoreln->GetMotionMaster()->MovePoint(0, MoveLoc[4].x, MoveLoc[4].y, MoveLoc[4].z);
+    }
+
+    void SummonHordeAssist()
+    {
+        Creature *pLoralen = m_creature->SummonCreature(NPC_LORALEN, SummonLoc[0].x, SummonLoc[0].y, SummonLoc[0].z, SummonLoc[20].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+        if (pLoralen)
+            pLoralen->GetMotionMaster()->MovePoint(0, MoveLoc[3].x, MoveLoc[3].y, MoveLoc[3].z);
+        Creature *pKelira = m_creature->SummonCreature(NPC_KALIRA, SummonLoc[1].x, SummonLoc[1].y, SummonLoc[1].z, SummonLoc[21].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+        if (pKelira)
+            pKelira->GetMotionMaster()->MovePoint(0, MoveLoc[4].x, MoveLoc[4].y, MoveLoc[4].z);
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_bIsOutro)
+        {
+            if(m_uiSpeech_Timer < uiDiff)
+            {
+                switch(m_uiOutro_Phase)
+                {
+                case 0:
+                    if(Creature* pTyrannus = GetClosestCreatureWithEntry(m_creature, NPC_RIMEFANG, 100.0f))
+                        m_uiTyrannusGuid = pTyrannus->GetGUID();
+                    switch (creatureEntry)
+                    {
+                    case NPC_JAINA_END:
+                        if(Creature* pMartin = GetClosestCreatureWithEntry(m_creature, NPC_MARTIN_VICTUS_END, 100.0f))
+                        {
+                            DoScriptText(SAY_OUTRO1_SLAVE, pMartin);
+                            //SummonAlySlaves();
+                            pMartin->GetMotionMaster()->MovePoint(0, 1014.670f, 158.714f, 628.156f);
+                            m_uiMartinGuid = pMartin->GetGUID();
+                        }
+                        break;
+                    case NPC_SYLVANAS_END:
+                        if(Creature* pGorkun = GetClosestCreatureWithEntry(m_creature, NPC_GORKUN_IRONSKULL_END, 100.0f))
+                        {
+                            DoScriptText(SAY_OUTRO1_SLAVE, pGorkun);
+                            //SummonHordeSlaves();
+                            pGorkun->GetMotionMaster()->MovePoint(0, 1014.670f, 158.714f, 628.156f);
+                            m_uiGorkunGuid = pGorkun->GetGUID();
+                        }
+                        break;
+                    }
+                    ++m_uiOutro_Phase;
+                    m_uiSpeech_Timer = 15000;
+                    break;
+                case 1:
+                    if(Creature* pSindragosa = m_creature->SummonCreature(NPC_SINDRAGOSA, 977.224f, 164.056f, 653.216f,  0.064f, TEMPSUMMON_TIMED_DESPAWN, 15000))
+                    {
+                        pSindragosa->GetMotionMaster()->MoveIdle();
+                        pSindragosa->SetUInt32Value(UNIT_FIELD_BYTES_0, 50331648);
+                        pSindragosa->SetUInt32Value(UNIT_FIELD_BYTES_1, 50331648);
+                        pSindragosa->GetMotionMaster()->MoveIdle();
+                        pSindragosa->GetMap()->CreatureRelocation(pSindragosa, 977.224f, 164.056f, 653.216f,  0.064f);
+                        pSindragosa->SendMonsterMove(977.224f, 164.056f, 653.216f, SPLINETYPE_NORMAL, pSindragosa->GetSplineFlags(), 1);
+                        m_uiSindragosaGuid = pSindragosa->GetGUID();
+                    }
+                    switch (creatureEntry)
+                    {
+                    case NPC_JAINA_END:
+                        if(Creature* pMartin = m_pInstance->instance->GetCreature(m_uiMartinGuid))
+                            DoScriptText(SAY_OUTRO2_SLAVE, pMartin);
+                        break;
+                    case NPC_SYLVANAS_END:
+                        if(Creature* pGorkun = m_pInstance->instance->GetCreature(m_uiGorkunGuid))
+                            DoScriptText(SAY_OUTRO2_SLAVE, pGorkun);
+                        break;
+                    }
+                    ++m_uiOutro_Phase;
+                    m_uiSpeech_Timer = 10000;
+                    break;
+                case 2:
+                    switch (creatureEntry)
+                    {
+                    case NPC_JAINA_END:
+                        if(Creature* pMartin = m_pInstance->instance->GetCreature(m_uiMartinGuid))
+                        {
+                            pMartin->SetHealth(0);
+                            pMartin->SetStandFlags(UNIT_STAND_STATE_DEAD);
+                            if(Creature* pSindragosa = m_pInstance->instance->GetCreature(m_uiSindragosaGuid))
+                                pSindragosa->CastSpell(pMartin, SPELL_FROST_BOMB, false);
+                        }
+                        DoScriptText(SAY_OUTRO3_ALY, m_creature);
+                        break;
+                    case NPC_SYLVANAS_END:
+                        if(Creature* pGorkun = m_pInstance->instance->GetCreature(m_uiGorkunGuid))
+                        {
+                            pGorkun->SetHealth(0);
+                            pGorkun->SetStandFlags(UNIT_STAND_STATE_DEAD);
+                            if(Creature* pSindragosa = m_pInstance->instance->GetCreature(m_uiSindragosaGuid))
+                                pSindragosa->CastSpell(pGorkun, SPELL_FROST_BOMB, false);
+                        }
+                        DoScriptText(SAY_OUTRO3_HORDE, m_creature);
+                        break;
+                    }
+                    TeleportPlayers();
+                    ++m_uiOutro_Phase;
+                    m_uiSpeech_Timer = 7000;
+                    break;
+                case 3:
+                    switch (creatureEntry)
+                    {
+                    case NPC_JAINA_END:
+                        DoScriptText(SAY_OUTRO4_ALY, m_creature);
+                        m_creature->GetMotionMaster()->MovePoint(0, 1068.709f, 208.378f, 628.156f);
+                        SummonAlyAssist();
+                        m_uiSpeech_Timer = 7000;
+                        break;
+                    case NPC_SYLVANAS_END:
+                        DoScriptText(SAY_OUTRO4_HORDE, m_creature);
+                        m_creature->GetMotionMaster()->MovePoint(0, 1068.709f, 208.378f, 628.156f);
+                        SummonHordeAssist();
+                        m_bIsOutro = false;
+                        break;
+                    }
+                    ++m_uiOutro_Phase;
+                    break;
+                case 4:
+                    switch (creatureEntry)
+                    {
+                    case NPC_JAINA_END:
+                        DoScriptText(SAY_OUTRO5_ALY, m_creature);
+                        break;
+                    case NPC_SYLVANAS_END:
+                        break;
+                    }
+                    m_bIsOutro = false;
+                    ++m_uiOutro_Phase;
+                    m_uiSpeech_Timer = 5000;
+                    break;
+
+                default:
+                    m_uiSpeech_Timer = 100000;
+                }
+            }else m_uiSpeech_Timer -= uiDiff;
+        }
+    }
+};
+
+struct MANGOS_DLL_DECL boss_TyrannusAI : public ScriptedAI
+{
+    boss_TyrannusAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        SetEquipmentSlots(false, EQUIP_ID, -1, -1);
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint64 m_uiRimefangGuid;
+
+    uint32 m_uiSpeech_Timer;
+    uint8 m_uiIntro_Phase;
+    bool m_bIsIntro;
+    bool m_bIsTunnelIntro;
+    bool m_bHasTaunted;
+    bool m_bHasPassedTunnel;
+
+    uint64 m_uiMartinGuid;
+    uint64 m_uiGorkunGuid;
+
+    uint32 m_uiForcefulSmashTimer;
+    uint32 m_uiOverlordsBrandTimer;
+    uint32 m_uiDarkMightTimer;
+    uint32 m_uiMarkOfRimefangTimer;
+    uint32 TeamInInstance;
+
+    void Reset()
+    {
+        m_uiForcefulSmashTimer  = 10000;
+        m_uiOverlordsBrandTimer = 35000;
+        m_uiDarkMightTimer      = 40000;
+        m_uiMarkOfRimefangTimer = 55000;
+
+        m_uiIntro_Phase     = 0;
+        m_uiSpeech_Timer    = 1000;
+        m_bIsIntro          = false; 
+
+        m_bHasTaunted = false;
+
+        m_uiMartinGuid      = 0;
+        m_uiGorkunGuid      = 0;
+        m_uiRimefangGuid    = 0;
+        
+        TeamInInstance = GetFaction();
+        
+        if(Creature* pRimefang = GetClosestCreatureWithEntry(m_creature, NPC_RIMEFANG, 100.0f))
+        {
+            pRimefang->GetMotionMaster()->MoveIdle();
+            pRimefang->GetMap()->CreatureRelocation(pRimefang, RimefangSummon[0], RimefangSummon[1], RimefangSummon[2]  + 10, RimefangSummon[3]);
+            pRimefang->SendMonsterMove(RimefangSummon[0], RimefangSummon[1], RimefangSummon[2] + 10, SPLINETYPE_NORMAL, m_creature->GetSplineFlags(), 1);
+            m_uiRimefangGuid = pRimefang->GetGUID();
+        }
+        else
+        {
+            pRimefang = m_creature->SummonCreature(NPC_RIMEFANG, RimefangSummon[0], RimefangSummon[1], RimefangSummon[2], RimefangSummon[3], TEMPSUMMON_CORPSE_TIMED_DESPAWN, 30000);
+            m_uiRimefangGuid = pRimefang->GetGUID();
+
+            if(pRimefang)
+            {
+                pRimefang->GetMotionMaster()->MoveIdle();
+                pRimefang->GetMap()->CreatureRelocation(pRimefang, RimefangSummon[0], RimefangSummon[1], RimefangSummon[2]  + 10, RimefangSummon[3]);
+                pRimefang->SendMonsterMove(RimefangSummon[0], RimefangSummon[1], RimefangSummon[2] + 10, SPLINETYPE_NORMAL, m_creature->GetSplineFlags(), 1);
+            }
+        }
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_TYRANNUS, NOT_STARTED);
+    }
+
+    uint32 GetFaction()
+    {
+        uint32 faction = 0;
+        Map *map = m_creature->GetMap();
+        if (map->IsDungeon())
+        {
+            Map::PlayerList const &PlayerList = map->GetPlayers();
+
+            if (!PlayerList.isEmpty())
+            {
+                if (Player* pPlayer = PlayerList.begin()->getSource())
+                    faction = pPlayer->GetTeam();
+            }
+        }
+        return faction;
+    }
+
+    void MoveInLineOfSight(Unit *pWho)
+    {
+        if (!m_bHasTaunted && pWho->isInAccessablePlaceFor(m_creature) && !m_bIsIntro && pWho->GetTypeId() == TYPEID_PLAYER && m_creature->IsWithinDistInMap(pWho, 80) && m_creature->IsWithinLOSInMap(pWho))
+        {
+            m_bIsIntro = true;
+            m_bHasTaunted = true;
+
+            m_uiIntro_Phase     = 0;
+            m_uiSpeech_Timer    = 1000;
+
+            if(Creature* pRimefang = m_pInstance->instance->GetCreature(m_uiRimefangGuid))
+            {
+                pRimefang->GetMotionMaster()->MoveIdle();
+                pRimefang->GetMap()->CreatureRelocation(pRimefang, RimefangSummon[0], RimefangSummon[1], RimefangSummon[2]  + 10, RimefangSummon[3]);
+                pRimefang->SendMonsterMove(RimefangSummon[0], RimefangSummon[1], RimefangSummon[2] + 10, SPLINETYPE_NORMAL, m_creature->GetSplineFlags(), 1);
+            }
+        }  
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_TYRANNUS, IN_PROGRESS);
+
+        DoScriptText(SAY_AGGRO, m_creature);
+
+        m_bIsIntro = false;
+
+        if(Creature* pRimefang = m_pInstance->instance->GetCreature(m_uiRimefangGuid))
+        {
+            pRimefang->SetInCombatWithZone();
+            pRimefang->GetMotionMaster()->MoveIdle();
+            pRimefang->GetMap()->CreatureRelocation(pRimefang, RimefangSummon[0], RimefangSummon[1], RimefangSummon[2]  + 20, RimefangSummon[3]);
+            pRimefang->SendMonsterMove(RimefangSummon[0], RimefangSummon[1], RimefangSummon[2] + 20, SPLINETYPE_NORMAL, m_creature->GetSplineFlags(), 1);
+        }
+    }
+
+    void KilledUnit(Unit *victim)
+    {
+        switch(urand(0, 1))
+        {
+        case 0: DoScriptText(SAY_SLAY_1, m_creature); break;
+        case 1: DoScriptText(SAY_SLAY_2, m_creature); break;
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_bIsIntro)
+        {
+            if(m_uiSpeech_Timer < uiDiff)
+            {
+                switch(m_uiIntro_Phase)
+                {
+                case 0:
+                    DoScriptText(SAY_INTRO1, m_creature);
+                    if(TeamInInstance == ALLIANCE)
+                        if(Creature* pMartin = m_creature->SummonCreature(NPC_MARTIN_VICTUS_END, 1060.955f, 107.274f, 629.424f, 2.084f, TEMPSUMMON_DEAD_DESPAWN, 0))
+                            m_uiMartinGuid = pMartin->GetGUID();
+                    if(TeamInInstance == HORDE)
+                        if(Creature* pGorkun = m_creature->SummonCreature(NPC_GORKUN_IRONSKULL_END, 1060.955f, 107.274f, 629.424f, 2.084f, TEMPSUMMON_DEAD_DESPAWN, 0))
+                            m_uiGorkunGuid = pGorkun->GetGUID();
+                    ++m_uiIntro_Phase;
+                    m_uiSpeech_Timer = 15000;
+                    break;
+                case 1:
+                    if(TeamInInstance == ALLIANCE)
+                    {
+                        if(Creature* pMartin = m_pInstance->instance->GetCreature(m_uiMartinGuid))
+                            DoScriptText(SAY_INTRO2_SLAVES, pMartin);
+                    }
+                    if(TeamInInstance == HORDE)
+                    {
+                        if(Creature* pGorkun = m_pInstance->instance->GetCreature(m_uiGorkunGuid))
+                            DoScriptText(SAY_INTRO2_SLAVES, pGorkun);
+                    }
+                    ++m_uiIntro_Phase;
+                    m_uiSpeech_Timer = 10000;
+                    break;
+                case 2:
+                    DoScriptText(SAY_INTRO3, m_creature);
+                    m_bIsIntro = false;
+                    ++m_uiIntro_Phase;
+                    m_uiSpeech_Timer = 15000;
+                    break;
+
+                default:
+                    m_uiSpeech_Timer = 100000;
+                }
+            }else m_uiSpeech_Timer -= uiDiff;
+        }
+
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiForcefulSmashTimer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_FORCEFUL_SMASH : SPELL_FORCEFUL_SMASH_H);
+            m_uiForcefulSmashTimer = 10000;
+        }
+        else
+            m_uiForcefulSmashTimer -= uiDiff;
+
+        if (m_uiOverlordsBrandTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, SPELL_OVERLORDS_BRAND);
+            m_uiOverlordsBrandTimer = 45000;
+        }
+        else
+            m_uiOverlordsBrandTimer -= uiDiff;
+
+        if (m_uiDarkMightTimer < uiDiff)
+        {
+            DoScriptText(SAY_DARK_MIGHT, m_creature);
+            DoScriptText(SAY_DARK_MIGHT_EMOTE, m_creature);
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_DARK_MIGHT : SPELL_DARK_MIGHT_H);
+            m_uiDarkMightTimer = 60000;
+        }
+        else
+            m_uiDarkMightTimer -= uiDiff;
+
+        if (m_uiMarkOfRimefangTimer < uiDiff)
+        {
+            DoScriptText(SAY_MARK_OF_RIMEFANG, m_creature);
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, SPELL_MARK_OF_RIMEFANG);
+            m_uiMarkOfRimefangTimer = 55000;
+        }
+        else
+            m_uiMarkOfRimefangTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+
+        if (m_creature->GetDistance2d(HOME_X, HOME_Y) > 80)
+            EnterEvadeMode();
+    }
+    void JustDied(Unit* killer)  
+    {
+        DoScriptText(SAY_DEATH, m_creature);
+        if (Creature* pRimefang = m_pInstance->instance->GetCreature(m_uiRimefangGuid))
+        {
+            pRimefang->GetMotionMaster()->Clear();
+            pRimefang->GetMotionMaster()->MovePoint(0, 844.752f, 358.993f, 645.330f);
+            pRimefang->setFaction(35);
+            pRimefang->DeleteThreatList();
+            pRimefang->RemoveAllAuras();
+            pRimefang->SetVisibility(VISIBILITY_OFF);
+            //pRimefang->DealDamage(pRimefang, pRimefang->GetMaxHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_TYRANNUS, DONE);
+
+        if(TeamInInstance == ALLIANCE)
+            Creature *pJaina = m_creature->SummonCreature(NPC_JAINA_END, 1065.983f, 94.954f, 630.997f, 2.247f, TEMPSUMMON_DEAD_DESPAWN, 0);
+
+        if(TeamInInstance == HORDE)
+            Creature *pSylvanas = m_creature->SummonCreature(NPC_SYLVANAS_END, 1065.983f, 94.954f, 630.997f, 2.247f, TEMPSUMMON_DEAD_DESPAWN, 0);
+    }
+};
+
+struct MANGOS_DLL_DECL boss_RimefangAI : public ScriptedAI
+{
+    boss_RimefangAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        SetCombatMovement(false);
+        pCreature->setFaction(14);
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiHoarfrostTimer;
+    uint32 m_uiIcyBlastTimer;
+    uint32 m_uiIcyBlastSlowTimer;
+
+    void Reset()
+    {
+        m_uiHoarfrostTimer  = 25000;
+        m_uiIcyBlastTimer   = 35000;
+        m_uiIcyBlastSlowTimer   = 30000;
+        m_creature->InterruptSpell(CURRENT_GENERIC_SPELL);
+        m_creature->HandleEmoteCommand(EMOTE_ONESHOT_LIFTOFF); 
+
+        m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 50331648);
+        m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 50331648);
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiHoarfrostTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, SPELL_HOARFROST);
+            m_uiHoarfrostTimer = 20000;
+        }
+        else
+            m_uiHoarfrostTimer -= uiDiff;
+
+        if (m_uiIcyBlastTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_ICY_BLAST : SPELL_ICY_BLAST_H);
+            m_uiIcyBlastTimer = 35000;
+        }
+        else
+            m_uiIcyBlastTimer -= uiDiff;
+
+        if (m_uiIcyBlastSlowTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_ICY_BLAST_SLOW : SPELL_ICY_BLAST_SLOW_H);
+            m_uiIcyBlastSlowTimer = 40000;
+        }
+        else
+            m_uiIcyBlastSlowTimer -= uiDiff;
+    }
+};
+
+CreatureAI* GetAI_boss_Tyrannus(Creature* pCreature)
+{
+    return new boss_TyrannusAI (pCreature);
+}
+
+CreatureAI* GetAI_boss_Rimefang(Creature* pCreature)
+{
+    return new boss_RimefangAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_sylvanas_jaina_pos_end(Creature* pCreature)
+{
+    return new npc_sylvanas_jaina_pos_endAI (pCreature);
+}
+
+void AddSC_boss_Tyrannus()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name="boss_Tyrannus";
+    newscript->GetAI = &GetAI_boss_Tyrannus;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="boss_Rimefang";
+    newscript->GetAI = &GetAI_boss_Rimefang;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->GetAI = &GetAI_npc_sylvanas_jaina_pos_end;
+    newscript->Name = "npc_slyvanas_jaina_pos_end";
+    newscript->RegisterSelf();
+}
diff --git a/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/instance_pit_of_saron.cpp b/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/instance_pit_of_saron.cpp
new file mode 100644
index 0000000..e0c902b
--- /dev/null
+++ b/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/instance_pit_of_saron.cpp
@@ -0,0 +1,212 @@
+/* Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "precompiled.h"
+#include "pit_of_saron.h"
+
+#define MAX_ENCOUNTER     4
+
+struct MANGOS_DLL_DECL instance_pit_of_saron : public ScriptedInstance
+{
+    instance_pit_of_saron(Map* pMap) : ScriptedInstance(pMap) {Initialize();};
+
+	std::string str_data;
+    uint64 m_uiKrick;
+    uint64 m_uiIck;
+    uint64 m_uiRimefang;
+	uint64 m_uiGarfrost;
+	uint64 m_uiTyrannus;
+
+    uint32 m_auiEncounter[MAX_ENCOUNTER];
+
+   void Initialize()
+   {
+        memset(&m_auiEncounter, 0, sizeof(m_auiEncounter));
+
+        m_uiGarfrost = 0;
+		m_uiKrick = 0;
+		m_uiTyrannus = 0;
+        m_uiIck = 0;
+        m_uiRimefang = 0;
+    }
+
+    bool IsEncounterInProgress() const
+    {
+        for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+            if (m_auiEncounter[i] == IN_PROGRESS) return true;
+
+        return false;
+    }
+
+    void OnCreatureCreate(Creature* pCreature, bool add)
+    {
+        Map::PlayerList const &players = instance->GetPlayers();
+        uint32 TeamInInstance = 0;
+
+        if (!players.isEmpty())
+        {
+            if (Player* pPlayer = players.begin()->getSource())
+                TeamInInstance = pPlayer->GetTeam();
+        }
+
+        switch(pCreature->GetEntry())
+        {
+           case NPC_KRICK:    
+               m_uiKrick = pCreature->GetGUID();     
+               break;
+           case NPC_ICK: 
+               m_uiIck = pCreature->GetGUID();
+               break;
+		   case NPC_GARFROST:    
+               m_uiGarfrost = pCreature->GetGUID();        
+               break;
+		   case NPC_TYRANNUS:    
+               m_uiTyrannus = pCreature->GetGUID();        
+               break;
+           case NPC_RIMEFANG:
+               m_uiRimefang = pCreature->GetGUID();
+               break;
+           case NPC_SLYVANAS_PART1:
+                if (TeamInInstance == ALLIANCE)
+                   pCreature->UpdateEntry(NPC_JAINA_PART1, ALLIANCE);
+				break;
+           case NPC_KALIRA:
+                if (TeamInInstance == ALLIANCE)
+                   pCreature->UpdateEntry(NPC_ELANDRA, ALLIANCE);
+				break;
+           case NPC_LORALEN:
+                if (TeamInInstance == ALLIANCE)
+                   pCreature->UpdateEntry(NPC_KORELN, ALLIANCE);
+				break;
+            case NPC_CHAMPION_1_HORDE:
+                if (TeamInInstance == ALLIANCE)
+                   pCreature->UpdateEntry(NPC_CHAMPION_1_ALLIANCE, ALLIANCE);
+				break;
+            case NPC_CHAMPION_2_HORDE:
+                if (TeamInInstance == ALLIANCE)
+                   pCreature->UpdateEntry(NPC_CHAMPION_2_ALLIANCE, ALLIANCE);
+				break;
+            case NPC_CHAMPION_3_HORDE: // No 3rd set for Alliance?
+                if (TeamInInstance == ALLIANCE) 
+                   pCreature->UpdateEntry(NPC_CHAMPION_2_ALLIANCE, ALLIANCE);
+				break;
+        }
+    }
+
+    uint64 GetData64(uint32 identifier)
+    {
+        switch(identifier)
+        {
+            case TYPE_GARFROST:			    return m_uiGarfrost;
+			case TYPE_TYRANNUS:             return m_uiTyrannus;
+			case TYPE_KRICK_AND_ICK:        return m_uiKrick;
+        }
+
+        return 0;
+    }
+
+    void SetData(uint32 type, uint32 data)
+    {
+        switch(type)
+        {
+        case TYPE_GARFROST:
+            m_auiEncounter[0] = data; break;
+		case TYPE_TYRANNUS:
+            m_auiEncounter[1] = data; break;
+        case TYPE_KRICK_AND_ICK:
+            m_auiEncounter[2] = data; break;
+        case TYPE_INTRO:
+            m_auiEncounter[3] = data; break;
+        }
+
+        if (data == DONE)
+        {
+            SaveToDB();
+        }
+    }
+
+    uint32 GetData(uint32 type)
+    {
+        switch(type)
+        {
+            case TYPE_GARFROST:			    return m_auiEncounter[0];
+			case TYPE_TYRANNUS:			    return m_auiEncounter[1];
+			case TYPE_KRICK_AND_ICK:		return m_auiEncounter[2];
+            case TYPE_INTRO:                return m_auiEncounter[3];
+        }
+
+        return 0;
+    }
+
+    std::string GetSaveData()
+    {
+        OUT_SAVE_INST_DATA;
+
+        std::ostringstream saveStream;
+        saveStream << "P S " << m_auiEncounter[0] << " " << m_auiEncounter[1]  << " " << m_auiEncounter[2] << " " << m_auiEncounter[3];
+
+        str_data = saveStream.str();
+
+        OUT_SAVE_INST_DATA_COMPLETE;
+        return str_data;
+    }
+
+    void Load(const char* in)
+    {
+        if (!in)
+        {
+            OUT_LOAD_INST_DATA_FAIL;
+            return;
+        }
+
+        OUT_LOAD_INST_DATA(in);
+
+        char dataHead1, dataHead2;
+        uint16 data0, data1, data2, data3, data4;
+
+        std::istringstream loadStream(in);
+        loadStream >> dataHead1 >> dataHead2 >> data0 >> data1 >> data2 >> data3 >> data4;
+
+        if (dataHead1 == 'F' && dataHead2 == 'S')
+        {
+            m_auiEncounter[0] = data0;
+            m_auiEncounter[1] = data1;
+			m_auiEncounter[2] = data2;
+            m_auiEncounter[3] = data3;
+
+            for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+                if (m_auiEncounter[i] == IN_PROGRESS)
+                    m_auiEncounter[i] = NOT_STARTED;
+
+        } else OUT_LOAD_INST_DATA_FAIL;
+
+        OUT_LOAD_INST_DATA_COMPLETE;
+    }
+};
+
+InstanceData* GetInstanceData_instance_pit_of_saron(Map* pMap)
+{
+   return new instance_pit_of_saron(pMap);
+}
+
+void AddSC_instance_pit_of_saron()
+{
+   Script *newscript;
+   newscript = new Script;
+   newscript->Name = "instance_pit_of_saron";
+   newscript->GetInstanceData = &GetInstanceData_instance_pit_of_saron;
+   newscript->RegisterSelf();
+}
diff --git a/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/pit_of_saron.cpp b/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/pit_of_saron.cpp
new file mode 100644
index 0000000..b84f69a
--- /dev/null
+++ b/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/pit_of_saron.cpp
@@ -0,0 +1,1336 @@
+/* Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include "precompiled.h"
+#include "pit_of_saron.h"
+
+enum
+{
+    /***** SPELLS *****/
+    // Ymirjar Wrathbringer
+    SPELL_BLIGHT                        = 69603,
+    SPELL_BLIGHT_H                      = 70285,
+
+    //Ymirjar Skycaller
+    SPELL_FROSTBLADE                    = 70291,
+    SPELL_GLACIAL_STRIKE                = 70292,
+
+    //Ymirjar Flamebearer
+    SPELL_FIREBALL                      = 69583,
+    SPELL_FIREBALL_H                    = 70282,
+    SPELL_HELLFIRE                      = 69586,
+    SPELL_HELLFIRE_H                    = 70283,
+    SPELL_TACTICAL_BLINK                = 69584,
+
+    //Ymirjar Deathbringer
+    SPELL_EMPOWERED_SHADOW_BOLT         = 69528,
+    SPELL_EMPOWERED_SHADOW_BOLT_H       = 70281,
+    SPELL_SUMMON_UNDEAD                 = 69516,
+
+    //Wrathbone Laborer
+    SPELL_BLINDING_DIRT                 = 70302,
+    SPELL_PUNCTURE_WOUND                = 70278,
+    SPELL_PUNCTURE_WOUND_H              = 70279,
+    SPELL_SHOVELLED                     = 69572,
+    SPELL_SHOVELLED_H                   = 70280,
+
+    //Wrathbone Coldwraith
+    SPELL_FREEZING_CIRCLE               = 69574,
+    SPELL_FREEZING_CIRCLE_H             = 70276,
+    SPELL_FROSTBOLT                     = 69573,
+    SPELL_FROSTBOLT_H                   = 70277,
+
+    //Stonespine Gargoyle
+    SPELL_GARGOYLE_STRIKE               = 69520,
+    SPELL_GARGOYLE_STRIKE_H             = 70275,
+    SPELL_STONEFORM                     = 69575,
+
+    // Plagueborn Horror
+    SPELL_BLIGHT_BOMB                   = 69582,
+    SPELL_PUSTULANT_FLESH               = 69581,
+    SPELL_PUSTULANT_FLESH_H             = 70273,
+    SPELL_TOXIC_WASTE                   = 70274,
+
+    //Iceborn Proto-Drake
+    SPELL_FROST_BREATH                  = 69527,
+    SPELL_FROST_BREATH_H                = 70272,
+
+    //Hungering Ghoul
+    SPELL_DEVOUR_FLESH                  = 70393,
+
+    //Fallen Warrior
+    SPELL_ARCING_SLICE                  = 69579,
+    SPELL_DEMORALIZING_SHOUT            = 61044,
+    SPELL_SHIELD_BLOCK                  = 69580,
+
+    //Deathwhisper Torturer
+    SPELL_BLACK_BRAND                   = 70392,
+    SPELL_CURSE_OF_AGONY                = 70391,
+
+    //Deathwhisper Shadowcaster
+    SPELL_SHADOW_BOLT                   = 70386,
+    SPELL_SHADOW_BOLT_H                 = 70387,
+
+    //Deathwhisper Necrolyte
+    SPELL_CONVERSION_BEAM               = 69578,
+    SPELL_CONVERSION_BEAM_H             = 70269,
+    SPELL_SHADOW_BOLT_2                 = 69577,
+    SPELL_SHADOW_BOLT_2_H               = 70270,
+
+    //Wrathbone Sorcerer
+    SPELL_SHADOW_BOLT_3                 = 70386,
+    SPELL_SHADOW_BOLT_3_H               = 70387,
+
+    //Geist Ambusher
+    SPELL_LEAPING_FACE_MAUL             = 69504,
+    SPELL_LEAPING_FACE_MAUL_H           = 70271,
+
+    //Disturbed glacial revenant
+    SPELL_AVALANCHE                     = 55216,
+
+    ACHIEV_DONT_LOOK_UP                 = 4525, //needs script support -> area trigger and icicles
+};
+
+struct MANGOS_DLL_DECL npc_YmirjarWrathbringerAI : public ScriptedAI
+{
+    npc_YmirjarWrathbringerAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiBlightTimer;
+
+    void Reset()
+    {
+        m_uiBlightTimer = 7000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiBlightTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_BLIGHT : SPELL_BLIGHT_H);
+            m_uiBlightTimer = 8000;
+        }
+        else
+            m_uiBlightTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_YmirjarSkyCallerAI: public ScriptedAI
+{
+    npc_YmirjarSkyCallerAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiFrostBladeTimer;
+    uint32 m_uiGlacialStrikeTimer;
+
+    void Reset()
+    {
+        m_uiFrostBladeTimer = 1000;
+        m_uiGlacialStrikeTimer = 8000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiFrostBladeTimer < uiDiff)
+        {
+            //DoCast(m_creature, SPELL_FROSTBLADE);
+            m_uiFrostBladeTimer = 25000;
+        }
+        else
+            m_uiFrostBladeTimer -= uiDiff;
+
+        if (m_uiGlacialStrikeTimer < uiDiff)
+        {
+            //DoCast(m_creature->getVictim(), SPELL_GLACIAL_STRIKE);
+            m_uiGlacialStrikeTimer = 8000;
+        }
+        else
+            m_uiGlacialStrikeTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_YmirjarFlamebearerAI: public ScriptedAI
+{
+    npc_YmirjarFlamebearerAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiFireballTimer;
+    uint32 m_uiHellfireTimer;
+    uint32 m_uiTacticalBlinkTimer;
+
+    void Reset()
+    {
+        m_uiFireballTimer       = 4000;
+        m_uiHellfireTimer       = 8000;
+        m_uiTacticalBlinkTimer  = 15000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiFireballTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_FIREBALL : SPELL_FIREBALL_H);
+            m_uiFireballTimer = 5000;
+        }
+        else
+            m_uiFireballTimer -= uiDiff;
+
+        if (m_uiTacticalBlinkTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, SPELL_TACTICAL_BLINK);
+            m_uiTacticalBlinkTimer = 12000;
+        }
+        else
+            m_uiTacticalBlinkTimer -= uiDiff;
+
+        if (m_uiHellfireTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_HELLFIRE : SPELL_HELLFIRE_H);
+            m_uiHellfireTimer = 10000;
+        }
+        else
+            m_uiHellfireTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_YmirjarDeathbringerAI: public ScriptedAI
+{
+    npc_YmirjarDeathbringerAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiEmpoweredShadowBoltTimer;
+
+    void Reset()
+    {
+        m_uiEmpoweredShadowBoltTimer = 8000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiEmpoweredShadowBoltTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_EMPOWERED_SHADOW_BOLT : SPELL_EMPOWERED_SHADOW_BOLT_H);
+            m_uiEmpoweredShadowBoltTimer = 8000;
+        }
+        else
+            m_uiEmpoweredShadowBoltTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_WrathboneLaborerAI: public ScriptedAI
+{
+    npc_WrathboneLaborerAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiBlindingDirtTimer;
+    uint32 m_uiPunctureWoundTimer;
+    uint32 m_uiShovelledTimer;
+
+    void Reset()
+    {
+        m_uiBlindingDirtTimer   = 8000;
+        m_uiPunctureWoundTimer  = 9000;
+        m_uiShovelledTimer      = 5000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiBlindingDirtTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, SPELL_BLINDING_DIRT);
+            m_uiBlindingDirtTimer = 10000;
+        }
+        else
+            m_uiBlindingDirtTimer -= uiDiff;
+
+        if (m_uiPunctureWoundTimer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_PUNCTURE_WOUND : SPELL_PUNCTURE_WOUND_H);
+            m_uiPunctureWoundTimer = 9000;
+        }
+        else
+            m_uiPunctureWoundTimer -= uiDiff;
+
+        if (m_uiShovelledTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_SHOVELLED : SPELL_SHOVELLED_H);
+            m_uiShovelledTimer = 7000;
+        }
+        else
+            m_uiShovelledTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_WrathboneColdwraithAI: public ScriptedAI
+{
+    npc_WrathboneColdwraithAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiFreezingCircleTimer;
+    uint32 m_uiFrostboltTimer;
+
+    void Reset()
+    {
+        m_uiFreezingCircleTimer = 9000;
+        m_uiFrostboltTimer      = 5000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiFreezingCircleTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_FREEZING_CIRCLE : SPELL_FREEZING_CIRCLE_H);
+            m_uiFreezingCircleTimer = 9000;
+        }
+        else
+            m_uiFreezingCircleTimer -= uiDiff;
+
+        if (m_uiFrostboltTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_FROSTBOLT : SPELL_FROSTBOLT_H);
+            m_uiFrostboltTimer = 5000;
+        }
+        else
+            m_uiFrostboltTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_StonespineGargoyleAI: public ScriptedAI
+{
+    npc_StonespineGargoyleAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiGargoyleStrikeTimer;
+    bool m_bHasSkin;
+
+    void Reset()
+    {
+        m_uiGargoyleStrikeTimer = 5000;
+        m_bHasSkin  = false;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiGargoyleStrikeTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_GARGOYLE_STRIKE : SPELL_GARGOYLE_STRIKE_H);
+            m_uiGargoyleStrikeTimer = 6000;
+        }
+        else
+            m_uiGargoyleStrikeTimer -= uiDiff;
+
+        if(m_creature->GetHealthPercent() < 10 && !m_bHasSkin)
+        {
+            m_bHasSkin = true;
+            DoCast(m_creature, SPELL_STONEFORM);
+        }
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_PlaguebornHorrorAI: public ScriptedAI
+{
+    npc_PlaguebornHorrorAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    bool m_bHasBlightBomb;
+    uint32 m_uiPustulantFleshTimer;
+    uint32 m_uiToxicWasteTimer;
+
+    void Reset()
+    {
+        m_bHasBlightBomb        = false;
+        m_uiPustulantFleshTimer = 5000;
+        m_uiToxicWasteTimer     = 8000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiPustulantFleshTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_PUSTULANT_FLESH : SPELL_PUSTULANT_FLESH_H);
+            m_uiPustulantFleshTimer = 10000;
+        }
+        else
+            m_uiPustulantFleshTimer -= uiDiff;
+
+        if (m_uiToxicWasteTimer < uiDiff)
+        {
+            DoCast(m_creature, SPELL_TOXIC_WASTE);
+            m_uiToxicWasteTimer = 8000;
+        }
+        else
+            m_uiToxicWasteTimer -= uiDiff;
+
+        if(m_creature->GetHealthPercent() < 15 && !m_bHasBlightBomb)
+        {
+            m_bHasBlightBomb = true;
+            DoCast(m_creature, SPELL_BLIGHT_BOMB);
+        }
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_IcebornProtoDrakeAI: public ScriptedAI
+{
+    npc_IcebornProtoDrakeAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiFrostBreathTimer;
+
+    void Reset()
+    {
+        m_uiFrostBreathTimer = 5000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiFrostBreathTimer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_FROST_BREATH : SPELL_FROST_BREATH_H);
+            m_uiFrostBreathTimer = 10000;
+        }
+        else
+            m_uiFrostBreathTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_HungeringGhoulAI: public ScriptedAI
+{
+    npc_HungeringGhoulAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiDevourFleshTimer;
+
+    void Reset()
+    {
+        m_uiDevourFleshTimer = 4000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiDevourFleshTimer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_DEVOUR_FLESH);
+            m_uiDevourFleshTimer = 8000;
+        }
+        else
+            m_uiDevourFleshTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_FallenWarriorAI: public ScriptedAI
+{
+    npc_FallenWarriorAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiArcticSliceTimer;
+    uint32 m_uiDemoralizingShoutTimer;
+    uint32 m_uiShieldBlockTimer;
+
+    void Reset()
+    {
+        m_uiArcticSliceTimer        = 8000;
+        m_uiDemoralizingShoutTimer  = 20000;
+        m_uiShieldBlockTimer        = 8000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiArcticSliceTimer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_ARCING_SLICE);
+            m_uiArcticSliceTimer = 10000;
+        }
+        else
+            m_uiArcticSliceTimer -= uiDiff;
+
+        if (m_uiDemoralizingShoutTimer < uiDiff)
+        {
+            DoCast(m_creature, SPELL_DEMORALIZING_SHOUT);
+            m_uiDemoralizingShoutTimer = 20000;
+        }
+        else
+            m_uiDemoralizingShoutTimer -= uiDiff;
+
+        if (m_uiShieldBlockTimer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_SHIELD_BLOCK);
+            m_uiShieldBlockTimer = 8000;
+        }
+        else
+            m_uiShieldBlockTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_DeathwhisperTorturerAI: public ScriptedAI
+{
+    npc_DeathwhisperTorturerAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiBlackBrandTimer;
+    uint32 m_uiCurseOfAgonyTimer;
+
+    void Reset()
+    {
+        m_uiBlackBrandTimer     = 10000;
+        m_uiCurseOfAgonyTimer   = 6000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiBlackBrandTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, SPELL_BLACK_BRAND);
+            m_uiBlackBrandTimer = 10000;
+        }
+        else
+            m_uiBlackBrandTimer -= uiDiff;
+
+        if (m_uiCurseOfAgonyTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, SPELL_CURSE_OF_AGONY);
+            m_uiCurseOfAgonyTimer = 13000;
+        }
+        else
+            m_uiCurseOfAgonyTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_DeathwhisperShadowcasterAI: public ScriptedAI
+{
+    npc_DeathwhisperShadowcasterAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiShadowBoltTimer;
+
+    void Reset()
+    {
+        m_uiShadowBoltTimer = 3000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiShadowBoltTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_SHADOW_BOLT : SPELL_SHADOW_BOLT_H);
+            m_uiShadowBoltTimer = 5000;
+        }
+        else
+            m_uiShadowBoltTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_DeathwhisperNecrolyteAI: public ScriptedAI
+{
+    npc_DeathwhisperNecrolyteAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiConversionBeamTimer;
+    uint32 m_uiShadowBoltTimer;
+
+    void Reset()
+    {
+        m_uiConversionBeamTimer = 12000;
+        m_uiShadowBoltTimer     = 4000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiConversionBeamTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_CONVERSION_BEAM : SPELL_CONVERSION_BEAM_H);
+            m_uiConversionBeamTimer = 12000;
+        }
+        else
+            m_uiConversionBeamTimer -= uiDiff;
+
+
+        if (m_uiShadowBoltTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_SHADOW_BOLT_2 : SPELL_SHADOW_BOLT_2_H);
+            m_uiShadowBoltTimer = 5000;
+        }
+        else
+            m_uiShadowBoltTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_WrathboneSorcererAI: public ScriptedAI
+{
+    npc_WrathboneSorcererAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiShadowBoltTimer;
+
+    void Reset()
+    {
+        m_uiShadowBoltTimer = 3000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiShadowBoltTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_SHADOW_BOLT_3 : SPELL_SHADOW_BOLT_3_H);
+            m_uiShadowBoltTimer = 5000;
+        }
+        else
+            m_uiShadowBoltTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_GeistAmbusherAI: public ScriptedAI
+{
+    npc_GeistAmbusherAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiLeapingFaceMaulTimer;
+
+    void Reset()
+    {
+        m_uiLeapingFaceMaulTimer = 10000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiLeapingFaceMaulTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_LEAPING_FACE_MAUL : SPELL_LEAPING_FACE_MAUL_H);
+            m_uiLeapingFaceMaulTimer = 5000;
+        }
+        else
+            m_uiLeapingFaceMaulTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_disturbedGlacialRevenantAI: public ScriptedAI
+{
+    npc_disturbedGlacialRevenantAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiAvalancheTimer;
+
+    void Reset()
+    {
+        m_uiAvalancheTimer = 10000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiAvalancheTimer < uiDiff)
+        {
+            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, SPELL_AVALANCHE);
+            m_uiAvalancheTimer = 5000;
+        }
+        else
+            m_uiAvalancheTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+/******** JAINA & SYLVANAS *******/
+//Positional defines 
+struct LocationsXY
+{
+    float x, y, z, o;
+    uint32 id;
+};
+static LocationsXY SummonLoc[]=
+{
+    {445.941f, 199.304f, 528.707f},
+    {452.197f, 214.461f, 528.710f},
+    {444.204f, 232.011f, 528.710f},
+};
+
+static LocationsXY MoveLoc[]=
+{
+    {489.709f, 195.165f, 528.709f}, 
+    {482.365f, 221.354f, 528.709f}, 
+    {475.318f, 253.910f, 528.709f}, 
+};
+
+enum
+{
+    SAY_SPEECH_SYLVANAS1    = -1610047,
+    SAY_SPEECH_SYLVANAS2    = -1610048,
+    SAY_SPEECH_SYLVANAS3    = -1610049,
+    SAY_SPEECH_SYLVANAS4    = -1610050,
+
+    SAY_SPEECH_JAINA1       = -1610042,
+    SAY_SPEECH_JAINA2       = -1610043,
+    SAY_SPEECH_JAINA3       = -1610044,
+    SAY_SPEECH_JAINA4       = -1610045,
+    SAY_SPEECH_JAINA5       = -1610046,
+
+    SAY_TYRANNUS1           = -1610200,
+    SAY_TYRANNUS2           = -1610201,
+    SAY_TYRANNUS3           = -1610202,
+    SAY_TYRANNUS4           = -1610203,
+    SAY_TYRANNUS5           = -1610204, 
+    SPELL_NECROTIC_POWER    = 69347,
+};
+
+struct MANGOS_DLL_DECL npc_sylvanas_jaina_pos_startAI: public ScriptedAI
+{
+    npc_sylvanas_jaina_pos_startAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+
+    uint32 m_uiSpeech_Timer;
+    uint8 m_uiIntro_Phase;
+    bool m_bIsIntro;
+    uint32 creatureEntry;
+
+    uint64 m_uiTyrannusGuid;
+
+    void Reset()
+    {
+        m_uiIntro_Phase     = 0;
+        m_uiSpeech_Timer    = 1000;
+        m_bIsIntro          = false;
+        m_uiTyrannusGuid    = 0;
+        creatureEntry = m_creature->GetEntry();
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_INTRO, NOT_STARTED);
+    }
+
+    void MoveInLineOfSight(Unit* pWho)
+    {
+        if (pWho->isInAccessablePlaceFor(m_creature) && !m_bIsIntro && pWho->GetTypeId() == TYPEID_PLAYER && m_creature->IsWithinDistInMap(pWho, 50) && m_creature->IsWithinLOSInMap(pWho))
+        {
+            if(m_pInstance && m_creature->GetPositionZ() > 525.0f)
+                if(m_pInstance->GetData(TYPE_INTRO) != DONE)
+                {
+                    m_bIsIntro = true;
+                    m_uiSpeech_Timer = 5000;
+                }
+        }
+    }
+
+    void SummonHordeChampions()
+    {
+        for (uint8 i = 0; i < 5; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_CHAMPION_1_HORDE, SummonLoc[0].x + urand(0, 20), SummonLoc[0].y - urand(0, 20), SummonLoc[0].z, SummonLoc[0].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[0].x + urand(0, 40), MoveLoc[0].y - urand(0, 10), MoveLoc[0].z);
+        }
+
+        for (uint8 i = 5; i < 10; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_CHAMPION_2_HORDE, SummonLoc[1].x + urand(0, 20), SummonLoc[1].y + urand(0, 20), SummonLoc[1].z, SummonLoc[1].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[1].x + urand(0, 40), MoveLoc[1].y + urand(0, 40), MoveLoc[1].z);
+        }
+
+        for (uint8 i = 10; i < 15; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_CHAMPION_3_HORDE, SummonLoc[2].x + urand(0, 20), SummonLoc[2].y + urand(0, 20), SummonLoc[2].z, SummonLoc[2].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[1].x + urand(0, 40), MoveLoc[1].y + urand(0, 40), MoveLoc[1].z);
+        }
+    }
+
+    void SummonAlyChampions()
+    {
+        for (uint8 i = 0; i < 5; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_CHAMPION_1_ALLIANCE, SummonLoc[0].x + urand(0, 20), SummonLoc[0].y - urand(0, 20), SummonLoc[0].z, SummonLoc[0].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[0].x + urand(0, 40), MoveLoc[0].y - urand(0, 10), MoveLoc[0].z);
+        }
+
+        for (uint8 i = 5; i < 10; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_CHAMPION_2_ALLIANCE, SummonLoc[1].x + urand(0, 20), SummonLoc[1].y + urand(0, 20), SummonLoc[1].z, SummonLoc[1].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[1].x + urand(0, 40), MoveLoc[1].y + urand(0, 40), MoveLoc[1].z);
+        }
+
+        for (uint8 i = 10; i < 15; i++)
+        {
+            Creature *pTemp = m_creature->SummonCreature(NPC_CHAMPION_3_ALLIANCE, SummonLoc[2].x + urand(0, 20), SummonLoc[2].y + urand(0, 20), SummonLoc[2].z, SummonLoc[2].o, TEMPSUMMON_DEAD_DESPAWN, 0);
+            if (pTemp)
+                pTemp->GetMotionMaster()->MovePoint(0, MoveLoc[2].x + urand(0, 40), MoveLoc[2].y + urand(0, 40), MoveLoc[2].z);
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_bIsIntro)
+        {
+            if(m_uiSpeech_Timer < uiDiff)
+            {
+                switch(m_uiIntro_Phase)
+                {
+                case 0:
+                    if(m_pInstance)
+                        m_pInstance->SetData(TYPE_INTRO, IN_PROGRESS);
+
+                    if(Creature* pTyrannus = m_creature->SummonCreature(NPC_TYRANNUS_INTRO, 526.501f, 237.639f, 543.686f, 3.431f, TEMPSUMMON_TIMED_DESPAWN, 40000))
+                    {
+                        pTyrannus->GetMotionMaster()->MoveIdle();
+                        pTyrannus->SetUInt64Value(UNIT_FIELD_TARGET, m_creature->GetGUID());
+                        pTyrannus->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        pTyrannus->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                        pTyrannus->SetUInt32Value(UNIT_FIELD_BYTES_0, 50331648);
+                        pTyrannus->SetUInt32Value(UNIT_FIELD_BYTES_1, 50331648);
+                        pTyrannus->GetMotionMaster()->MoveIdle();
+                        pTyrannus->GetMap()->CreatureRelocation(pTyrannus, 526.501f, 237.639f, 543.686f, 3.431f);
+                        pTyrannus->SendMonsterMove(526.501f, 237.639f, 543.686f, SPLINETYPE_NORMAL, pTyrannus->GetSplineFlags(), 1);
+                        DoScriptText(SAY_TYRANNUS1, pTyrannus);
+                        m_uiTyrannusGuid = pTyrannus->GetGUID();
+                    }
+
+                    switch (creatureEntry)
+                    {
+                    case NPC_JAINA_START:
+                        SummonAlyChampions();
+                        break;
+                    case NPC_SYLVANAS_START:
+                        SummonHordeChampions();
+                        break;
+                    }
+                    ++m_uiIntro_Phase;
+                    m_uiSpeech_Timer = 7000;
+                    break;
+                case 1:
+                    switch (creatureEntry)
+                    {
+                    case NPC_JAINA_START:
+                        DoScriptText(SAY_SPEECH_JAINA1, m_creature);
+                        break;
+                    case NPC_SYLVANAS_START:
+                        DoScriptText(SAY_SPEECH_SYLVANAS1, m_creature);
+                        break;
+                    }
+                    ++m_uiIntro_Phase;
+                    m_uiSpeech_Timer = 7000;
+                    break;
+                case 2:
+                    if(Creature* pTyrannus = m_pInstance->instance->GetCreature(m_uiTyrannusGuid))
+                        DoScriptText(SAY_TYRANNUS2, pTyrannus);
+                    ++m_uiIntro_Phase;
+                    m_uiSpeech_Timer = 13000;
+                    break;
+                case 3:
+                    if(Creature* pTyrannus = m_pInstance->instance->GetCreature(m_uiTyrannusGuid))
+                        DoScriptText(SAY_TYRANNUS3, pTyrannus);
+                    ++m_uiIntro_Phase;
+                    m_uiSpeech_Timer = 5000;
+                    break;
+                case 4:
+                    if(Creature* pTyrannus = m_pInstance->instance->GetCreature(m_uiTyrannusGuid))
+                    {
+                        pTyrannus->CastSpell(m_creature, SPELL_NECROTIC_POWER, false);
+                        DoScriptText(SAY_TYRANNUS4, pTyrannus);
+                    }
+                    switch (creatureEntry)
+                    {
+                    case NPC_JAINA_START:
+                        DoScriptText(SAY_SPEECH_JAINA2, m_creature);
+                        break;
+                    case NPC_SYLVANAS_START:
+                        DoScriptText(SAY_SPEECH_SYLVANAS2, m_creature);
+                        break;
+                    }
+                    ++m_uiIntro_Phase;
+                    m_uiSpeech_Timer = 5000;
+                    break;
+                case 5:
+                    if(Creature* pTyrannus = m_pInstance->instance->GetCreature(m_uiTyrannusGuid))
+                        DoScriptText(SAY_TYRANNUS5, pTyrannus);
+                    ++m_uiIntro_Phase;
+                    m_uiSpeech_Timer = 5000;
+                    break;
+                case 6:
+                    switch (creatureEntry)
+                    {
+                    case NPC_JAINA_START:
+                        DoScriptText(SAY_SPEECH_JAINA3, m_creature);
+                        m_uiSpeech_Timer = 5000;
+                        break;
+                    case NPC_SYLVANAS_START:
+                        m_uiSpeech_Timer = 500;
+                        break;
+                    }
+                    ++m_uiIntro_Phase;
+                    break;
+                case 7:
+                    switch (creatureEntry)
+                    {
+                    case NPC_JAINA_START:
+                        DoScriptText(SAY_SPEECH_JAINA4, m_creature);
+                        break;
+                    case NPC_SYLVANAS_START:
+                        DoScriptText(SAY_SPEECH_SYLVANAS3, m_creature);
+                        break;
+                    }
+                    ++m_uiIntro_Phase;
+                    m_uiSpeech_Timer = 7000;
+                    break;
+                case 8:
+                    switch (creatureEntry)
+                    {
+                    case NPC_JAINA_START:
+                        DoScriptText(SAY_SPEECH_JAINA5, m_creature);
+                        break;
+                    case NPC_SYLVANAS_START:
+                        DoScriptText(SAY_SPEECH_SYLVANAS4, m_creature);
+                        break;
+                    }
+                    if(m_pInstance)
+                        m_pInstance->SetData(TYPE_INTRO,DONE);
+                    ++m_uiIntro_Phase;
+                    m_bIsIntro = false;
+                    m_uiSpeech_Timer = 10000;
+                    break;
+
+                default:
+                    m_uiSpeech_Timer = 100000;
+                }
+            }else m_uiSpeech_Timer -= uiDiff;
+        }
+    }
+};
+
+CreatureAI* GetAI_npc_YmirjarWrathbringerAI(Creature* pCreature)
+{
+    return new npc_YmirjarWrathbringerAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_YmirjarSkyCallerAI(Creature* pCreature)
+{
+    return new npc_YmirjarSkyCallerAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_YmirjarFlamebearerAI(Creature* pCreature)
+{
+    return new npc_YmirjarFlamebearerAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_YmirjarDeathbringerAI(Creature* pCreature)
+{
+    return new npc_YmirjarDeathbringerAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_WrathboneLaborerAI(Creature* pCreature)
+{
+    return new npc_WrathboneLaborerAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_WrathboneColdwraithAI(Creature* pCreature)
+{
+    return new npc_WrathboneColdwraithAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_StonespineGargoyleAI(Creature* pCreature)
+{
+    return new npc_StonespineGargoyleAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_PlaguebornHorrorAI(Creature* pCreature)
+{
+    return new npc_PlaguebornHorrorAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_IcebornProtoDrakeAI(Creature* pCreature)
+{
+    return new npc_IcebornProtoDrakeAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_HungeringGhoulAI(Creature* pCreature)
+{
+    return new npc_HungeringGhoulAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_FallenWarriorAI(Creature* pCreature)
+{
+    return new npc_FallenWarriorAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_DeathwhisperTorturerAI(Creature* pCreature)
+{
+    return new npc_DeathwhisperTorturerAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_DeathwhisperShadowcasterAI(Creature* pCreature)
+{
+    return new npc_DeathwhisperShadowcasterAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_DeathwhisperNecrolyteAI(Creature* pCreature)
+{
+    return new npc_DeathwhisperNecrolyteAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_WrathboneSorcererAI(Creature* pCreature)
+{
+    return new npc_WrathboneSorcererAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_GeistAmbusherAI(Creature* pCreature)
+{
+    return new npc_GeistAmbusherAI (pCreature);
+}
+
+CreatureAI* GetAI_npc_disturbedGlacialRevenant(Creature* pCreature)
+{
+    return new npc_disturbedGlacialRevenantAI (pCreature);
+}
+
+
+CreatureAI* GetAI_npc_sylvanas_jaina_pos_start(Creature* pCreature)
+{
+    return new npc_sylvanas_jaina_pos_startAI (pCreature);
+}
+
+void AddSC_Pit_Of_Saron()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name="npc_YmirjarWrathbringer";
+    newscript->GetAI = &GetAI_npc_YmirjarWrathbringerAI;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="npc_YmirjarSkycaller";
+    newscript->GetAI = &GetAI_npc_YmirjarSkyCallerAI;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="npc_YmirjarFlamebearer";
+    newscript->GetAI = &GetAI_npc_YmirjarFlamebearerAI;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="npc_YmirjarDeathbringer";
+    newscript->GetAI = &GetAI_npc_YmirjarDeathbringerAI;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="npc_WrathboneLaborer";
+    newscript->GetAI = &GetAI_npc_WrathboneLaborerAI;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="npc_WrathboneColdwraith";
+    newscript->GetAI = &GetAI_npc_WrathboneColdwraithAI;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="npc_StonespineGargoyle";
+    newscript->GetAI = &GetAI_npc_StonespineGargoyleAI;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="npc_PlaguebornHorror";
+    newscript->GetAI = &GetAI_npc_PlaguebornHorrorAI;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="npc_IcebornProtoDrake";
+    newscript->GetAI = &GetAI_npc_IcebornProtoDrakeAI;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="npc_HungeringGhoul";
+    newscript->GetAI = &GetAI_npc_HungeringGhoulAI;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="npc_FallenWarrior";
+    newscript->GetAI = &GetAI_npc_FallenWarriorAI;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="npc_DeathwhisperTorturer";
+    newscript->GetAI = &GetAI_npc_DeathwhisperTorturerAI;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="npc_DeathwhisperShadowcaster";
+    newscript->GetAI = &GetAI_npc_DeathwhisperShadowcasterAI;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="npc_DeathwhisperNecrolyte";
+    newscript->GetAI = &GetAI_npc_DeathwhisperNecrolyteAI;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="npc_WrathboneSorcerer";
+    newscript->GetAI = &GetAI_npc_WrathboneSorcererAI;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="npc_GeistAmbusher";
+    newscript->GetAI = &GetAI_npc_GeistAmbusherAI;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name="npc_disturbedGlacialRevenant";
+    newscript->GetAI = &GetAI_npc_disturbedGlacialRevenant;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->GetAI = &GetAI_npc_sylvanas_jaina_pos_start;
+    newscript->Name = "npc_slyvanas_jaina_pos_start";
+    newscript->RegisterSelf();
+}
\ No newline at end of file
diff --git a/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/pit_of_saron.h b/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/pit_of_saron.h
new file mode 100644
index 0000000..fc1d272
--- /dev/null
+++ b/scripts/northrend/icecrown_citadel/frozen_halls/pit_of_saron/pit_of_saron.h
@@ -0,0 +1,53 @@
+/* Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software licensed under GPL version 2
+ * Please see the included DOCS/LICENSE.TXT for more information */
+
+#ifndef DEF_ICECROWN_H
+#define DEF_ICECROWN_H
+
+enum
+{
+    NPC_SLYVANAS_PART1             = 36990,
+    NPC_SLYVANAS_PART2             = 38189,
+    NPC_JAINA_PART1                = 36993,
+    NPC_JAINA_PART2                = 38188,
+    NPC_KALIRA                     = 37583,
+    NPC_LORALEN                    = 37779,
+    NPC_ELANDRA                    = 37774,
+    NPC_KORELN                     = 37582,
+    NPC_CHAMPION_1_HORDE           = 37584,
+    NPC_CHAMPION_2_HORDE           = 37587,
+    NPC_CHAMPION_3_HORDE           = 37588,
+    NPC_CHAMPION_1_ALLIANCE        = 37496,
+    NPC_CHAMPION_2_ALLIANCE        = 37497,
+    NPC_CHAMPION_3_ALLIANCE        = 37498,
+
+    NPC_SLAVE_HORDE_1               = 37578,
+    NPC_SLAVE_HORDE_2               = 37577,
+    NPC_SLAVE_HORDE_3               = 37579,
+    NPC_SLAVE_ALY_1                 = 37572,
+    NPC_SLAVE_ALY_2                 = 37575,
+    NPC_SLAVE_ALY_3                 = 37576,
+
+    NPC_JAINA_START                 = 36993,
+    NPC_JAINA_END                   = 38188,
+    NPC_SYLVANAS_START              = 36990,
+    NPC_SYLVANAS_END                = 38189,
+    NPC_MARTIN_VICTUS_SLAVE         = 37591, 
+    NPC_MARTIN_VICTUS_END           = 37580,
+    NPC_GORKUN_IRONSKULL_SLAVE      = 37592,
+    NPC_GORKUN_IRONSKULL_END        = 37581,
+
+    NPC_GARFROST                    = 36494,
+    NPC_KRICK                       = 36477,
+    NPC_ICK                         = 36476,
+    NPC_TYRANNUS                    = 36658,
+    NPC_RIMEFANG                    = 36661,
+    NPC_TYRANNUS_INTRO              = 36794,
+
+    TYPE_GARFROST                  = 1,
+    TYPE_TYRANNUS                  = 2,
+    TYPE_KRICK_AND_ICK             = 3,
+    TYPE_INTRO                     = 4,
+};
+#endif
diff --git a/system/ScriptLoader.cpp b/system/ScriptLoader.cpp
index 375291f..87f3ffd 100644
--- a/system/ScriptLoader.cpp
+++ b/system/ScriptLoader.cpp
@@ -279,6 +279,11 @@ extern void AddSC_boss_Bronjahn();                          //icecrown citadel -
 extern void AddSC_boss_Devourer_Of_Souls();
 extern void AddSC_Forge_Of_Souls();                         
 extern void AddSC_instance_forge_of_souls();
+extern void AddSC_boss_Garfrost();                          //icecrown citadel - frozen halls - pit of saron
+extern void AddSC_boss_Ick_and_Krick();
+extern void AddSC_boss_Tyrannus();
+extern void AddSC_instance_pit_of_saron();
+extern void AddSC_Pit_Of_Saron();
 extern void AddSC_boss_anubrekhan();                        //naxxramas
 extern void AddSC_boss_four_horsemen();
 extern void AddSC_boss_faerlina();
@@ -703,6 +708,11 @@ void AddScripts()
     AddSC_boss_Devourer_Of_Souls();
     AddSC_Forge_Of_Souls();                                
     AddSC_instance_forge_of_souls();
+	AddSC_boss_Garfrost();                                  //icecrown citadel - frozen halls - pit of saron
+    AddSC_boss_Ick_and_Krick();
+    AddSC_boss_Tyrannus();
+    AddSC_instance_pit_of_saron();
+    AddSC_Pit_Of_Saron();
     AddSC_boss_anubrekhan();                                //naxxramas
     AddSC_boss_four_horsemen();
     AddSC_boss_faerlina();
