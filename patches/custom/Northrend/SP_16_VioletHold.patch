diff --git a/Makefile.am b/Makefile.am
index 934211f..839898c 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -443,6 +443,13 @@ scripts/northrend/utgarde_keep/utgarde_pinnacle/boss_svala.cpp \
 scripts/northrend/utgarde_keep/utgarde_pinnacle/boss_ymiron.cpp \
 scripts/northrend/utgarde_keep/utgarde_pinnacle/instance_utgarde_pinnacle.cpp \
 scripts/northrend/utgarde_keep/utgarde_pinnacle/utgarde_pinnacle.h \
+scripts/northrend/violet_hold/boss_cyanigosa.cpp \
+scripts/northrend/violet_hold/boss_erekem.cpp \
+scripts/northrend/violet_hold/boss_ichoron.cpp \
+scripts/northrend/violet_hold/boss_lavanthor.cpp \
+scripts/northrend/violet_hold/boss_moragg.cpp \
+scripts/northrend/violet_hold/boss_xevozz.cpp \
+scripts/northrend/violet_hold/boss_zuramat.cpp \
 scripts/northrend/violet_hold/instance_violet_hold.cpp \
 scripts/northrend/violet_hold/violet_hold.cpp \
 scripts/northrend/violet_hold/violet_hold.h \
diff --git a/VC90/90ScriptDev2.vcproj b/VC90/90ScriptDev2.vcproj
index 3d80d66..53ad302 100644
--- a/VC90/90ScriptDev2.vcproj
+++ b/VC90/90ScriptDev2.vcproj
@@ -2115,6 +2115,34 @@
 					Name="violet_hold"
 					>
 					<File
+						RelativePath="..\scripts\northrend\violet_hold\boss_cyanigosa.cpp"
+						>
+					</File>
+					<File
+						RelativePath="..\scripts\northrend\violet_hold\boss_erekem.cpp"
+						>
+					</File>
+					<File
+						RelativePath="..\scripts\northrend\violet_hold\boss_ichoron.cpp"
+						>
+					</File>
+					<File
+						RelativePath="..\scripts\northrend\violet_hold\boss_lavanthor.cpp"
+						>
+					</File>
+					<File
+						RelativePath="..\scripts\northrend\violet_hold\boss_moragg.cpp"
+						>
+					</File>
+					<File
+						RelativePath="..\scripts\northrend\violet_hold\boss_xevozz.cpp"
+						>
+					</File>
+					<File
+						RelativePath="..\scripts\northrend\violet_hold\boss_zuramat.cpp"
+						>
+					</File>
+					<File
 						RelativePath="..\scripts\northrend\violet_hold\instance_violet_hold.cpp"
 						>
 					</File>
diff --git a/scripts/northrend/violet_hold/boss_cyanigosa.cpp b/scripts/northrend/violet_hold/boss_cyanigosa.cpp
new file mode 100644
index 0000000..25a2c52
--- /dev/null
+++ b/scripts/northrend/violet_hold/boss_cyanigosa.cpp
@@ -0,0 +1,197 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* ScriptData
+SDName: boss_cyanigosa
+SDAuthor: ckegg
+SD%Complete: 0
+SDComment: 
+SDCategory: The Violet Hold
+EndScriptData */
+
+#include "precompiled.h"
+#include "violet_hold.h"
+
+enum
+{
+    SAY_AGGRO                                 = -1608050,
+    SAY_SLAY_1                                = -1608051,
+    SAY_SLAY_2                                = -1608052,
+    SAY_SLAY_3                                = -1608053,
+    SAY_DEATH                                 = -1608054,
+    SAY_SPAWN                                 = -1608055,
+    SAY_DISRUPTION                            = -1608056,
+    SAY_BREATH_ATTACK                         = -1608057,
+    SAY_SPECIAL_ATTACK_1                      = -1608058,
+    SAY_SPECIAL_ATTACK_2                      = -1608059,
+
+    SPELL_ARCANE_VACUM                        = 58694,
+    SPELL_BLIZZARD                            = 58693,
+    SPELL_BLIZZARD_H                          = 59369,
+    SPELL_MANA_DESTRUCTION                    = 59374,
+    SPELL_TAIL_SWEEP                          = 58690,
+    SPELL_TAIL_SWEEP_H                        = 59283,
+    SPELL_UNCONTROLLABLE_ENERGY               = 58688,
+    SPELL_UNCONTROLLABLE_ENERGY_H             = 59281,
+    SPELL_CYANIGOSA_TRANSFORM                 = 58668,
+};
+
+struct MANGOS_DLL_DECL boss_cyanigosaAI : public ScriptedAI
+{
+    boss_cyanigosaAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = ((ScriptedInstance*)pCreature->GetInstanceData());
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        pCreature->setFaction(35);
+        pCreature->SetVisibility(VISIBILITY_OFF);
+        Reset();
+    }
+    ScriptedInstance *m_pInstance;
+
+    bool m_bIsRegularMode;
+
+    uint32 m_uiTailSweep_Timer;
+    uint32 m_uiManaDestruction_Timer;
+    uint32 m_uiBlizzard_Timer;
+    uint32 m_uiUncontrollableEnergy_Timer;
+    uint32 m_uiArcaneVacuum_Timer;
+    uint32 m_uiSpeechTimer;
+    bool MovementStarted;
+
+    void Reset()
+    {
+        m_uiUncontrollableEnergy_Timer = urand(15000, 16000);
+        m_uiManaDestruction_Timer = urand(5000, 6000);
+        m_uiBlizzard_Timer = urand(20000, 25000);
+        m_uiTailSweep_Timer = urand(10000, 11000);
+        m_uiArcaneVacuum_Timer = urand(28000, 33000);
+        m_uiSpeechTimer = 40000;
+        MovementStarted = false;
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        DoScriptText(SAY_AGGRO, m_creature);
+        DoCast(m_creature, SPELL_CYANIGOSA_TRANSFORM);
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiUncontrollableEnergy_Timer < uiDiff)
+        {
+            DoScriptText(SAY_BREATH_ATTACK, m_creature);
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_UNCONTROLLABLE_ENERGY_H : SPELL_UNCONTROLLABLE_ENERGY);
+            m_uiUncontrollableEnergy_Timer = urand(15000, 16000);
+        }
+        else
+            m_uiUncontrollableEnergy_Timer -= uiDiff;
+
+        if (m_uiManaDestruction_Timer < uiDiff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, SPELL_MANA_DESTRUCTION);
+            m_uiManaDestruction_Timer = urand(8000, 13000);
+        }
+        else
+            m_uiManaDestruction_Timer -= uiDiff;
+
+        if (m_uiBlizzard_Timer < uiDiff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_BLIZZARD_H : SPELL_BLIZZARD);
+            m_uiBlizzard_Timer = urand(20000, 25000);
+        }
+        else
+            m_uiBlizzard_Timer -= uiDiff;
+
+        if (m_uiArcaneVacuum_Timer < uiDiff)
+        {
+            DoCast(m_creature, SPELL_ARCANE_VACUM);
+            DoResetThreat();
+            m_uiArcaneVacuum_Timer = urand(28000, 33000);
+        }
+        else
+            m_uiArcaneVacuum_Timer -= uiDiff;
+
+        if (m_uiTailSweep_Timer < uiDiff)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_TAIL_SWEEP_H : SPELL_TAIL_SWEEP);
+            m_uiTailSweep_Timer = urand(10000, 11000);
+        }
+        else
+            m_uiTailSweep_Timer -= uiDiff;
+
+        if (m_uiSpeechTimer < uiDiff)
+        {
+            switch(urand(0, 1))
+            {
+            case 0: DoScriptText(SAY_SPECIAL_ATTACK_1, m_creature);break;
+            case 1: DoScriptText(SAY_SPECIAL_ATTACK_2, m_creature);break;
+            }
+            m_uiSpeechTimer = urand(30000, 50000);
+        }
+        else
+            m_uiSpeechTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        DoScriptText(SAY_DEATH, m_creature);
+
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_RIFT, DONE);
+            m_pInstance->SetData(TYPE_EVENT, DONE);
+
+            if (Creature* pSinclari = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_SINCLARI))))
+            {
+                if (pSinclari->isAlive())
+                    pSinclari->SetUInt32Value(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_NONE);
+            }
+        }
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        switch(urand(0, 2))
+        {
+            case 0: DoScriptText(SAY_SLAY_1, m_creature);break;
+            case 1: DoScriptText(SAY_SLAY_2, m_creature);break;
+            case 2: DoScriptText(SAY_SLAY_3, m_creature);break;
+        }
+    }
+};
+
+CreatureAI* GetAI_boss_cyanigosa(Creature* pCreature)
+{
+    return new boss_cyanigosaAI (pCreature);
+}
+
+void AddSC_boss_cyanigosa()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "boss_cyanigosa";
+    newscript->GetAI = &GetAI_boss_cyanigosa;
+    newscript->RegisterSelf();
+}
diff --git a/scripts/northrend/violet_hold/boss_erekem.cpp b/scripts/northrend/violet_hold/boss_erekem.cpp
new file mode 100644
index 0000000..dfb674b
--- /dev/null
+++ b/scripts/northrend/violet_hold/boss_erekem.cpp
@@ -0,0 +1,352 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* ScriptData
+SDName: boss_erekem
+SDAuthor: ckegg
+SD%Complete: 0
+SDComment: 
+SDCategory: The Violet Hold
+EndScriptData */
+
+#include "precompiled.h"
+#include "violet_hold.h"
+
+enum
+{
+    SAY_AGGRO                                 = -1608010,
+    SAY_SLAY_1                                = -1608011,
+    SAY_SLAY_2                                = -1608012,
+    SAY_SLAY_3                                = -1608013,
+    SAY_DEATH                                 = -1608014,
+    SAY_SPAWN                                 = -1608015,
+    SAY_ADD_KILED                             = -1608016,
+    SAY_BOTH_ADDS_KILED                       = -1608017,
+
+    SPELL_BLOODLUST                           = 54516,
+    SPELL_BREAK_BONDS                         = 59463,
+    SPELL_CHAIN_HEAL                          = 54481,
+    SPELL_CHAIN_HEAL_H                        = 59473,
+    SPELL_EARTH_SHIELD                        = 54479,
+    SPELL_EARTH_SHIELD_H                      = 59471,
+    SPELL_EARTH_SHOCK                         = 54511,
+    SPELL_LIGHTNING_BOLT                      = 53044,
+    SPELL_STORMSTRIKE                         = 51876,
+
+    SPELL_GUSHING_WOUND                       = 39215,
+    SPELL_HOWLING_SCREECH                     = 54462,
+    SPELL_STRIKE                              = 14516,
+};
+
+struct MANGOS_DLL_DECL boss_erekemAI : public ScriptedAI
+{
+    boss_erekemAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = ((ScriptedInstance*)pCreature->GetInstanceData());
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+    ScriptedInstance *m_pInstance;
+
+    bool m_bIsRegularMode;
+    bool m_bIsAddDead;
+    bool MovementStarted;
+
+    uint32 m_uiBloodlust_Timer;
+    uint32 m_uiBreakBonds_Timer;
+    uint32 m_uiChainHeal_Timer;
+    uint32 m_uiEarthShield_Timer;
+    uint32 m_uiEarthShock_Timer;
+    uint32 m_uiLightningBolt_Timer;
+    uint32 m_uiStormstrike_Timer;
+
+    void Reset()
+    {
+        m_bIsAddDead = false;
+        MovementStarted = false;
+        m_uiLightningBolt_Timer = 2000;
+        m_uiEarthShield_Timer = urand(15000, 20000);
+        m_uiEarthShock_Timer = urand(12000, 17000);
+        m_uiChainHeal_Timer = urand(5000, 25000);
+        m_uiBreakBonds_Timer = urand(25000, 30000);
+        m_uiBloodlust_Timer = urand(60000, 65000);
+        m_uiStormstrike_Timer = urand(1000, 2000);
+
+        std::list<Creature*> lUnitList;
+        GetCreatureListWithEntryInGrid(lUnitList, m_creature, NPC_EREKEM_GUARD, 100.0f);
+        if (!lUnitList.empty())
+            for(std::list<Creature*>::iterator iter = lUnitList.begin(); iter != lUnitList.end(); ++iter)
+                if ((*iter))
+                    if ((*iter)->isDead())
+                        (*iter)->Respawn();
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_EREKEM, NOT_STARTED);
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        DoScriptText(SAY_AGGRO, m_creature);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_EREKEM, IN_PROGRESS);
+
+    }
+
+    void AttackStart(Unit* pWho)
+    {
+        if (!m_pInstance)
+            return;
+
+        if (m_pInstance->GetData(TYPE_EREKEM) != SPECIAL && m_pInstance->GetData(TYPE_EREKEM) != IN_PROGRESS)
+            return;
+
+        if (!pWho || pWho == m_creature)
+            return;
+
+        if (m_creature->Attack(pWho, true))
+        {
+            m_creature->AddThreat(pWho, 0.0f);
+            m_creature->SetInCombatWith(pWho);
+            pWho->SetInCombatWith(m_creature);
+            DoStartMovement(pWho);
+
+            std::list<Creature*> lUnitList;
+            GetCreatureListWithEntryInGrid(lUnitList, m_creature, NPC_EREKEM_GUARD, 100.0f);
+            if (!lUnitList.empty())
+                for(std::list<Creature*>::iterator iter = lUnitList.begin(); iter != lUnitList.end(); ++iter)
+                    if (*iter)
+                        if ((*iter)->isAlive())
+                        {
+                            (*iter)->AddThreat(pWho, 0.0f);
+                            (*iter)->AI()->AttackStart(pWho);
+                        }
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_pInstance->GetData(TYPE_EREKEM) == SPECIAL && !MovementStarted) {
+	m_creature->GetMotionMaster()->MovePoint(0, PortalLoc[0].x, PortalLoc[0].y, PortalLoc[0].z);
+        m_creature->AddSplineFlag(SPLINEFLAG_WALKMODE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        MovementStarted = true;
+        }
+
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiEarthShield_Timer < uiDiff)
+        {
+            m_creature->InterruptNonMeleeSpells(false);
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_EARTH_SHIELD_H : SPELL_EARTH_SHIELD);
+            m_uiEarthShield_Timer = urand(15000, 20000);
+        }
+        else m_uiEarthShield_Timer -= uiDiff;
+
+        if (m_uiEarthShock_Timer < uiDiff)
+        {
+            m_creature->InterruptNonMeleeSpells(false);
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, SPELL_EARTH_SHOCK);
+            m_uiEarthShock_Timer = urand(12000, 17000);
+        }
+        else m_uiEarthShock_Timer -= uiDiff;
+
+        if (m_uiChainHeal_Timer < uiDiff)
+        {
+            //m_creature->InterruptNonMeleeSpells(false);
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_CHAIN_HEAL_H : SPELL_CHAIN_HEAL);
+            m_uiChainHeal_Timer = urand(5000, 25000);
+        }
+        else m_uiChainHeal_Timer -= uiDiff;
+
+        if (m_uiBreakBonds_Timer < uiDiff)
+        {
+            m_creature->InterruptNonMeleeSpells(false);
+            DoCast(m_creature, SPELL_BREAK_BONDS);
+            m_uiBreakBonds_Timer = urand(25000, 30000);
+        }
+        else m_uiBreakBonds_Timer -= uiDiff;
+
+        if (!m_bIsAddDead)
+        {
+            if (m_uiLightningBolt_Timer < uiDiff)
+            {
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                    DoCast(pTarget, SPELL_LIGHTNING_BOLT);
+                m_uiLightningBolt_Timer = 2000;
+            }
+            else m_uiLightningBolt_Timer -= uiDiff;
+        }
+        else
+        {
+            if (m_uiStormstrike_Timer < uiDiff)
+            {
+                DoCast(m_creature->getVictim(), SPELL_STORMSTRIKE);
+                m_uiStormstrike_Timer = 1000;
+            }
+            else m_uiStormstrike_Timer -= uiDiff;
+
+            DoMeleeAttackIfReady();
+        }
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        DoScriptText(SAY_DEATH, m_creature);
+
+        if (m_pInstance) m_pInstance->SetData(TYPE_EREKEM, DONE);
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        switch(urand(0, 2))
+        {
+            case 0: DoScriptText(SAY_SLAY_1, m_creature);break;
+            case 1: DoScriptText(SAY_SLAY_2, m_creature);break;
+            case 2: DoScriptText(SAY_SLAY_3, m_creature);break;
+        }
+    }
+};
+
+struct MANGOS_DLL_DECL mob_erekem_guardAI : public ScriptedAI
+{
+    mob_erekem_guardAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = ((ScriptedInstance*)pCreature->GetInstanceData());
+        Reset();
+    }
+    ScriptedInstance *m_pInstance;
+
+    uint32 m_uiGushingWound_Timer;
+    uint32 m_uiHowlingScreech_Timer;
+    uint32 m_uiStrike_Timer;
+    bool MovementStarted;
+
+    void Reset()
+    {
+        m_uiGushingWound_Timer = urand(5000, 10000);
+        m_uiHowlingScreech_Timer = urand(12000, 15000);
+        m_uiStrike_Timer = urand(10000, 11000);
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        MovementStarted = false;
+
+    }
+
+    void AttackStart(Unit* pWho)
+    {
+        if (!m_pInstance)
+            return;
+
+        if (m_pInstance->GetData(TYPE_EREKEM) != SPECIAL && m_pInstance->GetData(TYPE_EREKEM) != IN_PROGRESS)
+            return;
+
+
+        if (!pWho || pWho == m_creature)
+            return;
+
+        if (m_creature->Attack(pWho, true))
+        {
+            m_creature->AddThreat(pWho, 0.0f);
+            m_creature->SetInCombatWith(pWho);
+            pWho->SetInCombatWith(m_creature);
+            DoStartMovement(pWho);
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_pInstance->GetData(TYPE_EREKEM) == SPECIAL && !MovementStarted) {
+        m_creature->GetMotionMaster()->MovePoint(0, PortalLoc[0].x, PortalLoc[0].y, PortalLoc[0].z);
+        m_creature->AddSplineFlag(SPLINEFLAG_WALKMODE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        MovementStarted = true;
+        }
+
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiGushingWound_Timer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_GUSHING_WOUND);
+            m_uiGushingWound_Timer = urand(30000, 32000);
+        }
+        else m_uiGushingWound_Timer -= uiDiff;
+
+        if (m_uiHowlingScreech_Timer < uiDiff)
+        {
+            DoCast(m_creature, SPELL_HOWLING_SCREECH);
+            m_uiHowlingScreech_Timer = urand(24000, 30000);
+        }
+        else m_uiHowlingScreech_Timer -= uiDiff;
+
+        if (m_uiStrike_Timer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_STRIKE);
+            m_uiStrike_Timer = urand(15000, 16000);
+        }
+        else m_uiStrike_Timer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        if (m_pInstance)
+            if (Creature* pErekem = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_EREKEM))))
+                if (pErekem->isAlive())
+                {
+                    DoScriptText(SAY_ADD_KILED, pErekem);
+                    pErekem->InterruptNonMeleeSpells(false);
+                    pErekem->CastSpell(pErekem, SPELL_BLOODLUST, false);
+                    ((boss_erekemAI*)pErekem->AI())->m_bIsAddDead = true;
+                }
+    }
+};
+
+CreatureAI* GetAI_boss_erekem(Creature* pCreature)
+{
+    return new boss_erekemAI (pCreature);
+}
+
+CreatureAI* GetAI_mob_erekem_guard(Creature* pCreature)
+{
+    return new mob_erekem_guardAI (pCreature);
+}
+
+void AddSC_boss_erekem()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "boss_erekem";
+    newscript->GetAI = &GetAI_boss_erekem;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_erekem_guard";
+    newscript->GetAI = &GetAI_mob_erekem_guard;
+    newscript->RegisterSelf();
+}
diff --git a/scripts/northrend/violet_hold/boss_ichoron.cpp b/scripts/northrend/violet_hold/boss_ichoron.cpp
new file mode 100644
index 0000000..0e5014e
--- /dev/null
+++ b/scripts/northrend/violet_hold/boss_ichoron.cpp
@@ -0,0 +1,334 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* ScriptData
+SDName: boss_ichoron
+SDAuthor: ckegg
+SD%Complete: 0
+SDComment: 
+SDCategory: The Violet Hold
+EndScriptData */
+
+#include "precompiled.h"
+#include "violet_hold.h"
+
+
+enum
+{
+    SAY_AGGRO                                 = -1608018,
+    SAY_SLAY_1                                = -1608019,
+    SAY_SLAY_2                                = -1608020,
+    SAY_SLAY_3                                = -1608021,
+    SAY_DEATH                                 = -1608022,
+    SAY_SPAWN                                 = -1608023,
+    SAY_ENRAGE                                = -1608024,
+    SAY_SHATTER                               = -1608025,
+    SAY_BUBBLE                                = -1608026,
+
+    SPELL_DRAINED                             = 59820,
+    SPELL_FRENZY                              = 54312,
+    SPELL_FRENZY_H                            = 59522,
+    SPELL_PROTECTIVE_BUBBLE                   = 54306,
+    SPELL_WATER_BLAST                         = 54237,
+    SPELL_WATER_BLAST_H                       = 59520,
+    SPELL_WATER_BOLT_VOLLEY                   = 54241,
+    SPELL_WATER_BOLT_VOLLEY_H                 = 59521,
+
+    NPC_ICHOR_GLOBULE                         = 29321,
+    SPELL_SPLASH                              = 59516,
+};
+
+struct MANGOS_DLL_DECL boss_ichoronAI : public ScriptedAI
+{
+    boss_ichoronAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = ((ScriptedInstance*)pCreature->GetInstanceData());
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+    ScriptedInstance *m_pInstance;
+    std::list<uint64> m_lWaterElementsGUIDList;
+
+    bool m_bIsRegularMode;
+    bool m_bIsExploded;
+    bool m_bIsFrenzy;
+    bool MovementStarted;
+
+    uint32 m_uiBuubleChecker_Timer;
+    uint32 m_uiWaterBoltVolley_Timer;
+    uint32 m_uiShowup_Counter;
+
+    void Reset()
+    {
+        m_bIsExploded = false;
+        m_bIsFrenzy = false;
+        MovementStarted = false;
+        m_uiBuubleChecker_Timer = 1000;
+        m_uiWaterBoltVolley_Timer = urand(10000, 15000);
+        m_uiShowup_Counter = 0;
+
+        m_creature->SetVisibility(VISIBILITY_ON);
+        DespawnWaterElements();
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ICHORON, NOT_STARTED);
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        DoScriptText(SAY_AGGRO, m_creature);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ICHORON, IN_PROGRESS);
+    }
+
+    void AttackStart(Unit* pWho)
+    {
+        if (!m_pInstance)
+            return;
+
+        if (m_pInstance->GetData(TYPE_ICHORON) != SPECIAL && m_pInstance->GetData(TYPE_ICHORON) != IN_PROGRESS)
+            return;
+
+
+        if (!pWho || pWho == m_creature)
+            return;
+
+
+        if (m_creature->Attack(pWho, true))
+        {
+//            DoCast(m_creature, SPELL_PROTECTIVE_BUBBLE);
+            m_creature->AddThreat(pWho);
+            m_creature->SetInCombatWith(pWho);
+            pWho->SetInCombatWith(m_creature);
+            DoStartMovement(pWho);
+        }
+    }
+
+    void WaterElementHit()
+    {
+        m_creature->SetHealth(m_creature->GetHealth() + m_creature->GetMaxHealth() * 0.01);
+        if (m_bIsExploded)
+        {
+            DoCast(m_creature, SPELL_PROTECTIVE_BUBBLE);
+            m_bIsExploded = false;
+            m_creature->SetVisibility(VISIBILITY_ON);
+            m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
+        }
+    }
+
+    void JustSummoned(Creature* pSummoned)
+    {
+        pSummoned->SetSpeedRate(MOVE_RUN, 0.2f);
+        pSummoned->GetMotionMaster()->MoveFollow(m_creature, 0, 0);
+        m_lWaterElementsGUIDList.push_back(pSummoned->GetGUID());
+    }
+
+    void DespawnWaterElements()
+    {
+        if (m_lWaterElementsGUIDList.empty())
+            return;
+
+        for(std::list<uint64>::iterator itr = m_lWaterElementsGUIDList.begin(); itr != m_lWaterElementsGUIDList.end(); ++itr)
+        {
+            if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
+            {
+                if (pTemp->isAlive())
+                    //pTemp->ForcedDespawn();
+                    pTemp->DealDamage(pTemp, pTemp->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+            }
+        }
+
+        m_lWaterElementsGUIDList.clear();
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_pInstance->GetData(TYPE_ICHORON) == SPECIAL && !MovementStarted) {
+	m_creature->GetMotionMaster()->MovePoint(0, PortalLoc[0].x, PortalLoc[0].y, PortalLoc[0].z);
+        m_creature->AddSplineFlag(SPLINEFLAG_WALKMODE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        MovementStarted = true;
+        }
+
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (!m_bIsFrenzy)
+        {
+            if (m_uiBuubleChecker_Timer < uiDiff)
+            {
+                if (!m_bIsExploded)
+                {
+                    if (!m_creature->HasAura(SPELL_PROTECTIVE_BUBBLE, EFFECT_INDEX_0))
+                    {
+                        DoCast(m_creature, m_bIsRegularMode ? SPELL_WATER_BLAST_H : SPELL_WATER_BLAST);
+                        //DoCast(m_creature, SPELL_DRAINED);
+                        m_bIsExploded = true;
+                        m_uiShowup_Counter = 0;
+                        DoCast(m_creature, SPELL_PROTECTIVE_BUBBLE);
+                        m_creature->AttackStop();
+//                        m_creature->SetVisibility(VISIBILITY_OFF);
+                        for(uint8 i = 0; i < 10; i++)
+                        {
+                            int tmp = urand(0, 5);
+                            m_creature->SummonCreature(NPC_ICHOR_GLOBULE, PortalLoc[tmp].x, PortalLoc[tmp].y, PortalLoc[tmp].z, 0, TEMPSUMMON_CORPSE_DESPAWN, 0);
+                            //m_creature->SummonCreature(NPC_ICHOR_GLOBULE, m_creature->GetPositionX()-10+rand()%20, m_creature->GetPositionY()-10+rand()%20, m_creature->GetPositionZ(), 0, TEMPSUMMON_CORPSE_DESPAWN, 0);
+                        }
+                    }
+                    m_uiBuubleChecker_Timer = 3000;
+                }
+                else
+                {
+                    bool bIsWaterElementsAlive = false;
+                    ++m_uiShowup_Counter;
+                    if (!m_lWaterElementsGUIDList.empty())
+                    {
+                        for(std::list<uint64>::iterator itr = m_lWaterElementsGUIDList.begin(); itr != m_lWaterElementsGUIDList.end(); ++itr)
+                            if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
+                                if (pTemp->isAlive())
+                                    bIsWaterElementsAlive = true;
+                    }
+                    if (!bIsWaterElementsAlive || m_uiShowup_Counter > 20)
+                    {
+                        m_bIsExploded = false;
+                        m_uiShowup_Counter = 0;
+//                        m_creature->SetVisibility(VISIBILITY_ON);
+                        m_creature->SetInCombatWithZone();
+                        m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
+                    }
+                    m_uiBuubleChecker_Timer = 1000;
+                }
+            }
+            else m_uiBuubleChecker_Timer -= uiDiff;
+        }
+
+        if (!m_bIsExploded)
+        {
+            if (m_uiWaterBoltVolley_Timer < uiDiff)
+            {
+                DoCast(m_creature, m_bIsRegularMode ? SPELL_WATER_BOLT_VOLLEY_H : SPELL_WATER_BOLT_VOLLEY);
+                m_uiWaterBoltVolley_Timer = urand(10000, 15000);
+            }
+            else m_uiWaterBoltVolley_Timer -= uiDiff;
+
+            if (!m_bIsFrenzy && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 25)
+            {
+                DoScriptText(SAY_ENRAGE, m_creature);
+                DoCast(m_creature, m_bIsRegularMode ? SPELL_FRENZY_H : SPELL_FRENZY);
+                m_bIsFrenzy = true;
+            }
+        }
+        DoMeleeAttackIfReady();
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        DoScriptText(SAY_DEATH, m_creature);
+        DespawnWaterElements();
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ICHORON, DONE);
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        switch(urand(0, 2))
+        {
+            case 0: DoScriptText(SAY_SLAY_1, m_creature);break;
+            case 1: DoScriptText(SAY_SLAY_2, m_creature);break;
+            case 2: DoScriptText(SAY_SLAY_3, m_creature);break;
+        }
+    }
+};
+
+
+struct MANGOS_DLL_DECL mob_ichor_globuleAI : public ScriptedAI
+{
+    mob_ichor_globuleAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = ((ScriptedInstance*)pCreature->GetInstanceData());
+        Reset();
+    }
+    ScriptedInstance *m_pInstance;
+
+    uint32 m_uiRangeCheck_Timer;
+
+    void Reset()
+    {
+        m_uiRangeCheck_Timer = 1000;
+    }
+
+    void AttackStart(Unit* pWho)
+    {
+        return;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_uiRangeCheck_Timer < uiDiff)
+        {
+            if (m_pInstance)
+            {
+                if (Creature* pIchoron = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_ICHORON))))
+                {
+                    float fDistance = m_creature->GetDistance2d(pIchoron);
+                    if (fDistance <= 2)
+                    {
+                        ((boss_ichoronAI*)pIchoron->AI())->WaterElementHit();
+                        m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                    }
+                }
+            }
+            m_uiRangeCheck_Timer = 1000;
+        }
+        else m_uiRangeCheck_Timer -= uiDiff;
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        DoCast(m_creature, SPELL_SPLASH);
+    }
+};
+
+CreatureAI* GetAI_boss_ichoron(Creature* pCreature)
+{
+    return new boss_ichoronAI (pCreature);
+}
+
+CreatureAI* GetAI_mob_ichor_globule(Creature* pCreature)
+{
+    return new mob_ichor_globuleAI (pCreature);
+}
+
+void AddSC_boss_ichoron()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "boss_ichoron";
+    newscript->GetAI = &GetAI_boss_ichoron;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_ichor_globule";
+    newscript->GetAI = &GetAI_mob_ichor_globule;
+    newscript->RegisterSelf();
+}
diff --git a/scripts/northrend/violet_hold/boss_lavanthor.cpp b/scripts/northrend/violet_hold/boss_lavanthor.cpp
new file mode 100644
index 0000000..61b05d6
--- /dev/null
+++ b/scripts/northrend/violet_hold/boss_lavanthor.cpp
@@ -0,0 +1,161 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* ScriptData
+SDName: boss_lavanthor
+SDAuthor: ckegg
+SD%Complete: 0
+SDComment: 
+SDCategory: The Violet Hold
+EndScriptData */
+
+#include "precompiled.h"
+#include "violet_hold.h"
+
+enum
+{
+    SPELL_CAUTERIZING_FLAMES                  = 59466,
+    SPELL_FIREBOLT                            = 54235,
+    SPELL_FIREBOLT_H                          = 59468,
+    SPELL_FLAME_BREATH                        = 54282,
+    SPELL_FLAME_BREATH_H                      = 59469,
+    SPELL_LAVA_BURN                           = 54249,
+    SPELL_LAVA_BURN_H                         = 59594,
+};
+
+struct MANGOS_DLL_DECL boss_lavanthorAI : public ScriptedAI
+{
+    boss_lavanthorAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = ((ScriptedInstance*)pCreature->GetInstanceData());
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+    ScriptedInstance *m_pInstance;
+
+    bool m_bIsRegularMode;
+    bool MovementStarted;
+
+    uint32 m_uiCauterizingFlames_Timer;
+    uint32 m_uiFlameBreath_Timer;
+    uint32 m_uiFirebolt_Timer;
+
+    void Reset()
+    {
+        m_uiCauterizingFlames_Timer = urand(40000, 41000);
+        m_uiFlameBreath_Timer = urand(15000, 16000);
+        m_uiFirebolt_Timer = urand(10000, 11000);
+        MovementStarted = false;
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_LAVANTHOR, NOT_STARTED);
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_LAVANTHOR, IN_PROGRESS);
+    }
+
+    void AttackStart(Unit* pWho)
+    {
+        if (!m_pInstance)
+            return;
+
+        if (m_pInstance->GetData(TYPE_LAVANTHOR) != SPECIAL && m_pInstance->GetData(TYPE_LAVANTHOR) != IN_PROGRESS)
+            return;
+
+        if (!pWho || pWho == m_creature)
+            return;
+
+        if (m_creature->Attack(pWho, true))
+        {
+            m_creature->AddThreat(pWho);
+            m_creature->SetInCombatWith(pWho);
+            pWho->SetInCombatWith(m_creature);
+            DoStartMovement(pWho);
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_pInstance->GetData(TYPE_LAVANTHOR) == SPECIAL && !MovementStarted) {
+        m_creature->GetMotionMaster()->MovePoint(0, PortalLoc[0].x, PortalLoc[0].y, PortalLoc[0].z);
+        m_creature->AddSplineFlag(SPLINEFLAG_WALKMODE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        MovementStarted = true;
+        }
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiCauterizingFlames_Timer < uiDiff)
+        {
+            DoCast(m_creature, SPELL_CAUTERIZING_FLAMES);
+            m_uiCauterizingFlames_Timer = urand(40000, 41000);
+        }
+        else m_uiCauterizingFlames_Timer -= uiDiff;
+
+        if (m_uiFirebolt_Timer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_FIREBOLT_H : SPELL_FIREBOLT);
+            m_uiFirebolt_Timer = urand(10000, 11000);
+        }
+        else m_uiFirebolt_Timer -= uiDiff;
+
+        if (m_uiFlameBreath_Timer < uiDiff)
+        {
+            switch (urand(0, 1))
+            {
+                case 0:
+                    DoCast(m_creature, m_bIsRegularMode ? SPELL_FLAME_BREATH_H : SPELL_FLAME_BREATH);
+                    break;
+                case 1:
+                    DoCast(m_creature, m_bIsRegularMode ? SPELL_LAVA_BURN_H : SPELL_LAVA_BURN);
+                    break;
+            }
+            m_uiFlameBreath_Timer = urand(15000, 16000);
+        }
+        else m_uiFlameBreath_Timer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_LAVANTHOR, DONE);
+    }
+};
+
+CreatureAI* GetAI_boss_lavanthor(Creature* pCreature)
+{
+    return new boss_lavanthorAI (pCreature);
+}
+
+void AddSC_boss_lavanthor()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "boss_lavanthor";
+    newscript->GetAI = &GetAI_boss_lavanthor;
+    newscript->RegisterSelf();
+}
diff --git a/scripts/northrend/violet_hold/boss_moragg.cpp b/scripts/northrend/violet_hold/boss_moragg.cpp
new file mode 100644
index 0000000..62cfdbe
--- /dev/null
+++ b/scripts/northrend/violet_hold/boss_moragg.cpp
@@ -0,0 +1,154 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* ScriptData
+SDName: boss_moragg
+SDAuthor: ckegg
+SD%Complete: 0
+SDComment: 
+SDCategory: The Violet Hold
+EndScriptData */
+
+#include "precompiled.h"
+#include "violet_hold.h"
+
+enum
+{
+    SPELL_CORROSICE_SALIVA                = 54527,
+    SPELL_OPTIC_LINK                      = 54396,
+    SPELL_RAY_PAIN                        = 59525,
+    SPELL_RAY_SUFFERING                   = 54417,
+};
+
+struct MANGOS_DLL_DECL boss_moraggAI : public ScriptedAI
+{
+    boss_moraggAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = ((ScriptedInstance*)pCreature->GetInstanceData());
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+    ScriptedInstance *m_pInstance;
+
+    bool m_bIsRegularMode;
+    uint32 m_uiCorrosiveSaliva_Timer;
+    uint32 m_uiOpticLink_Timer;
+    uint32 m_uiRay_Timer;
+    
+    bool MovementStarted;
+
+    void Reset()
+    {
+        MovementStarted = false;
+        m_uiCorrosiveSaliva_Timer = urand(10000, 11000);
+        m_uiOpticLink_Timer = urand(25000, 30000);
+        m_uiRay_Timer = urand(2000, 7000);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_MORAGG, NOT_STARTED);
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_MORAGG, IN_PROGRESS);
+
+    }
+
+    void AttackStart(Unit* pWho)
+    {
+        if (!m_pInstance)
+            return;
+
+        if (m_pInstance->GetData(TYPE_MORAGG) != SPECIAL && m_pInstance->GetData(TYPE_MORAGG) != IN_PROGRESS)
+            return;
+
+        if (!pWho || pWho == m_creature)
+            return;
+
+        if (m_creature->Attack(pWho, true))
+        {
+            m_creature->AddThreat(pWho);
+            m_creature->SetInCombatWith(pWho);
+            pWho->SetInCombatWith(m_creature);
+            DoStartMovement(pWho);
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_pInstance->GetData(TYPE_MORAGG) == SPECIAL && !MovementStarted) {
+	m_creature->GetMotionMaster()->MovePoint(0, PortalLoc[0].x, PortalLoc[0].y, PortalLoc[0].z);
+        m_creature->AddSplineFlag(SPLINEFLAG_WALKMODE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        MovementStarted = true;
+         }
+
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiCorrosiveSaliva_Timer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_CORROSICE_SALIVA);
+            m_uiCorrosiveSaliva_Timer = urand(10000, 11000);
+        }
+        else m_uiCorrosiveSaliva_Timer -= uiDiff;
+
+        if (m_uiOpticLink_Timer < uiDiff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, SPELL_OPTIC_LINK);
+            m_uiOpticLink_Timer = urand(25000, 30000);
+        }
+        else m_uiOpticLink_Timer -= uiDiff;
+
+        if (m_uiRay_Timer < uiDiff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, urand(0, 1) ? SPELL_RAY_PAIN : SPELL_RAY_SUFFERING);
+            m_uiRay_Timer = urand(2000, 7000);
+        }
+        else m_uiRay_Timer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_MORAGG, DONE);
+    }
+};
+
+CreatureAI* GetAI_boss_moragg(Creature* pCreature)
+{
+    return new boss_moraggAI (pCreature);
+}
+
+void AddSC_boss_moragg()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "boss_moragg";
+    newscript->GetAI = &GetAI_boss_moragg;
+    newscript->RegisterSelf();
+}
diff --git a/scripts/northrend/violet_hold/boss_xevozz.cpp b/scripts/northrend/violet_hold/boss_xevozz.cpp
new file mode 100644
index 0000000..ae0e7bd
--- /dev/null
+++ b/scripts/northrend/violet_hold/boss_xevozz.cpp
@@ -0,0 +1,290 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* ScriptData
+SDName: boss_xevozz
+SDAuthor: ckegg
+SD%Complete: 0
+SDComment: 
+SDCategory: The Violet Hold
+EndScriptData */
+
+#include "precompiled.h"
+#include "violet_hold.h"
+
+enum
+{
+    SAY_AGGRO                                 = -1608027,
+    SAY_SLAY_1                                = -1608028,
+    SAY_SLAY_2                                = -1608029,
+    SAY_SLAY_3                                = -1608030,
+    SAY_DEATH                                 = -1608031,
+    SAY_SPAWN                                 = -1608032,
+    SAY_CHARGED                               = -1608033,
+    SAY_REPEAT_SUMMON_1                       = -1608034,
+    SAY_REPEAT_SUMMON_2                       = -1608035,
+    SAY_SUMMON_ENERGY                         = -1608036,
+
+    SPELL_ARCANE_BARRAGE_VOLLEY               = 54202,
+    SPELL_ARCANE_BARRAGE_VOLLEY_H             = 59483,
+    SPELL_ARCANE_BUFFET                       = 54226,
+    SPELL_ARCANE_BUFFET_H                     = 59485,
+    SPELL_SUMMON_ETHEREAL_SPHERE_1            = 54102,
+    SPELL_SUMMON_ETHEREAL_SPHERE_2            = 54137,
+    SPELL_SUMMON_ETHEREAL_SPHERE_3            = 54138,
+
+    NPC_ETHEREAL_SPHERE                       = 29271,
+    //NPC_ETHEREAL_SPHERE2                      = 32582, // heroic only?
+    SPELL_ARCANE_POWER                        = 54160,
+    SPELL_ARCANE_POWER_H                      = 59474,
+    SPELL_SUMMON_PLAYERS                      = 54164,
+};
+
+struct MANGOS_DLL_DECL boss_xevozzAI : public ScriptedAI
+{
+    boss_xevozzAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = ((ScriptedInstance*)pCreature->GetInstanceData());
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+    ScriptedInstance *m_pInstance;
+
+    bool m_bIsRegularMode;
+    bool MovementStarted;
+
+    uint32 m_uiSummonEtherealSphere_Timer;
+    uint32 m_uiArcaneBarrageVolley_Timer;
+    uint32 m_uiArcaneBuffet_Timer;
+
+    void Reset()
+    {
+        m_uiSummonEtherealSphere_Timer = urand(10000, 12000);
+        m_uiArcaneBarrageVolley_Timer = urand(20000, 22000);
+        m_uiArcaneBuffet_Timer = m_uiSummonEtherealSphere_Timer + urand(5000, 6000);
+        DespawnSphere();
+        MovementStarted = false;
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_XEVOZZ, NOT_STARTED);
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        DoScriptText(SAY_AGGRO, m_creature);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_XEVOZZ, IN_PROGRESS);
+
+    }
+
+    void AttackStart(Unit* pWho)
+    {
+        if (!m_pInstance)
+            return;
+
+        if (m_pInstance->GetData(TYPE_XEVOZZ) != SPECIAL && m_pInstance->GetData(TYPE_XEVOZZ) != IN_PROGRESS)
+            return;
+
+        if (!pWho || pWho == m_creature)
+            return;
+
+        if (m_creature->Attack(pWho, true))
+        {
+            m_creature->AddThreat(pWho);
+            m_creature->SetInCombatWith(pWho);
+            pWho->SetInCombatWith(m_creature);
+            DoStartMovement(pWho);
+        }
+    }
+
+    void DespawnSphere()
+    {
+        std::list<Creature*> assistList;
+        GetCreatureListWithEntryInGrid(assistList,m_creature, NPC_ETHEREAL_SPHERE ,150.0f);
+
+        if (assistList.empty())
+            return;
+
+        for(std::list<Creature*>::iterator iter = assistList.begin(); iter != assistList.end(); ++iter)
+            (*iter)->DealDamage((*iter), (*iter)->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+    }
+
+    void JustSummoned(Creature* pSummoned)
+    {
+        pSummoned->SetSpeedRate(MOVE_RUN, 0.5f);
+        if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+        {
+            pSummoned->AddThreat(pTarget);
+            pSummoned->AI()->AttackStart(pTarget);
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_pInstance->GetData(TYPE_XEVOZZ) == SPECIAL && !MovementStarted) {
+	m_creature->GetMotionMaster()->MovePoint(0, PortalLoc[0].x, PortalLoc[0].y, PortalLoc[0].z);
+        m_creature->AddSplineFlag(SPLINEFLAG_WALKMODE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        MovementStarted = true;
+        }
+
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiArcaneBarrageVolley_Timer < uiDiff)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_ARCANE_BARRAGE_VOLLEY_H : SPELL_ARCANE_BARRAGE_VOLLEY);
+            m_uiArcaneBarrageVolley_Timer = urand(20000, 22000);
+        }
+        else m_uiArcaneBarrageVolley_Timer -= uiDiff;
+
+        if (m_uiArcaneBuffet_Timer)
+            if (m_uiArcaneBuffet_Timer < uiDiff)
+            {
+                DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_ARCANE_BUFFET_H : SPELL_ARCANE_BUFFET);
+                m_uiArcaneBuffet_Timer = 0;
+            }
+            else m_uiArcaneBuffet_Timer -= uiDiff;
+
+        if (m_uiSummonEtherealSphere_Timer < uiDiff)
+        {
+            DoScriptText(SAY_SUMMON_ENERGY, m_creature);
+            DoCast(m_creature, SPELL_SUMMON_ETHEREAL_SPHERE_1);
+            if (m_bIsRegularMode) // extra one for heroic
+                m_creature->SummonCreature(NPC_ETHEREAL_SPHERE, m_creature->GetPositionX()-5+rand()%10, m_creature->GetPositionY()-5+rand()%10, m_creature->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 40000);
+
+            m_uiSummonEtherealSphere_Timer = urand(45000, 47000);
+            m_uiArcaneBuffet_Timer = urand(5000, 6000);
+        }
+        else m_uiSummonEtherealSphere_Timer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        DoScriptText(SAY_DEATH, m_creature);
+        DespawnSphere();
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_XEVOZZ, DONE);
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        switch(urand(0, 2))
+        {
+            case 0: DoScriptText(SAY_SLAY_1, m_creature);break;
+            case 1: DoScriptText(SAY_SLAY_2, m_creature);break;
+            case 2: DoScriptText(SAY_SLAY_3, m_creature);break;
+        }
+    }
+};
+
+struct MANGOS_DLL_DECL mob_ethereal_sphereAI : public ScriptedAI
+{
+    mob_ethereal_sphereAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = ((ScriptedInstance*)pCreature->GetInstanceData());
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+    ScriptedInstance *m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiSummonPlayers_Timer;
+    uint32 m_uiRangeCheck_Timer;
+
+    void Reset()
+    {
+        m_uiSummonPlayers_Timer = urand(33000, 35000);
+        m_uiRangeCheck_Timer = 1000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiRangeCheck_Timer < uiDiff)
+        {
+            if (m_pInstance)
+            {
+                if (Creature* pXevozz = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_XEVOZZ))))
+                {
+                    float fDistance = m_creature->GetDistance2d(pXevozz);
+                    if (fDistance <= 3)
+                        DoCast(pXevozz, m_bIsRegularMode ? SPELL_ARCANE_POWER_H : SPELL_ARCANE_POWER);
+                    else
+                        DoCast(m_creature, 35845);
+                }
+            }
+            m_uiRangeCheck_Timer = 1000;
+        }
+        else m_uiRangeCheck_Timer -= uiDiff;
+
+        if (m_uiSummonPlayers_Timer < uiDiff)
+        {
+            DoCast(m_creature, SPELL_SUMMON_PLAYERS); // not working right
+
+            Map* pMap = m_creature->GetMap();
+            if (pMap && pMap->IsDungeon())
+            {
+                Map::PlayerList const &PlayerList = pMap->GetPlayers();
+
+                if (!PlayerList.isEmpty())
+                    for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                        if (i->getSource()->isAlive())
+                            DoTeleportPlayer(i->getSource(), m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ(), i->getSource()->GetOrientation());
+            }
+
+            m_uiSummonPlayers_Timer = urand(33000, 35000);
+        }
+        else m_uiSummonPlayers_Timer -= uiDiff;
+    }
+};
+
+CreatureAI* GetAI_boss_xevozz(Creature* pCreature)
+{
+    return new boss_xevozzAI (pCreature);
+}
+
+CreatureAI* GetAI_mob_ethereal_sphere(Creature* pCreature)
+{
+    return new mob_ethereal_sphereAI (pCreature);
+}
+
+void AddSC_boss_xevozz()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "boss_xevozz";
+    newscript->GetAI = &GetAI_boss_xevozz;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_ethereal_sphere";
+    newscript->GetAI = &GetAI_mob_ethereal_sphere;
+    newscript->RegisterSelf();
+}
diff --git a/scripts/northrend/violet_hold/boss_zuramat.cpp b/scripts/northrend/violet_hold/boss_zuramat.cpp
new file mode 100644
index 0000000..8595723
--- /dev/null
+++ b/scripts/northrend/violet_hold/boss_zuramat.cpp
@@ -0,0 +1,241 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* ScriptData
+SDName: boss_zuramat
+SDAuthor: ckegg
+SD%Complete: 0
+SDComment: 
+SDCategory: The Violet Hold
+EndScriptData */
+
+#include "precompiled.h"
+#include "violet_hold.h"
+
+enum
+{
+    SAY_AGGRO                                 = -1608037,
+    SAY_SLAY_1                                = -1608038,
+    SAY_SLAY_2                                = -1608039,
+    SAY_SLAY_3                                = -1608040,
+    SAY_DEATH                                 = -1608041,
+    SAY_SPAWN                                 = -1608042,
+    SAY_SHIELD                                = -1608043,
+    SAY_WHISPER                               = -1608044,
+
+    SPELL_SHROUD_OF_DARKNESS                  = 54524,
+    SPELL_SHROUD_OF_DARKNESS_H                = 59745,
+    SPELL_SUMMON_VOID_SENTRY                  = 54369,
+    SPELL_VOID_SHIFT                          = 54361,
+    SPELL_VOID_SHIFT_H                        = 59743,
+
+    NPC_VOID_SENTRY                           = 29364,
+    SPELL_VOID_SENTRY_AURA                    = 54341,
+    SPELL_VOID_SENTRY_AURA_H                  = 54351,
+    SPELL_SHADOW_BOLT_VOLLEY                  = 54358, // 54342? 54358?
+    SPELL_SHADOW_BOLT_VOLLEY_H                = 59747,
+};
+
+struct MANGOS_DLL_DECL boss_zuramatAI : public ScriptedAI
+{
+    boss_zuramatAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = ((ScriptedInstance*)pCreature->GetInstanceData());
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+    ScriptedInstance *m_pInstance;
+
+    bool m_bIsRegularMode;
+    bool MovementStarted;
+    std::list<uint64> m_lSentryGUIDList;
+
+    uint32 m_uiShroudDarkness_Timer;
+    uint32 m_uiVoidShift_Timer;
+    uint32 m_uiSummonVoidSentry_Timer;
+
+    void Reset()
+    {
+        m_uiShroudDarkness_Timer = urand(8000, 9000);
+        m_uiSummonVoidSentry_Timer = urand(5000, 10000);
+        m_uiVoidShift_Timer = 10000;
+        MovementStarted = false;
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ZURAMAT, NOT_STARTED);
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        DoScriptText(SAY_AGGRO, m_creature);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ZURAMAT, IN_PROGRESS);
+    }
+
+    void AttackStart(Unit* pWho)
+    {
+        if (!m_pInstance)
+            return;
+
+        if (m_pInstance->GetData(TYPE_ZURAMAT) != SPECIAL && m_pInstance->GetData(TYPE_ZURAMAT) != IN_PROGRESS)
+            return;
+
+        if (!pWho || pWho == m_creature)
+            return;
+
+        if (m_creature->Attack(pWho, true))
+        {
+            m_creature->AddThreat(pWho);
+            m_creature->SetInCombatWith(pWho);
+            pWho->SetInCombatWith(m_creature);
+            DoStartMovement(pWho);
+        }
+    }
+
+    void JustSummoned(Creature* pSummoned)
+    {
+        m_lSentryGUIDList.push_back(pSummoned->GetGUID());
+        //pSummoned->AddThreat(m_creature);
+        //pSummoned->AI()->AttackStart(m_creature);
+    }
+
+    void DespawnSentry()
+    {
+        if (m_lSentryGUIDList.empty())
+            return;
+
+        for(std::list<uint64>::iterator itr = m_lSentryGUIDList.begin(); itr != m_lSentryGUIDList.end(); ++itr)
+        {
+            if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
+            {
+                if (pTemp->isAlive())
+                    //pTemp->ForcedDespawn();
+                    pTemp->DealDamage(pTemp, pTemp->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+            }
+        }
+
+        m_lSentryGUIDList.clear();
+    }
+
+    void UpdateAI(const uint32 uiDiff) 
+    {
+        if (m_pInstance->GetData(TYPE_ZURAMAT) == SPECIAL && !MovementStarted) {
+	m_creature->GetMotionMaster()->MovePoint(0, PortalLoc[0].x, PortalLoc[0].y, PortalLoc[0].z);
+        m_creature->AddSplineFlag(SPLINEFLAG_WALKMODE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        MovementStarted = true;
+        }
+
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiShroudDarkness_Timer < uiDiff)
+        {
+            DoScriptText(SAY_SHIELD, m_creature);
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_SHROUD_OF_DARKNESS_H : SPELL_SHROUD_OF_DARKNESS);
+            m_uiShroudDarkness_Timer = urand(7000, 8000);
+        }
+        else m_uiShroudDarkness_Timer -= uiDiff;
+
+        if (m_uiVoidShift_Timer < uiDiff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_VOID_SHIFT_H : SPELL_VOID_SHIFT);
+            m_uiVoidShift_Timer = urand(10000, 11000);
+        }
+        else m_uiVoidShift_Timer -= uiDiff;
+
+        if (m_uiSummonVoidSentry_Timer < uiDiff)
+        {
+            m_creature->SummonCreature(NPC_VOID_SENTRY, m_creature->GetPositionX()-10+rand()%20, m_creature->GetPositionY()-10+rand()%20, m_creature->GetPositionZ(), 0, TEMPSUMMON_CORPSE_DESPAWN, 0);
+            m_uiSummonVoidSentry_Timer = urand(10000, 11000);
+        }
+        else m_uiSummonVoidSentry_Timer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        DoScriptText(SAY_DEATH, m_creature);
+        DespawnSentry();
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ZURAMAT, DONE);
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        switch(urand(0, 2))
+        {
+            case 0: DoScriptText(SAY_SLAY_1, m_creature);break;
+            case 1: DoScriptText(SAY_SLAY_2, m_creature);break;
+            case 2: DoScriptText(SAY_SLAY_3, m_creature);break;
+        }
+    }
+};
+
+struct MANGOS_DLL_DECL mob_zuramat_sentryAI : public ScriptedAI
+{
+    mob_zuramat_sentryAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = ((ScriptedInstance*)pCreature->GetInstanceData());
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        SetCombatMovement(false);
+        Reset();
+    }
+    ScriptedInstance *m_pInstance;
+    bool m_bIsRegularMode;
+
+    void Reset()
+    {
+        //DoCast(m_creature, m_bIsRegularMode ? SPELL_VOID_SENTRY_AURA_H : SPELL_VOID_SENTRY_AURA); ??
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        DoCast(m_creature, m_bIsRegularMode ? SPELL_SHADOW_BOLT_VOLLEY_H : SPELL_SHADOW_BOLT_VOLLEY);
+    }
+};
+
+CreatureAI* GetAI_boss_zuramat(Creature* pCreature)
+{
+    return new boss_zuramatAI (pCreature);
+}
+
+CreatureAI* GetAI_mob_zuramat_sentry(Creature* pCreature)
+{
+    return new mob_zuramat_sentryAI (pCreature);
+}
+
+void AddSC_boss_zuramat()
+{
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "boss_zuramat";
+    newscript->GetAI = &GetAI_boss_zuramat;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_zuramat_sentry";
+    newscript->GetAI = &GetAI_mob_zuramat_sentry;
+    newscript->RegisterSelf();
+
+}
diff --git a/scripts/northrend/violet_hold/instance_violet_hold.cpp b/scripts/northrend/violet_hold/instance_violet_hold.cpp
index 9eb5e3c..55d55f8 100644
--- a/scripts/northrend/violet_hold/instance_violet_hold.cpp
+++ b/scripts/northrend/violet_hold/instance_violet_hold.cpp
@@ -15,384 +15,398 @@
  */
 
 /* ScriptData
-SDName: Instance_Violet_Hold
-SD%Complete: 50
-SDComment: "experimental" use of header/source object
-SDCategory: Violet Hold
+SDName: Instance The Violet Hold
+SD%Complete: 60%
+SDComment:
+SDCategory: The Violet Hold
 EndScriptData */
 
 #include "precompiled.h"
 #include "violet_hold.h"
 
-instance_violet_hold::instance_violet_hold(Map* pMap) : ScriptedInstance(pMap),
-    m_uiSinclariGUID(0),
-    m_uiSinclariAltGUID(0),
-    m_uiErekemGUID(0),
-    m_uiMoraggGUID(0),
-    m_uiIchoronGUID(0),
-    m_uiXevozzGUID(0),
-    m_uiLavanthorGUID(0),
-    m_uiZuramatGUID(0),
-
-    m_uiCellErekemGuard_LGUID(0),
-    m_uiCellErekemGuard_RGUID(0),
-    m_uiIntroCrystalGUID(0),
-
-    m_uiWorldState(0),
-    m_uiWorldStateSealCount(100),
-    m_uiWorldStatePortalCount(0),
-
-    m_uiPortalId(0),
-    m_uiPortalTimer(0),
-    m_uiMaxCountPortalLoc(0)
+/* The Violet Hold encounters:
+0 Whole Event
+1 Rift
+2 Erekem
+3 Moragg
+4 Ichoron
+5 Xevozz
+6 Lavanthor
+7 Zuramat
+*/
+//inline uint32 RandRiftBoss() { return ((rand()%2) ? NPC_GUARDIAN : NPC_KEEPER); }
+
+struct MANGOS_DLL_DECL instance_violet_hold : public ScriptedInstance
 {
-    Initialize();
-}
-
-void instance_violet_hold::Initialize()
-{
-    memset(&m_auiEncounter, 0, sizeof(m_auiEncounter));
-    m_uiMaxCountPortalLoc = (sizeof(afPortalLocation)/sizeof(sPortalData)) - 1;
-}
-
-void instance_violet_hold::ResetVariables()
-{
-    m_uiWorldStateSealCount = 100;
-    m_uiWorldStatePortalCount = 0;
-}
-
-void instance_violet_hold::ResetAll()
-{
-    ResetVariables();
-    UpdateWorldState(false);
-    CallGuards(true);
-    SetIntroPortals(false);
-}
-
-void instance_violet_hold::OnCreatureCreate(Creature* pCreature)
-{
-    switch(pCreature->GetEntry())
+    instance_violet_hold(Map* pMap) : ScriptedInstance(pMap) {Initialize();};
+
+    uint32 m_auiEncounter[MAX_ENCOUNTER+1];
+    std::string m_strInstData;
+
+    bool bIsInBoss;
+
+    uint8 m_uiLastBossID;
+    uint8 m_uiLastBossIDConst;
+    uint8 m_uiRiftPortalCount;
+    uint32 m_uiShieldPercent;
+    uint32 m_uiDisruptions;
+    int8 m_uiPortalTime;
+
+    uint64 m_uiSinclariGUID;
+    uint64 m_uiNPCSealDoorGUID;
+
+    uint64 m_uiErekemGUID;
+    uint64 m_uiMoraggGUID;
+    uint64 m_uiIchoronGUID;
+    uint64 m_uiXevozzGUID;
+    uint64 m_uiLavanthorGUID;
+    uint64 m_uiZuramatGUID;
+
+    uint64 m_uiSealDoorGUID;
+    uint64 m_uiErekemDoorGUID;
+    uint64 m_uiErekemDoorLeftGUID;
+    uint64 m_uiErekemDoorRightGUID;
+    uint64 m_uiMoraggDoorGUID;
+    uint64 m_uiIchoronDoorGUID;
+    uint64 m_uiXevozzDoorGUID;
+    uint64 m_uiLavanthorDoorGUID;
+    uint64 m_uiZuramatDoorGUID;
+
+    void Initialize()
     {
-        case NPC_SINCLARI: m_uiSinclariGUID = pCreature->GetGUID(); break;
-        case NPC_SINCLARI_ALT: m_uiSinclariAltGUID = pCreature->GetGUID(); break;
-        case NPC_DOOR_SEAL: m_uiDoorSealGUID = pCreature->GetGUID(); break;
+//        memset(&m_auiEncounter, 0, sizeof(m_auiEncounter));
+	    for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+            m_auiEncounter[i] = NOT_STARTED;
+
+        m_uiSinclariGUID = 0;
+        m_uiNPCSealDoorGUID = 0;
+        m_uiLastBossIDConst = 0;
+
+        m_uiErekemGUID      = 0;
+        m_uiMoraggGUID      = 0;
+        m_uiIchoronGUID     = 0;
+        m_uiXevozzGUID      = 0;
+        m_uiLavanthorGUID   = 0;
+        m_uiZuramatGUID     = 0;
+        
+        m_uiDisruptions     = 0;
+
+        m_uiSealDoorGUID        = 0;
+        m_uiErekemDoorGUID      = 0;
+        m_uiErekemDoorLeftGUID  = 0;
+        m_uiErekemDoorRightGUID = 0;
+        m_uiMoraggDoorGUID      = 0;
+        m_uiIchoronDoorGUID     = 0;
+        m_uiXevozzDoorGUID      = 0;
+        m_uiLavanthorDoorGUID   = 0;
+        m_uiZuramatDoorGUID     = 0;
+        Clear();
+    }
 
-        case NPC_EREKEM:
-            m_lRandomBossList.push_back(pCreature->GetEntry());
-            m_uiErekemGUID = pCreature->GetGUID();
-            break;
-        case NPC_MORAGG:
-            m_lRandomBossList.push_back(pCreature->GetEntry());
-            m_uiMoraggGUID = pCreature->GetGUID();
-            break;
-        case NPC_ICHORON:
-            m_lRandomBossList.push_back(pCreature->GetEntry());
-            m_uiIchoronGUID = pCreature->GetGUID();
-            break;
-        case NPC_XEVOZZ:
-            m_lRandomBossList.push_back(pCreature->GetEntry());
-            m_uiXevozzGUID = pCreature->GetGUID();
-            break;
-        case NPC_LAVANTHOR:
-            m_lRandomBossList.push_back(pCreature->GetEntry());
-            m_uiLavanthorGUID = pCreature->GetGUID();
-            break;
-        case NPC_ZURAMAT:
-            m_lRandomBossList.push_back(pCreature->GetEntry());
-            m_uiZuramatGUID = pCreature->GetGUID();
-            break;
+    void Clear(){
+        bIsInBoss = false;
 
-        case NPC_PORTAL_INTRO:
-            m_lIntroPortalList.push_back(pCreature->GetGUID());
-            break;
-        case NPC_HOLD_GUARD:
-            m_lGuardsList.push_back(pCreature->GetGUID());
-            break;
+        m_uiLastBossID = 0;
+        m_uiRiftPortalCount = 0;
+        m_uiPortalTime = 0;
+        m_uiShieldPercent = 100;
     }
-}
 
-void instance_violet_hold::OnObjectCreate(GameObject* pGo)
-{
-    switch(pGo->GetEntry())
+    void InitWorldState(bool Enable = true)
     {
-        case GO_CELL_LAVANTHOR:
-            m_mBossToCellMap.insert(BossToCellMap::value_type(NPC_LAVANTHOR, pGo->GetGUID()));
-            break;
-        case GO_CELL_MORAGG:
-            m_mBossToCellMap.insert(BossToCellMap::value_type(NPC_MORAGG, pGo->GetGUID()));
-            break;
-        case GO_CELL_ZURAMAT:
-            m_mBossToCellMap.insert(BossToCellMap::value_type(NPC_ZURAMAT, pGo->GetGUID()));
-            break;
-        case GO_CELL_XEVOZZ:
-            m_mBossToCellMap.insert(BossToCellMap::value_type(NPC_XEVOZZ, pGo->GetGUID()));
-            break;
-        case GO_CELL_ICHORON:
-            m_mBossToCellMap.insert(BossToCellMap::value_type(NPC_ICHORON, pGo->GetGUID()));
-            break;
-        case GO_CELL_EREKEM:
-            m_mBossToCellMap.insert(BossToCellMap::value_type(NPC_EREKEM, pGo->GetGUID()));
-            break;
-        case GO_CELL_EREKEM_GUARD_L:
-            m_mBossToCellMap.insert(BossToCellMap::value_type(NPC_EREKEM, pGo->GetGUID()));
-            break;
-        case GO_CELL_EREKEM_GUARD_R:
-            m_mBossToCellMap.insert(BossToCellMap::value_type(NPC_EREKEM, pGo->GetGUID()));
-            break;
-
-        case GO_INTRO_CRYSTAL:
-            m_uiIntroCrystalGUID = pGo->GetGUID();
-            break;
-        case GO_PRISON_SEAL_DOOR:
-            m_uiDoorSealGUID = pGo->GetGUID();
-            break;
+        DoUpdateWorldState(WORLD_STATE_VH,Enable ? 1 : 0);
+        DoUpdateWorldState(WORLD_STATE_VH_PRISON,100);
+        DoUpdateWorldState(WORLD_STATE_VH_PORTALS,0);
     }
-}
-
-void instance_violet_hold::UpdateCellForBoss(uint32 uiBossEntry)
-{
-    BossToCellMap::const_iterator itrCellLower = m_mBossToCellMap.lower_bound(uiBossEntry);
-    BossToCellMap::const_iterator itrCellUpper = m_mBossToCellMap.upper_bound(uiBossEntry);
-
-    if (itrCellLower == itrCellUpper)
-        return;
-
-    for(BossToCellMap::const_iterator itr = itrCellLower; itr != itrCellUpper; ++itr)
-        DoUseDoorOrButton(itr->second);
-}
-
-void instance_violet_hold::UpdateWorldState(bool bEnable)
-{
-    if (bEnable)
-        m_uiWorldState = 1;
-    else
-        m_uiWorldState = 0;
-
-    DoUpdateWorldState(WORLD_STATE_ID, m_uiWorldState);
-    DoUpdateWorldState(WORLD_STATE_SEAL, m_uiWorldStateSealCount);
-    DoUpdateWorldState(WORLD_STATE_PORTALS, m_uiWorldStatePortalCount);
-}
 
-void instance_violet_hold::OnPlayerEnter(Player* pPlayer)
-{
-    UpdateWorldState(m_auiEncounter[0] == IN_PROGRESS ? true : false);
-}
+    void OnPlayerEnter(Player* pPlayer)
+    {
+        if(m_auiEncounter[0] != NOT_STARTED)
+            pPlayer->SendUpdateWorldState(WORLD_STATE_VH,1);
+    }
+    
+    bool IsEncounterInProgress() const
+    {
+        for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+            if (m_auiEncounter[i] == IN_PROGRESS)
+                return true;
 
-void instance_violet_hold::SetData(uint32 uiType, uint32 uiData)
-{
-    debug_log("SD2: instance_violet_hold: SetData got type % u, data %u.", uiType, uiData);
+        return false;
+    }
 
-    switch(uiType)
+    void OnCreatureCreate(Creature* pCreature)
     {
-        case TYPE_MAIN:
+        switch(pCreature->GetEntry())
         {
-            if (uiData == m_auiEncounter[0])
-                return;
-
-            switch(uiData)
-            {
-                case NOT_STARTED:
-                    ResetAll();
-                    break;
-                case IN_PROGRESS:
-                    DoUseDoorOrButton(m_uiDoorSealGUID);
-                    SetRandomBosses();
-                    UpdateWorldState();
-                    m_uiPortalId = urand(0, 2);
-                    m_uiPortalTimer = 15000;
-                    break;
-                case FAIL:
-                    if (Creature* pSinclari = instance->GetCreature(m_uiSinclariGUID))
-                        pSinclari->Respawn();
-
-                    break;
-                case DONE:
-                    break;
-                case SPECIAL:
-                    break;
-            }
-            m_auiEncounter[0] = uiData;
-            break;
-        }
-        case TYPE_SEAL:
-            m_auiEncounter[1] = uiData;
-            break;
-        case TYPE_PORTAL:
-        {
-            switch(uiData)
-            {
-                case SPECIAL:                               // timer to next
-                    m_uiPortalTimer = 90000;
-                    break;
-                case DONE:                                  // portal done, set timer to 5 secs
-                    m_uiPortalTimer = 5000;
-                    break;
-            }
-            m_auiEncounter[2] = uiData;
-            break;
+            case NPC_SINCLARI:
+                m_uiSinclariGUID = pCreature->GetGUID();
+                break;
+            case NPC_DOOR_SEAL:
+                m_uiNPCSealDoorGUID = pCreature->GetGUID();
+                break;
+            case NPC_EREKEM:
+                m_uiErekemGUID = pCreature->GetGUID();
+                break;
+            case NPC_MORAGG:
+                m_uiMoraggGUID = pCreature->GetGUID();
+                break;
+            case NPC_ICHORON:
+                m_uiIchoronGUID = pCreature->GetGUID();
+                break;
+            case NPC_XEVOZZ:
+                m_uiXevozzGUID = pCreature->GetGUID();
+                break;
+            case NPC_LAVANTHOR:
+                m_uiLavanthorGUID = pCreature->GetGUID();
+                break;
+            case NPC_ZURAMAT:
+                m_uiZuramatGUID = pCreature->GetGUID();
+                break;
         }
     }
-}
 
-void instance_violet_hold::SetIntroPortals(bool bDeactivate)
-{
-    for(std::list<uint64>::iterator i = m_lIntroPortalList.begin(); i != m_lIntroPortalList.end(); ++i)
+    void OnObjectCreate(GameObject* pGo)
     {
-        if (Creature* pPortal = instance->GetCreature(*i))
+        switch(pGo->GetEntry())
         {
-            if (bDeactivate)
-                pPortal->ForcedDespawn();
-            else
-                pPortal->Respawn();
+            case GO_DOOR_SEAL:
+                m_uiSealDoorGUID = pGo->GetGUID();
+                break;
+            case GO_DOOR_EREKEM:
+                m_uiErekemDoorGUID = pGo->GetGUID();
+                break;
+            case GO_DOOR_EREKEM_LEFT:
+                m_uiErekemDoorLeftGUID = pGo->GetGUID();
+                break;
+            case GO_DOOR_EREKEM_RIGHT:
+                m_uiErekemDoorRightGUID = pGo->GetGUID();
+                break;
+            case GO_DOOR_MORAGG:
+                m_uiMoraggDoorGUID = pGo->GetGUID();
+                break;
+            case GO_DOOR_ICHORON:
+                m_uiIchoronDoorGUID = pGo->GetGUID();
+                break;
+            case GO_DOOR_XEVOZZ:
+                m_uiXevozzDoorGUID = pGo->GetGUID();
+                break;
+            case GO_DOOR_LAVANTHOR:
+                m_uiLavanthorDoorGUID = pGo->GetGUID();
+                break;
+            case GO_DOOR_ZURAMAT:
+                m_uiZuramatDoorGUID = pGo->GetGUID();
+                break;
         }
     }
-}
 
-void instance_violet_hold::SpawnPortal()
-{
-    if (const sPortalData* pData = GetPortalData())
+    void SetData(uint32 uiType, uint32 uiData)
     {
-        if (Creature* pController = instance->GetCreature(m_uiSinclariAltGUID))
+        switch(uiType)
         {
-            uint32 uiPortalEntry;
-
-            switch(pData->pPortalType)
-            {
-                case PORTAL_TYPE_NORM: uiPortalEntry = NPC_PORTAL; break;
-                case PORTAL_TYPE_SQUAD:
-                case PORTAL_TYPE_BOSS: uiPortalEntry = NPC_PORTAL_ELITE; break;
-            }
+            case TYPE_EVENT:
+                if (uiData == IN_PROGRESS)
+                {
+                    Clear();
+                    InitWorldState();
+                }
+                else if (uiData == FAIL || uiData == DONE)
+                {
+                DoUpdateWorldState(WORLD_STATE_VH, 0);
+                DoUseDoorOrButton(m_uiSealDoorGUID);
+                }
+                m_auiEncounter[0] = uiData;
+                break;
+            case TYPE_EREKEM:
+                m_auiEncounter[2] = uiData;
+                if (uiData == IN_PROGRESS) bIsInBoss = true;
+                break;
+            case TYPE_MORAGG:
+                m_auiEncounter[3] = uiData;
+                if (uiData == IN_PROGRESS) bIsInBoss = true;
+                break;
+            case TYPE_ICHORON:
+                m_auiEncounter[4] = uiData;
+                if (uiData == IN_PROGRESS) bIsInBoss = true;
+                break;
+            case TYPE_XEVOZZ:
+                m_auiEncounter[5] = uiData;
+                if (uiData == IN_PROGRESS) bIsInBoss = true;
+                break;
+            case TYPE_LAVANTHOR:
+                m_auiEncounter[6] = uiData;
+                if (uiData == IN_PROGRESS) bIsInBoss = true;
+                break;
+            case TYPE_ZURAMAT:
+                m_auiEncounter[7] = uiData;
+                if (uiData == IN_PROGRESS) bIsInBoss = true;
+                break;
+            case TYPE_RIFT:
+                if (uiData == FAIL) DoUseDoorOrButton(m_uiSealDoorGUID);
+                m_auiEncounter[1] = uiData;
+                break;
+            case TYPE_DOOR:
+                if (uiData == SPECIAL)
+                {
+                    m_uiShieldPercent = m_uiShieldPercent - 5;
+                    if(m_uiShieldPercent > 0)
+                        DoUpdateWorldState(WORLD_STATE_VH_PRISON, m_uiShieldPercent);
+                    else
+                    {   DoUpdateWorldState(WORLD_STATE_VH, 0);
+                        DoUseDoorOrButton(m_uiSealDoorGUID);
+                        m_auiEncounter[0] = FAIL;
+                    }
+                }
+                break;
+            case TYPE_DISRUPTIONS:
+            m_uiDisruptions = uiData;
+//            DoUpdateWorldState(WORLD_STATE_VH_PRISON, 100-m_uiDisruptions*5);
+            break;
+            case TYPE_LASTBOSS_ID:
+            m_uiLastBossIDConst = uiData;
+            break;
 
-            pController->SummonCreature(uiPortalEntry, pData->fX, pData->fY, pData->fZ, pData->fOrient, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 1800*IN_MILLISECONDS);
         }
-    }
-}
+        if (uiData == DONE)
+        {
+            bIsInBoss = false;
+            OUT_SAVE_INST_DATA;
 
-void instance_violet_hold::SetPortalId()
-{
-    if (IsCurrentPortalForTrash())
-    {
-        int iTemp = rand()%(m_uiMaxCountPortalLoc - 1);
+            std::ostringstream saveStream;
 
-        if (iTemp >= m_uiPortalId)
-            ++iTemp;
+            for(uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+                saveStream << m_auiEncounter[i] << " ";
 
-        debug_log("SD2: instance_violet_hold: SetPortalId %i, old was id %u.", iTemp, m_uiPortalId);
+            m_strInstData = saveStream.str();
+
+            SaveToDB();
+            OUT_SAVE_INST_DATA_COMPLETE;
+        }
 
-        m_uiPortalId = iTemp;
-    }
-    else
-    {
-        debug_log("SD2: instance_violet_hold: SetPortalId %u (is boss), old was id %u.", m_uiMaxCountPortalLoc, m_uiPortalId);
-        m_uiPortalId = m_uiMaxCountPortalLoc;
     }
-}
 
-void instance_violet_hold::SetRandomBosses()
-{
-    while (m_lRandomBossList.size() > 2)
+    uint32 GetData(uint32 uiType)
     {
-        uint32 uiPosition = urand(0, m_lRandomBossList.size()-1);
-
-        for(std::list<uint32>::iterator itr = m_lRandomBossList.begin(); itr != m_lRandomBossList.end(); ++itr, --uiPosition)
+        switch(uiType)
         {
-            if (!*itr)
-                continue;
-
-            if (!uiPosition)
+            case TYPE_EVENT:
+                return m_auiEncounter[0];
+            case TYPE_EREKEM:
+                return m_auiEncounter[2];
+            case TYPE_MORAGG:
+                return m_auiEncounter[3];
+            case TYPE_ICHORON:
+                return m_auiEncounter[4];
+            case TYPE_XEVOZZ:
+                return m_auiEncounter[5];
+            case TYPE_LAVANTHOR:
+                return m_auiEncounter[6];
+            case TYPE_ZURAMAT:
+                return m_auiEncounter[7];
+            case TYPE_RIFT:
+                return m_uiRiftPortalCount;
+            case TYPE_LASTBOSS_ID:
+                return m_uiLastBossIDConst;
+            case TYPE_LASTBOSS:
             {
-                m_lRandomBossList.erase(itr);
-                 break;
+                if (m_uiLastBossID == 0)
+                    m_uiLastBossID = urand(2, 7);
+//                    m_uiLastBossID = 3;
+                else
+                {
+                    m_uiLastBossID = urand(2, 7);
+                    if ( m_auiEncounter[2] == DONE &&
+                         m_auiEncounter[3] == DONE &&
+                         m_auiEncounter[4] == DONE &&
+                         m_auiEncounter[5] == DONE &&
+                         m_auiEncounter[6] == DONE &&
+                         m_auiEncounter[7] == DONE) return 0;
+                    while ( m_auiEncounter[m_uiLastBossID] == DONE
+                            || m_auiEncounter[m_uiLastBossID] == IN_PROGRESS 
+                            || m_auiEncounter[m_uiLastBossID] == SPECIAL ) 
+                            {
+                    m_uiLastBossID = urand(2, 7);
+                    }
+                }
+                return m_uiLastBossID;
             }
+            case DATA_BOSSTIME:
+                return bIsInBoss;
+            case TYPE_DISRUPTIONS:
+                return m_uiDisruptions;
         }
+        return 0;
     }
 
-    for(std::list<uint32>::iterator itr = m_lRandomBossList.begin(); itr != m_lRandomBossList.end(); ++itr)
-        debug_log("SD2: instance_violet_hold random boss is entry %u", *itr);
-}
-
-void instance_violet_hold::CallGuards(bool bRespawn)
-{
-    for(std::list<uint64>::iterator i = m_lGuardsList.begin(); i != m_lGuardsList.end(); ++i)
+    uint64 GetData64(uint32 uiData)
     {
-        if (Creature* pGuard = instance->GetCreature(*i))
+        switch(uiData)
         {
-            if (bRespawn)
-            {
-                pGuard->Respawn();
-            }
-            else if (pGuard->isAlive())
-            {
-                pGuard->AI()->EnterEvadeMode();
-
-                if (Creature* pSinclari = instance->GetCreature(m_uiSinclariGUID))
-                    pGuard->GetMotionMaster()->MoveFollow(pSinclari, 0.0f, 0.0f);
-
-                pGuard->ForcedDespawn(20000);
-            }
+            case DATA_EREKEM:
+                return m_uiErekemGUID;
+            case DATA_MORAGG:
+                return m_uiMoraggGUID;
+            case DATA_ICHORON:
+                return m_uiIchoronGUID;
+            case DATA_XEVOZZ:
+                return m_uiXevozzGUID;
+            case DATA_LAVANTHOR:
+                return m_uiLavanthorGUID;
+            case DATA_ZURAMAT:
+                return m_uiZuramatGUID;
+            case DATA_SINCLARI:
+                return m_uiSinclariGUID;
+            case DATA_NPC_SEAL_DOOR:
+                return m_uiNPCSealDoorGUID;
+            case DATA_SEAL_DOOR:
+                return m_uiSealDoorGUID;
+            case DATA_EREKEM_DOOR:
+                return m_uiErekemDoorGUID;
+            case DATA_EREKEM_DOOR_L:
+                return m_uiErekemDoorLeftGUID;
+            case DATA_EREKEM_DOOR_R:
+                return m_uiErekemDoorRightGUID;
+            case DATA_MORAGG_DOOR:
+                return m_uiMoraggDoorGUID;
+            case DATA_ICHORON_DOOR:
+                return m_uiIchoronDoorGUID;
+            case DATA_XEVOZZ_DOOR:
+                return m_uiXevozzDoorGUID;
+            case DATA_LAVANTHOR_DOOR:
+                return m_uiLavanthorDoorGUID;
+            case DATA_ZURAMAT_DOOR:
+                return m_uiZuramatDoorGUID;
         }
+        return 0;
     }
-}
 
-void instance_violet_hold::ProcessActivationCrystal(Unit* pUser, bool bIsIntro)
-{
-    if (Creature* pSummon = pUser->SummonCreature(NPC_DEFENSE_SYSTEM, fDefenseSystemLoc[0], fDefenseSystemLoc[1], fDefenseSystemLoc[2], fDefenseSystemLoc[3], TEMPSUMMON_TIMED_DESPAWN, 10000))
+const char* Save()
     {
-        pSummon->CastSpell(pSummon, SPELL_DEFENSE_SYSTEM_VISUAL, true);
-
-        // TODO: figure out how the rest work
-        // NPC's NPC_DEFENSE_DUMMY_TARGET are probably channeling some spell to the defense system
+        return m_strInstData.c_str();
     }
 
-    if (bIsIntro)
-        DoUseDoorOrButton(m_uiIntroCrystalGUID);
-
-    // else, kill (and despawn?) certain trash mobs. Also boss affected, but not killed.
-}
-
-uint32 instance_violet_hold::GetRandomPortalEliteEntry()
-{
-    return (urand(0, 1) ? NPC_PORTAL_GUARDIAN : NPC_PORTAL_KEEPER);
-}
-
-uint32 instance_violet_hold::GetRandomMobForNormalPortal()
-{
-    switch(urand(1, 4))
+void Load(const char* strIn)
     {
-        case 1: return NPC_AZURE_INVADER;
-        case 2: return NPC_MAGE_HUNTER;
-        case 3: return NPC_AZURE_SPELLBREAKER;
-        case 4: return NPC_AZURE_BINDER;
-    }
-
-    return 0;
-}
+        if (!strIn)
+        {
+            OUT_LOAD_INST_DATA_FAIL;
+            return;
+        }
 
-uint64 instance_violet_hold::GetData64(uint32 uiData)
-{
-    return 0;
-}
+        OUT_LOAD_INST_DATA(strIn);
 
-void instance_violet_hold::Update(uint32 uiDiff)
-{
-    if (m_auiEncounter[0] != IN_PROGRESS)
-        return;
+        std::istringstream loadStream(strIn);
 
-    if (m_uiPortalTimer)
-    {
-        if (m_uiPortalTimer <= uiDiff)
+        for(uint8 i = 0; i < MAX_ENCOUNTER; ++i)
         {
-            DoUpdateWorldState(WORLD_STATE_PORTALS, ++m_uiWorldStatePortalCount);
+            loadStream >> m_auiEncounter[i];
 
-            SetPortalId();
-            SpawnPortal();
-
-            m_uiPortalTimer = 0;
+            if (m_auiEncounter[i] == IN_PROGRESS && i != 1)
+                m_auiEncounter[i] = NOT_STARTED;
         }
-        else
-            m_uiPortalTimer -= uiDiff;
+
+        OUT_LOAD_INST_DATA_COMPLETE;
     }
-}
+};
 
 InstanceData* GetInstanceData_instance_violet_hold(Map* pMap)
 {
@@ -404,6 +418,6 @@ void AddSC_instance_violet_hold()
     Script *newscript;
     newscript = new Script;
     newscript->Name = "instance_violet_hold";
-    newscript->GetInstanceData = GetInstanceData_instance_violet_hold;
+    newscript->GetInstanceData = &GetInstanceData_instance_violet_hold;
     newscript->RegisterSelf();
 }
diff --git a/scripts/northrend/violet_hold/violet_hold.cpp b/scripts/northrend/violet_hold/violet_hold.cpp
index d887d13..41d7287 100644
--- a/scripts/northrend/violet_hold/violet_hold.cpp
+++ b/scripts/northrend/violet_hold/violet_hold.cpp
@@ -15,348 +15,1092 @@
  */
 
 /* ScriptData
-SDName: Violet_Hold
-SD%Complete: 40
-SDComment:
-SDCategory: Violet Hold
+SDName: violet_hold
+SDAuthor: ckegg, modified by rsa
+SD%Complete: 60
+SDComment: 
+SDCategory: The Violet Hold
 EndScriptData */
 
-/* ContentData
-go_activation_crystal
-npc_door_seal
-npc_sinclari
-npc_teleportation_portal
-EndContentData */
-
 #include "precompiled.h"
 #include "violet_hold.h"
-#include "escort_ai.h"
+enum
+{
+    SPELL_TELEPORT_INSIDE                 = 62139,
+    SPELL_SHIELD_DISRUPTION               = 58291,
 
-/*######
-## go_activation_crystal
-######*/
+    //DRAGONS SPELLS
+    //Azure Captain
+    SPELL_MORTAL_STRIKE                   = 32736,
+    SPELL_WHIRLWIND                       = 41057,
 
-bool GOHello_go_activation_crystal(Player* pPlayer, GameObject* pGo)
-{
-    if (instance_violet_hold* pInstance = (instance_violet_hold*)pGo->GetInstanceData())
-        pInstance->ProcessActivationCrystal(pPlayer);
+    //Azure Raider
+    SPELL_CONCUSSION_BLOW                 = 52719,
+    SPELL_MAGIC_REFLECTION                = 60158,
 
-    return false;
-}
+    //Azure Sorceror
+    SPELL_ARCANE_STREAM                   = 60181,
+    SPELL_ARCANE_STREAM_H                 = 60204,
+    SPELL_MANA_DETONATION                 = 60182,
+    SPELL_MANA_DETONATION_H               = 60205,
 
-/*######
-## npc_door_seal
-######*/
+    //Azure stalker
+    SPELL_BACKSTAB                        = 58471,
+    SPELL_TACTICAL_BLINK                  = 58470,
 
-bool EffectDummyCreature_npc_door_seal(Unit* pCaster, uint32 uiSpellId, SpellEffectIndex uiEffIndex, Creature* pCreatureTarget)
-{
-    //always check spellid and effectindex
-    if (uiSpellId == SPELL_DESTROY_DOOR_SEAL && uiEffIndex == EFFECT_INDEX_0)
-    {
-        if (instance_violet_hold* pInstance = (instance_violet_hold*)pCreatureTarget->GetInstanceData())
-            pInstance->SetData(TYPE_SEAL, SPECIAL);
+    //Azure guardian
+    SPELL_AGONISING_STRIKE                  = 58504,
+    SPELL_SIDE_SWIPE                        = 58508,
 
-        //always return true when we are handling this spell and effect
-        return true;
-    }
+    //Azure keeper
+    SPELL_ARCANE_MISSILES                   = 58531,
+    SPELL_ARCANE_MISSILES_H                 = 61593,
+    SPELL_DEEP_FREEZE                       = 58534,
+    SPELL_FROSTBOLT_VOLLEY                  = 58532,
+    SPELL_FROSTBOLT_VOLLEY_H                = 61594,
 
-    return false;
-}
+    //Azure binder
+    SPELL_ARCANE_BARRAGE                    = 58456,
+    SPELL_ARCANE_BARRAGE_H                  = 59248,
+    SPELL_ARCANE_EXPLOSION                  = 58455,
+    SPELL_ARCANE_EXPLOSION_H                = 59245,
 
-/*######
-## npc_sinclari
-######*/
+    //Azure invader
+    SPELL_CLEAVE                            = 15496,
+    SPELL_IMPALE                            = 58459,
+    SPELL_IMPALE_H                          = 59256,
+
+    //Azure mageslayer
+    SPELL_ARCANE_EMPOWERMENT                = 58469,
+
+    //Azure spellbreaker
+    SPELL_ARCANE_BLAST                      = 58462,
+    SPELL_ARCANE_BLAST_H                    = 59257,
+    SPELL_SLOW                              = 25603,
+};
 
 enum
 {
     SAY_BEGIN                   = -1608000,
     SAY_LOCK_DOOR               = -1608001,
+    SAY_CYANIGOSA_SPAWN         = -1608005,
+    SAY_EREKEM_SPAWN            = -1608015,
+    SAY_ICHORON_SPAWN           = -1608023,
+    SAY_XEVOZZ_SPAWN            = -1608032,
+    SAY_ZURAMAT_SPAWN           = -1608042,
 
     GOSSIP_TEXT_ID_INTRO        = 13853,
     GOSSIP_TEXT_ID_START        = 13854,
 };
 
-#define GOSSIP_ITEM_INTRO       "Activate the crystals when we get in trouble, right?"
-#define GOSSIP_ITEM_START       "Get your people to safety, we'll keep the Blue Dragonflight's forces at bay."
-
-struct MANGOS_DLL_DECL npc_sinclariAI : public npc_escortAI
+uint32 m_uiNextPortal_Timer;
+/*######
+## mob_vh_dragons
+## This script is for ALL mobs which are spawned from portals,
+## they have to be scripted in SD2 because in EventAI you cant
+## check for distance from door seal :/
+## (Intro not implented yet)
+######*/
+struct MANGOS_DLL_DECL mob_vh_dragonsAI : public ScriptedAI
 {
-    npc_sinclariAI(Creature* pCreature) : npc_escortAI(pCreature)
+    mob_vh_dragonsAI(Creature* pCreature) : ScriptedAI(pCreature)
     {
-        m_pInstance = (instance_violet_hold*)pCreature->GetInstanceData();
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegular = pCreature->GetMap()->IsRegularDifficulty();
+        WayPointList.clear();
         Reset();
     }
 
-    instance_violet_hold* m_pInstance;
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegular;
+    uint32 creatureEntry;
+    uint32 motherPortalID;
+    uint32 WalkTimer;
+    int8 portalLoc;
+    bool IsWalking;
+    bool IsInCombat;
+    bool MovementStarted;
+    Creature* pDoorSeal;
 
-    void Reset()
-    {
-    }
+    std::list<WayPoints> WayPointList;
+    std::list<WayPoints>::iterator WayPoint;
+
+    //Azure Captain
+    uint32 m_uiMortalStrike_Timer;
+    uint32 m_uiWhirlwind_Timer;
+
+    //Azure Raider
+    uint32 m_uiConcussionBlow_Timer;
+    uint32 m_uiMagicReflection_Timer;
+
+    //Azure Sorceror
+    uint32 m_uiArcaneStream_Timer;
+    uint32 m_uiManaDetonation_Timer;
+
+    //Azure Stalker
+    uint32 m_uiBackstab_Timer;
+    uint32 m_uiBlink_Timer;
+
+    //Azure Guardian
+    uint32 m_uiAgonisingStrike_Timer;
+    uint32 m_uiSideSwipe_Timer;
+
+    //Azure Keepers
+    uint32 m_uiArcaneMissile_Timer;
+    uint32 m_uiFrostboltVolley_Timer;
+    uint32 m_uiDeepFreeze_Timer;
+
+    //Azure Binder
+    uint32 m_uiArcaneBarrage_Timer;
+    uint32 m_uiExplosion_Timer;
+
+    //Azure Invader
+    uint32 m_uiCleave_Timer;
+    uint32 m_uiImpale_Timer;
+
+    //Azure Mageslayer
+    uint32 m_uiArcaneEmpowerment_Timer;
 
-    void WaypointReached(uint32 uiPointId)
+    //Azure Spellbreaker
+    uint32 m_uiArcaneblast_Timer;
+    uint32 m_uiSlow_Timer;
+
+    void Reset(){
+        creatureEntry = m_creature->GetEntry();
+        motherPortalID = 0;
+        WalkTimer = 200;
+        portalLoc = -1;
+        IsWalking = false;
+        IsInCombat = false;
+        MovementStarted = false;
+        pDoorSeal = GetClosestCreatureWithEntry(m_creature, NPC_DOOR_SEAL, 150.0f);
+       
+        //Azure Captain
+        m_uiMortalStrike_Timer      = 3000;
+        m_uiWhirlwind_Timer         = 5000;
+
+        //Azure Raider
+        m_uiConcussionBlow_Timer    = 3000;
+        m_uiMagicReflection_Timer   = 10000;
+
+        //Azure Sorceror
+        m_uiArcaneStream_Timer      = 5000;
+        m_uiManaDetonation_Timer    = 3000;
+
+        //Azure Stalker
+        m_uiBackstab_Timer          = 7100;
+        m_uiBlink_Timer             = 7000;
+
+        //Azure Guardian
+        m_uiAgonisingStrike_Timer   = 10000;
+        m_uiSideSwipe_Timer         = 7000;
+
+        //Azure Keepers
+        m_uiArcaneMissile_Timer     = 5500;
+        m_uiFrostboltVolley_Timer   = 10000;
+        m_uiDeepFreeze_Timer        = 7500;
+
+        //Azure Binder
+        m_uiArcaneBarrage_Timer     = 5000;
+        m_uiExplosion_Timer         = 8000;
+
+        //Azure Invader
+        m_uiCleave_Timer            = 6000;
+        m_uiImpale_Timer            = 10000;
+
+        //Azure Mageslayer
+        m_uiArcaneEmpowerment_Timer = 7000;
+
+        //Azure Spellbreaker
+        m_uiArcaneblast_Timer       = 5000;
+        m_uiSlow_Timer              = 9000;
+    }
+    void StartMovement()
     {
-        if (!m_pInstance)
+        if(!WayPointList.empty() || MovementStarted)
             return;
 
-        switch(uiPointId)
+        uint8 start = 0;
+        uint8 end = 0;
+        switch(portalLoc)
         {
+            case -1:
+                return;
+            //center & ichoron
             case 0:
-                m_pInstance->ProcessActivationCrystal(m_creature, true);
+            case 5:
+                start = 0;
+                end = 2;
                 break;
+            //From lavanthor
             case 1:
-                DoScriptText(SAY_BEGIN, m_creature);
-                m_pInstance->SetIntroPortals(true);
-                m_pInstance->CallGuards(false);
+                start = 3;
+                end = 5;
                 break;
+            // From Zuramat
             case 2:
-                DoScriptText(SAY_LOCK_DOOR, m_creature);
-                m_pInstance->SetData(TYPE_MAIN, IN_PROGRESS);
+                start = 6;
+                end = 11;
+                break;
+            //From Moragg
+            case 3:
+                start = 12;
+                end = 16;
+                break;
+            //From Erekem
+            case 4:
+                start = 17;
+                end = 21;
+                break;
+            //From highest platform
+            case 6:
+                start = 22;
+                end = 26;
                 break;
         }
-    }
+        uint8 wpId = 0;
+        for(uint8 i = start; i <= end; ++i){
+            debug_log("AddWP: %u", i);
+            AddWaypoint(wpId, DragonsWP[i].x, DragonsWP[i].y, DragonsWP[i].z);
+            wpId++;
+        }
 
-    void JustRespawned()
+        WayPoint = WayPointList.begin();
+        m_creature->AddSplineFlag(SPLINEFLAG_WALKMODE);
+        IsWalking = true;
+        MovementStarted = true;
+    }
+    void AddWaypoint(uint32 id, float x, float y, float z)
     {
-        if (m_pInstance)
-            m_pInstance->SetData(TYPE_MAIN, NOT_STARTED);
+        WayPoints DWP(id, x, y, z);
+        WayPointList.push_back(DWP);
     }
-};
+    void MovementInform(uint32 uiType, uint32 uiPointId)
+    {
+        if(uiType != POINT_MOTION_TYPE || creatureEntry == NPC_GUARDIAN || creatureEntry == NPC_KEEPER)
+            return;
 
-CreatureAI* GetAI_npc_sinclari(Creature* pCreature)
-{
-    return new npc_sinclariAI(pCreature);
-}
+        if(WayPoint->id != uiPointId)
+            return;
 
-bool GossipHello_npc_sinclari(Player* pPlayer, Creature* pCreature)
-{
-    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_ITEM_INTRO, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
-    pPlayer->SEND_GOSSIP_MENU(GOSSIP_TEXT_ID_INTRO, pCreature->GetGUID());
-    return true;
-}
+        ++WayPoint;
+        WalkTimer = 200;
+    }
+    void UpdateAI(const uint32 uiDiff){
+        if(portalLoc != -1)
+            StartMovement();
 
-bool GossipSelect_npc_sinclari(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
-{
-    if (uiAction == GOSSIP_ACTION_INFO_DEF+1)
-    {
-        if (instance_violet_hold* pInstance = (instance_violet_hold*)pCreature->GetInstanceData())
+        if (IsWalking && WalkTimer)
         {
-            if (pInstance->GetData(TYPE_MAIN) == NOT_STARTED)
+            if (WalkTimer <= uiDiff)
             {
-                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_ITEM_START, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
-                pPlayer->SEND_GOSSIP_MENU(GOSSIP_TEXT_ID_START, pCreature->GetGUID());
+                if (WayPoint != WayPointList.end())
+                {
+                    m_creature->GetMotionMaster()->MovePoint(WayPoint->id, WayPoint->x, WayPoint->y,WayPoint->z);
+                    WalkTimer = 0;
+                }
+            }else WalkTimer -= uiDiff;
+        }
+
+        //Corrupt Seal
+        if(pDoorSeal && !IsInCombat){
+            if(m_creature->IsWithinDist(pDoorSeal, 27.0f, false))
+            {
+                IsWalking = false;
+                WayPointList.clear();
+                m_creature->GetMotionMaster()->Clear(false);
+                m_creature->RemoveSplineFlag(SPLINEFLAG_WALKMODE);
+                DoCast(pDoorSeal, SPELL_CORRUPT);
+                m_pInstance->SetData(TYPE_DOOR,SPECIAL);
             }
         }
-        else
-            pPlayer->CLOSE_GOSSIP_MENU();
+        if(!IsWalking && !IsInCombat) {
+                if (Unit* m_uEmbraceTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                m_creature->GetMotionMaster()->MoveChase(m_uEmbraceTarget);
+                m_creature->SetInCombatWithZone();
+                IsInCombat = true;
+                }
+
+        //Return since we have no target
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if(m_creature->getVictim())
+            if(m_creature->getVictim()->GetEntry() == NPC_DOOR_SEAL)
+                return;
+        switch(creatureEntry)
+        {
+            case NPC_AZURE_CAPTAIN:
+                AzureCaptain_UpdateAI(uiDiff);
+                break;
+            case NPC_AZURE_RAIDER:
+                AzureRaider_UpdateAI(uiDiff);
+                break;
+            case NPC_AZURE_SORCEROR:
+                AzureSorceror_UpdateAI(uiDiff);
+                break;
+            case NPC_AZURE_STALKER:
+                AzureStalker_UpdateAI(uiDiff);
+                break;
+            case NPC_GUARDIAN:
+                AzureGuardian_UpdateAI(uiDiff);
+                break;
+            case NPC_KEEPER:
+                AzureKeeper_UpdateAI(uiDiff);
+                break;
+            case NPC_AZURE_BINDER:
+                AzureBinder_UpdateAI(uiDiff);
+                break;
+            case NPC_AZURE_INVADER:
+                AzureInvader_UpdateAI(uiDiff);
+                break;
+            case NPC_AZURE_MAGE_SLAYER:
+                AzureMageslayer_UpdateAI(uiDiff);
+                break;
+            case NPC_AZURE_SPELLBREAKER:
+                AzureSpellbreaker_UpdateAI(uiDiff);
+                break;
+            default:
+                debug_log("SD2: The Violet Hold: Unhandled dragon entry %u!", m_creature->GetEntry());
+                break;
+        }
+        DoMeleeAttackIfReady();
     }
+    //Azure Captain
+    void AzureCaptain_UpdateAI(const uint32 uiDiff)
+    {
+        //Mortal Strike
+        if (m_uiMortalStrike_Timer <= uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_MORTAL_STRIKE);
+            m_uiMortalStrike_Timer = 6000;
+        }else m_uiMortalStrike_Timer -= uiDiff;
 
-    if (uiAction == GOSSIP_ACTION_INFO_DEF+2)
+        //Whirlwind
+        if (m_uiWhirlwind_Timer <= uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_WHIRLWIND);
+            m_uiWhirlwind_Timer = 15000;
+        }else m_uiWhirlwind_Timer -= uiDiff;
+    }
+    //Azure Raider
+    void AzureRaider_UpdateAI(const uint32 uiDiff)
     {
-        if (instance_violet_hold* pInstance = (instance_violet_hold*)pCreature->GetInstanceData())
+        //Concusion Blow
+        if (m_uiConcussionBlow_Timer <= uiDiff)
         {
-            pPlayer->CLOSE_GOSSIP_MENU();
+            DoCast(m_creature->getVictim(), SPELL_CONCUSSION_BLOW);
+            m_uiMortalStrike_Timer = 7000;
+        }else m_uiConcussionBlow_Timer -= uiDiff;
 
-            if (pInstance->GetData(TYPE_MAIN) == NOT_STARTED)
-            {
-                pInstance->SetData(TYPE_MAIN, SPECIAL);
+        //Magic reflection
+        if (m_uiMagicReflection_Timer <= uiDiff)
+        {
+            DoCast(m_creature, SPELL_MAGIC_REFLECTION);
+            m_uiMagicReflection_Timer = 30000;
+        }else m_uiMagicReflection_Timer -= uiDiff;
+    }
+    //Azure Sorceror
+    void AzureSorceror_UpdateAI(const uint32 uiDiff)
+    {
+        //Arcane Stream
+        if (m_uiArcaneStream_Timer <= uiDiff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(pTarget, m_bIsRegular ? SPELL_ARCANE_STREAM : SPELL_ARCANE_STREAM_H);
+            m_uiArcaneStream_Timer = 7000;
+        }else m_uiArcaneStream_Timer -= uiDiff;
 
-                if (npc_sinclariAI* pEscortAI = dynamic_cast<npc_sinclariAI*>(pCreature->AI()))
-                    pEscortAI->Start(false);
-            }
-        }
-        else
-            pPlayer->CLOSE_GOSSIP_MENU();
+        //Mana Detonation
+        if (m_uiManaDetonation_Timer <= uiDiff)
+        {
+            DoCast(m_creature, m_bIsRegular ? SPELL_MANA_DETONATION : SPELL_MANA_DETONATION_H);
+            m_uiManaDetonation_Timer = 18000;
+        }else m_uiManaDetonation_Timer -= uiDiff;
     }
+    //Azure Stalker
+    void AzureStalker_UpdateAI(const uint32 uiDiff)
+    {
+        //Backstab
+        if (m_uiBackstab_Timer <= uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_BACKSTAB);
+            m_uiBackstab_Timer = 15100;
+        }else m_uiBackstab_Timer -= uiDiff;
 
-    return true;
-}
+        //Tactical blink
+        if (m_uiBlink_Timer <= uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_TACTICAL_BLINK);
+            m_uiBlink_Timer = 15000;
+        }else m_uiBlink_Timer -= uiDiff;
+    }
+
+    //Azure Guardian
+    void AzureGuardian_UpdateAI(const uint32 uiDiff)
+    {
+        //Agonising Strike
+        if (m_uiAgonisingStrike_Timer <= uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_AGONISING_STRIKE);
+            m_uiAgonisingStrike_Timer = 15100;
+        }else m_uiAgonisingStrike_Timer -= uiDiff;
+
+        //SideSwipe
+        if (m_uiSideSwipe_Timer <= uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_SIDE_SWIPE);
+            m_uiSideSwipe_Timer = 10000;
+        }else m_uiSideSwipe_Timer -= uiDiff;
+    }
+
+    //Azure Keeper
+    void AzureKeeper_UpdateAI(const uint32 uiDiff)
+    {
+        //ArcaneMissile
+        if (m_uiArcaneMissile_Timer <= uiDiff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(pTarget, m_bIsRegular ? SPELL_ARCANE_MISSILES : SPELL_ARCANE_MISSILES_H);
+            m_uiArcaneMissile_Timer = 10000;
+        }else m_uiArcaneMissile_Timer -= uiDiff;
+
+        //Frostbolt volley
+        if (m_uiFrostboltVolley_Timer <= uiDiff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsRegular ? SPELL_FROSTBOLT_VOLLEY : SPELL_FROSTBOLT_VOLLEY_H);
+            m_uiFrostboltVolley_Timer = 16000;
+        }else m_uiFrostboltVolley_Timer -= uiDiff;
+
+        //Deep freeze
+        if (m_uiDeepFreeze_Timer <= uiDiff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(pTarget, SPELL_DEEP_FREEZE);
+            m_uiDeepFreeze_Timer = 14000;
+        }else m_uiDeepFreeze_Timer -= uiDiff;
+    }
+
+    //Azure Binder
+    void AzureBinder_UpdateAI(const uint32 uiDiff)
+    {
+        //Arcane barrage
+        if (m_uiArcaneBarrage_Timer <= uiDiff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(pTarget, m_bIsRegular ? SPELL_ARCANE_BARRAGE : SPELL_ARCANE_BARRAGE_H);
+            m_uiArcaneBarrage_Timer = 8100;
+        }else m_uiArcaneBarrage_Timer -= uiDiff;
+
+        //Arcane explosion
+        if (m_uiExplosion_Timer <= uiDiff)
+        {
+            DoCast(m_creature, m_bIsRegular ? SPELL_ARCANE_EXPLOSION : SPELL_ARCANE_EXPLOSION_H);
+            m_uiExplosion_Timer = 13000;
+        }else m_uiExplosion_Timer -= uiDiff;
+    }
+
+    //Azure Invader
+    void AzureInvader_UpdateAI(const uint32 uiDiff)
+    {
+        //Cleave
+        if (m_uiCleave_Timer <= uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_CLEAVE);
+            m_uiCleave_Timer = 7100;
+        }else m_uiCleave_Timer -= uiDiff;
+
+        //Impale
+        if (m_uiImpale_Timer <= uiDiff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(pTarget, m_bIsRegular ? SPELL_IMPALE : SPELL_IMPALE_H);
+            m_uiImpale_Timer = 13000;
+        }else m_uiImpale_Timer -= uiDiff;
+    }
+
+    //Azure Mage slayer
+    void AzureMageslayer_UpdateAI(const uint32 uiDiff)
+    {
+        //Arcane empowerment
+        if (m_uiArcaneEmpowerment_Timer <= uiDiff)
+        {
+            DoCast(m_creature, SPELL_ARCANE_EMPOWERMENT);
+            m_uiArcaneEmpowerment_Timer = 13100;
+        }else m_uiArcaneEmpowerment_Timer -= uiDiff;
+    }
+
+    //Azure Spell breaker
+    void AzureSpellbreaker_UpdateAI(const uint32 uiDiff)
+    {
+        //Arcane blast
+        if (m_uiArcaneblast_Timer <= uiDiff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(pTarget, m_bIsRegular ? SPELL_ARCANE_BLAST : SPELL_ARCANE_BLAST_H);
+            m_uiArcaneblast_Timer = 10100;
+        }else m_uiArcaneblast_Timer -= uiDiff;
+
+        //Slow
+        if (m_uiSlow_Timer <= uiDiff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(pTarget, SPELL_SLOW);
+            m_uiSlow_Timer = 15000;
+        }else m_uiSlow_Timer -= uiDiff;
+    }
+};
 
 /*######
-## npc_teleportation_portal
+## npc_violet_portal
 ######*/
-
-struct MANGOS_DLL_DECL npc_teleportation_portalAI : public ScriptedAI
+struct MANGOS_DLL_DECL npc_violet_portalAI : public ScriptedAI
 {
-    npc_teleportation_portalAI(Creature* pCreature) : ScriptedAI(pCreature)
+    npc_violet_portalAI(Creature* pCreature) : ScriptedAI(pCreature)
     {
-        m_pInstance = (instance_violet_hold*)pCreature->GetInstanceData();
-        m_uiMyPortalNumber = 0;
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
         Reset();
     }
 
-    instance_violet_hold* m_pInstance;
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+    bool m_uiGroupSpawned;
+    uint8 portalType; // 0 = nothing, 1 = Guard & spawns, 2 = Group of elites
+    uint32 portalID; // To identify portal...
+    int8 portalLoc;
 
-    std::set<uint64> m_lMobSet;
-
-    bool m_bNeedInvisible;
-    bool m_bIntro;
-    uint32 m_uiIntroTimer;
-    uint32 m_uiMyPortalNumber;
+    uint32 TimeRiftWave_Timer;
+    uint32 Check_Timer;
 
     void Reset()
     {
-        m_bNeedInvisible = false;
-        m_bIntro = false;
-        m_uiIntroTimer = 10000;
-
-        if (m_pInstance)
-            m_uiMyPortalNumber = m_pInstance->GetCurrentPortalNumber();
+        m_uiGroupSpawned = false;
+        portalType = 0;
+        portalID = 0;
+        portalLoc = -1;
+        
+        TimeRiftWave_Timer = 15000;
+        Check_Timer = 5000;
     }
-
-    void DoSummon()
+    uint32 SelectRandSummon()
     {
-        if (m_creature->GetEntry() == NPC_PORTAL_INTRO)
+        uint32 entry = 0;
+        if(portalType == 1)
         {
-            //not made yet
+            switch (urand(0, 3))
+            {
+                case 0: entry = NPC_AZURE_BINDER; break;
+                case 1: entry = NPC_AZURE_INVADER; break;
+                case 2: entry = NPC_AZURE_MAGE_SLAYER; break;
+                case 3: entry = NPC_AZURE_SPELLBREAKER; break;
+            }      
+        }else{
+            switch (urand(0, 3))
+            {
+                case 0: entry = NPC_AZURE_CAPTAIN; break;
+                case 1: entry = NPC_AZURE_RAIDER; break;
+                case 2: entry = NPC_AZURE_SORCEROR; break;
+                case 3: entry = NPC_AZURE_STALKER; break;
+            }    
+        }
+        return entry;
+    }
+    void SpawnGroup()
+    {
+        if(portalType == 0)
             return;
+
+        uint8 uiSpawnCount = (m_pInstance->GetData(TYPE_RIFT) < 12) ? 3 : 4;
+        for(uint8 i = 0; i < uiSpawnCount; i++)
+        {
+            uint32 uiSpawnEntry = SelectRandSummon();
+            if(Creature* pSummoned = m_creature->SummonCreature(uiSpawnEntry, m_creature->GetPositionX()-5+rand()%10, m_creature->GetPositionY()-5+rand()%10, m_creature->GetPositionZ(), 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 30000))
+            {
+                debug_log("Spawn NPC %u, motherPortalID %u, portalLoc %u", uiSpawnEntry, portalID, portalLoc);
+                ((mob_vh_dragonsAI*)pSummoned->AI())->motherPortalID = portalID;
+                ((mob_vh_dragonsAI*)pSummoned->AI())->portalLoc = portalLoc;
+            }
         }
-        else if (m_creature->GetEntry() == NPC_PORTAL)
+    }
+    bool IsThereNearElite(float range)
+    {
+        //Azure captain
+        if(Creature* pTemp = GetClosestCreatureWithEntry(m_creature, NPC_AZURE_CAPTAIN, range))
         {
-            m_creature->SummonCreature(m_pInstance->GetRandomPortalEliteEntry(), 0.0f, 0.0f, 0.0f, 0.0f, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 600*IN_MILLISECONDS);
-            m_creature->CastSpell(m_creature, SPELL_PORTAL_PERIODIC, true);
+            if(((mob_vh_dragonsAI*)pTemp->AI())->motherPortalID == portalID)
+                return true;
         }
-        else if (m_pInstance->IsCurrentPortalForTrash())
+        //Azure raider
+        else if(Creature* pTemp = GetClosestCreatureWithEntry(m_creature, NPC_AZURE_RAIDER, range))
         {
-            for(uint8 i = 0; i < 4; ++i)
-            {
-                uint32 uiSummonId;
-
-                switch(i)
-                {
-                    case 0: uiSummonId = NPC_AZURE_CAPTAIN; break;
-                    case 1: uiSummonId = NPC_AZURE_RAIDER; break;
-                    case 2: uiSummonId = NPC_AZURE_SORCEROR; break;
-                    case 3: uiSummonId = NPC_AZURE_STALKER; break;
-                }
-
-                m_creature->SummonCreature(uiSummonId, 0.0f, 0.0f, 0.0f, 0.0f, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 600*IN_MILLISECONDS);
-            }
-
-            m_bNeedInvisible = true;
+            if(((mob_vh_dragonsAI*)pTemp->AI())->motherPortalID == portalID)
+                return true;
         }
-        else
+        //Azure sorceror
+        else if(Creature* pTemp = GetClosestCreatureWithEntry(m_creature, NPC_AZURE_SORCEROR, range))
         {
-            m_creature->SummonCreature(NPC_AZURE_SABOTEUR, 0.0f, 0.0f, 0.0f, 0.0f, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 600*IN_MILLISECONDS);
-            m_bNeedInvisible = true;
+            if(((mob_vh_dragonsAI*)pTemp->AI())->motherPortalID == portalID)
+                return true;
         }
+        //Azure Stalker
+        else if(Creature* pTemp = GetClosestCreatureWithEntry(m_creature, NPC_AZURE_STALKER, range))
+        {
+            if(((mob_vh_dragonsAI*)pTemp->AI())->motherPortalID == portalID)
+                return true;
+        }
+        return false;
     }
-
-    void JustSummoned(Creature* pSummoned)
+    void UpdateAI(const uint32 diff)
     {
-        switch(pSummoned->GetEntry())
+        if (!m_pInstance)
+            return;
+
+        if(m_pInstance->GetData(TYPE_EVENT) != IN_PROGRESS)
+            return;
+
+        switch(portalType)
         {
-            case NPC_PORTAL_GUARDIAN:
-                DoScriptText(EMOTE_GUARDIAN_PORTAL, pSummoned);
-                m_creature->CastSpell(pSummoned, SPELL_PORTAL_CHANNEL, false);
-                break;
-            case NPC_PORTAL_KEEPER:
-                DoScriptText(EMOTE_KEEPER_PORTAL, pSummoned);
-                m_creature->CastSpell(pSummoned, SPELL_PORTAL_CHANNEL, false);
+            case 0:
+                return;
+            case 1:
+                if (TimeRiftWave_Timer < diff)
+                {
+                    debug_log("SpawnGroup()");
+                    SpawnGroup();
+                    TimeRiftWave_Timer = 15000;
+                }else TimeRiftWave_Timer -= diff;
+
+                if (!m_creature->IsNonMeleeSpellCasted(false))
+                {
+                    m_uiNextPortal_Timer = 5000;
+                    debug_log("SD2: npc_time_rift: not casting anylonger, i need to die.");
+                    m_creature->setDeathState(JUST_DIED);
+                }
                 break;
-            case NPC_AZURE_CAPTAIN:
-                DoScriptText(EMOTE_DRAGONFLIGHT_PORTAL, pSummoned);
-                m_lMobSet.insert(pSummoned->GetGUID());
+            case 2:
+                if(!m_uiGroupSpawned)
+                {
+                    SpawnGroup();
+                    m_uiGroupSpawned = true;
+                }
+                if (Check_Timer < diff)
+                {
+                    if(!IsThereNearElite(150.0f))
+                    {
+                        m_uiNextPortal_Timer = 5000;
+                        debug_log("SD2: npc_time_rift: No elite, i need to die.");
+                        m_creature->setDeathState(JUST_DIED);
+                    }
+                    Check_Timer = 1000;
+                }else Check_Timer -= diff;
                 break;
-            case NPC_AZURE_RAIDER:
-            case NPC_AZURE_SORCEROR:
-            case NPC_AZURE_STALKER:
-                m_lMobSet.insert(pSummoned->GetGUID());
-                return;
-            default:
-                return;
         }
-
-        if (m_pInstance)
-            m_pInstance->SetData(TYPE_PORTAL, SPECIAL);
     }
-
-    void SummonedCreatureJustDied(Creature* pSummoned)
+};
+/*######
+## npc_sinclari
+######*/
+struct MANGOS_DLL_DECL npc_sinclariAI : public ScriptedAI
+{
+    npc_sinclariAI(Creature *pCreature) : ScriptedAI(pCreature)
     {
-        switch(pSummoned->GetEntry())
-        {
-            case NPC_PORTAL_GUARDIAN:
-            case NPC_PORTAL_KEEPER:
-                break;
-            case NPC_AZURE_CAPTAIN:
-            case NPC_AZURE_RAIDER:
-            case NPC_AZURE_SORCEROR:
-            case NPC_AZURE_STALKER:
-            {
-                m_lMobSet.erase(pSummoned->GetGUID());
+        m_pInstance = ((ScriptedInstance*)pCreature->GetInstanceData());
+        m_creature->SetHealth(m_creature->GetMaxHealth());
+        m_creature->SetStandFlags(UNIT_STAND_STATE_STAND);
+        Reset();
+    }
+    ScriptedInstance *m_pInstance;
 
-                if (!m_lMobSet.empty())
-                    return;
+    uint8 m_uiRiftPortalCount;
+    uint8 m_bIsRegular;
+    uint32 m_uiBossCheck_Timer;
+    uint32 m_uiPortalCheck_Timer;
 
-                break;
-            }
-            default:
-                return;
+    void Reset()
+    {
+        m_uiRiftPortalCount = 0;
+        m_uiNextPortal_Timer = 0;
+        m_uiBossCheck_Timer = 0;
+        m_uiPortalCheck_Timer = 1000;
+        m_bIsRegular = m_creature->GetMap()->IsRegularDifficulty();
+    }
+
+    void SetEvent()
+    {
+        //m_creature->SetUInt32Value(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_NONE);
+        m_uiNextPortal_Timer = 5000;
+        m_creature->GetMotionMaster()->MovePoint(0, 1815.571f, 800.112f, 44.364f);
+        if (m_pInstance){
+            m_pInstance->SetData(TYPE_EVENT, IN_PROGRESS);
+            m_pInstance->DoUseDoorOrButton(m_pInstance->GetData64(DATA_SEAL_DOOR));
         }
+    }
 
-        if (m_pInstance)
+    void DoSpawnPortal()
+    {
+        int tmp = urand(1, 6);
+        if (Creature* pTemp = m_creature->SummonCreature(NPC_PORTAL, PortalLoc[tmp].x, PortalLoc[tmp].y, PortalLoc[tmp].z, 0, TEMPSUMMON_CORPSE_DESPAWN, 0))
         {
-            // no need if a new portal was made while this was in progress
-            if (m_uiMyPortalNumber == m_pInstance->GetCurrentPortalNumber())
-                m_pInstance->SetData(TYPE_PORTAL, DONE);
-        }
+            pTemp->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            pTemp->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
 
-        m_creature->ForcedDespawn();
+            //set portal type
+            uint8 portalType = rand()%2+1;
+            uint32 portalID = rand()%50000;
+            ((npc_violet_portalAI*)pTemp->AI())->portalType = portalType; 
+            ((npc_violet_portalAI*)pTemp->AI())->portalID = portalID;
+            ((npc_violet_portalAI*)pTemp->AI())->portalLoc = tmp;
+            
+            if(portalType == 1)
+            {
+                uint32 entry = urand(0, 1) ? NPC_GUARDIAN : NPC_KEEPER;
+                if (Creature* pSummoned = pTemp->SummonCreature(entry, PortalLoc[tmp].x, PortalLoc[tmp].y, PortalLoc[tmp].z, pTemp->GetOrientation(), TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 600000))
+                {
+                    pSummoned->AddThreat(pTemp);
+                    pTemp->CastSpell(pSummoned, SPELL_PORTAL_CHANNEL,false);
+                    ((mob_vh_dragonsAI*)pSummoned->AI())->motherPortalID = portalID;
+                }
+            }
+        }
     }
 
     void UpdateAI(const uint32 uiDiff)
     {
-        if (m_uiIntroTimer)
+        if(m_pInstance->GetData(TYPE_EVENT) != IN_PROGRESS)
+            return;
+
+        if (m_uiNextPortal_Timer && m_pInstance->GetData(TYPE_RIFT) != DONE)
         {
-            if (m_uiIntroTimer <= uiDiff)
+            if (m_uiNextPortal_Timer <= uiDiff)
             {
-                if (!m_pInstance)
+                ++m_uiRiftPortalCount;
+                if (m_pInstance && m_uiRiftPortalCount <= 18)
+                {
+                    m_pInstance->DoUpdateWorldState(WORLD_STATE_VH_PORTALS, m_uiRiftPortalCount);
+                    m_pInstance->SetData(TYPE_RIFT, SPECIAL);
+                }
+                /* this is all bosses version -> switched to blizzlike version
+                if ( m_uiRiftPortalCount != 3
+                    && m_uiRiftPortalCount != 6
+                    && m_uiRiftPortalCount != 9 
+                    && m_uiRiftPortalCount != 12 
+                    && m_uiRiftPortalCount != 15 
+                    && m_uiRiftPortalCount != 18
+                    && m_uiRiftPortalCount < 19 )
+                    */
+                if (m_uiRiftPortalCount != 6 && m_uiRiftPortalCount != 12 && m_uiRiftPortalCount != 18 && m_uiRiftPortalCount < 19)
                 {
-                    m_creature->ForcedDespawn();
-                    return;
+                    DoSpawnPortal();
+                    if (m_uiRiftPortalCount < 12)
+                        m_uiNextPortal_Timer = 120000;
+                    else
+                        m_uiNextPortal_Timer = 90000;
                 }
+                /*
+                else if ( m_uiRiftPortalCount == 3 
+                         || m_uiRiftPortalCount == 6
+                         || m_uiRiftPortalCount == 9
+                         || m_uiRiftPortalCount == 12
+                         || m_uiRiftPortalCount == 15
+                         || m_uiRiftPortalCount == 18 )
+                         */
+                else if (m_uiRiftPortalCount == 6 || m_uiRiftPortalCount == 12)
+                {
+                    if (Creature* pTemp = m_creature->SummonCreature(NPC_PORTAL, PortalLoc[0].x, PortalLoc[0].y, PortalLoc[0].z, 0, TEMPSUMMON_TIMED_DESPAWN, 1500))
+                    {
+                        Creature* pSummoned = m_creature->SummonCreature(NPC_AZURE_SABOTEUR, PortalLoc[0].x, PortalLoc[0].y, PortalLoc[0].z, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 30000);
 
-                m_uiIntroTimer = 0;
+                        pSummoned->AddThreat(pTemp);
+                        pTemp->CastSpell(pSummoned, SPELL_PORTAL_CHANNEL, false);
+                    }
+                    m_pInstance->SetData(TYPE_RIFT, IN_PROGRESS);
+                    m_uiBossCheck_Timer = 1000;
+                    m_uiNextPortal_Timer =  m_bIsRegular ? 180000 : 120000;
+                }
+                else if (m_uiRiftPortalCount == 18)
+                {
+                    if(Creature *Cyanigosa = GetClosestCreatureWithEntry(m_creature, NPC_CYANIGOSA, 100.0f))
+                    //if(Creature *Cyanigosa = m_creature->SummonCreature(NPC_CYANIGOSA, PortalLoc[0].x, PortalLoc[0].y, PortalLoc[0].z, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 180000))
+                    {
+                        DoScriptText(SAY_CYANIGOSA_SPAWN, Cyanigosa);
+                        Cyanigosa->setFaction(14);
+                        Cyanigosa->SetVisibility(VISIBILITY_ON);
+                    }
+                    if (m_pInstance)
+                    {
+                        m_pInstance->SetData(TYPE_RIFT, DONE);
+                        m_pInstance->SetData(TYPE_DISRUPTIONS, 20);
+                        m_creature->ForcedDespawn();
+                    }
+                    m_uiNextPortal_Timer = 0;
+                }
             }
             else
-            {
-                m_uiIntroTimer -= uiDiff;
-                return;
-            }
-        }
+                m_uiNextPortal_Timer -= uiDiff;
 
-        if (!m_bIntro)
-        {
-            DoSummon();
-            m_bIntro = true;
+            return;
         }
 
-        if (m_bNeedInvisible)
+        if (m_uiBossCheck_Timer)
         {
-            // hack; find a better way
-            m_creature->SetVisibility(VISIBILITY_OFF);
-            m_bNeedInvisible = false;
+            if (m_uiBossCheck_Timer <= uiDiff)
+            {
+                if (!m_pInstance->GetData(DATA_BOSSTIME))
+                    m_uiNextPortal_Timer = 10000;
+                m_uiBossCheck_Timer = 1000;
+            }
+            else
+                m_uiBossCheck_Timer -= uiDiff;
+
+            return;
         }
     }
 };
 
-CreatureAI* GetAI_npc_teleportation_portal(Creature* pCreature)
+#define GOSSIP_ITEM_INTRO   "Activate the crystals when we get in trouble, right."
+#define GOSSIP_ITEM_START   "Get your people to safety, we'll keep the Blue Dragonflight's forces at bay."
+#define GOSSIP_ITEM_TELE_IN "I need to go in!"
+
+bool GossipHello_npc_sinclari(Player* pPlayer, Creature* pCreature)
 {
-    return new npc_teleportation_portalAI(pCreature);
+    ScriptedInstance* m_pInstance;
+    m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+
+    if (pCreature->isQuestGiver())
+        pPlayer->PrepareQuestMenu( pCreature->GetGUID() );
+
+    if(m_pInstance->GetData(TYPE_EVENT) == NOT_STARTED){
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_ITEM_START, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+    }else{
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_ITEM_TELE_IN, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+    }
+    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+
+    return true;
 }
 
-bool EffectDummyCreature_npc_teleportation_portal(Unit* pCaster, uint32 uiSpellId, SpellEffectIndex uiEffIndex, Creature* pCreatureTarget)
+bool GossipSelect_npc_sinclari(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
 {
-    //always check spellid and effectindex
-    if (uiSpellId == SPELL_PORTAL_PERIODIC && uiEffIndex == EFFECT_INDEX_0)
+    switch (uiAction)
     {
-        if (instance_violet_hold* pInstance = (instance_violet_hold*)pCreatureTarget->GetInstanceData())
-            pCreatureTarget->SummonCreature(pInstance->GetRandomMobForNormalPortal(), 0.0f, 0.0f, 0.0f, 0.0f, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 600*IN_MILLISECONDS);
+        case GOSSIP_ACTION_INFO_DEF+1:
+            pPlayer->CLOSE_GOSSIP_MENU();
+            ((npc_sinclariAI*)pCreature->AI())->SetEvent();
+            break;
+        case GOSSIP_ACTION_INFO_DEF+2:
+            pPlayer->CLOSE_GOSSIP_MENU();
+            pPlayer->CastSpell(pPlayer, SPELL_TELEPORT_INSIDE, false);
+    }
+    return true;
+}
+/*######
+## npc_door_seal_vh
+######*/
+struct MANGOS_DLL_DECL npc_door_sealAI : public ScriptedAI
+{
+    npc_door_sealAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();   
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+
+    uint32 CheckTimer;
+    uint32 SpellCorrupt_Timer;
+    uint8 lastPortal;
 
-        //always return true when we are handling this spell and effect
-        return true;
+    void Reset()
+    {
+        CheckTimer = 0;
+        SpellCorrupt_Timer = 0;
+        lastPortal = 0;
+}
+    void SpellHit(Unit* caster, const SpellEntry* spell)
+    {
+        if (SpellCorrupt_Timer)
+            return;
+
+        if (spell->Id == SPELL_CORRUPT) {
+            SpellCorrupt_Timer = 1000;
+            }
+    }
+    void JustDied(Unit* pKiller)
+    {
+        m_creature->Respawn();
     }
 
-    return false;
+    void UpdateAI(const uint32 diff){
+        if (SpellCorrupt_Timer)
+        {
+            if (SpellCorrupt_Timer <= diff)
+            {
+                if (m_creature->HasAura(SPELL_CORRUPT,EFFECT_INDEX_0))
+                    SpellCorrupt_Timer = 1500;
+                else
+                    SpellCorrupt_Timer = 0;
+            }else SpellCorrupt_Timer -= diff;
+        }
+    }
+};
+
+/*######
+## npc_azure_saboteur
+######*/
+struct MANGOS_DLL_DECL npc_azure_saboteurAI : public ScriptedAI
+{
+    npc_azure_saboteurAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = ((ScriptedInstance*)pCreature->GetInstanceData());
+        Reset();
+    }
+    ScriptedInstance *m_pInstance;
+
+    bool m_bIsActiving;
+
+    uint32 m_uiDisruption_Timer;
+    uint32 m_uiDisruptionCounter;
+    uint32 m_uiDisruptionsCount;
+
+    uint8 m_uiBossID;
+    uint8 m_bIsRegular;
+    uint32 m_uiBossType;
+    uint64 m_uiBossGUID;
+    uint64 m_uiDoorGUID;
+
+    void AttackStart(Unit* pWho)
+    {
+        return;
+    }
+
+    void Reset()
+    {
+        m_bIsActiving = false;
+
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_creature->RemoveSplineFlag(SPLINEFLAG_WALKMODE);
+        m_uiDisruptionCounter = 0;
+        m_uiDisruptionsCount = 0;
+        m_uiDisruption_Timer = 1000;
+//        m_bIsRegular = m_creature->GetMap()->IsRegularDifficulty();
+
+        if (m_pInstance)
+        {
+            m_uiBossID = m_pInstance->GetData(TYPE_LASTBOSS);
+            m_uiDisruptionsCount = m_pInstance->GetData(TYPE_DISRUPTIONS);
+            switch (m_uiBossID)
+            {
+                case 6: // Lavanthor
+                    m_uiBossType = TYPE_LAVANTHOR;
+                    m_uiBossGUID = m_pInstance->GetData64(DATA_LAVANTHOR);
+                    m_uiDoorGUID = m_pInstance->GetData64(DATA_LAVANTHOR_DOOR);
+                    break;
+                case 7: // Zuramat
+                    m_uiBossType = TYPE_ZURAMAT;
+                    m_uiBossGUID = m_pInstance->GetData64(DATA_ZURAMAT);
+                    if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_ZURAMAT))))
+                        DoScriptText(SAY_ZURAMAT_SPAWN, pTemp);
+                    m_uiDoorGUID = m_pInstance->GetData64(DATA_ZURAMAT_DOOR);
+                    break;
+                case 3: // Moragg
+                    m_uiBossType = TYPE_MORAGG;
+                    m_uiBossGUID = m_pInstance->GetData64(DATA_MORAGG);
+                    m_uiDoorGUID = m_pInstance->GetData64(DATA_MORAGG_DOOR);
+                    break;
+                case 2: // Erekem
+                    m_uiBossType = TYPE_EREKEM;
+                    m_uiBossGUID = m_pInstance->GetData64(DATA_EREKEM);
+                    if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_EREKEM))))
+                        DoScriptText(SAY_EREKEM_SPAWN, pTemp);
+                    m_uiDoorGUID = m_pInstance->GetData64(DATA_EREKEM_DOOR);
+                    break;
+                case 4: // Ichoron
+                    m_uiBossType = TYPE_ICHORON;
+                    m_uiBossGUID = m_pInstance->GetData64(DATA_ICHORON);
+                    if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_ICHORON))))
+                        DoScriptText(SAY_ICHORON_SPAWN, pTemp);
+                    m_uiDoorGUID = m_pInstance->GetData64(DATA_ICHORON_DOOR);
+                    break;
+                case 5: // Xevozz
+                    m_uiBossType = TYPE_XEVOZZ;
+                    m_uiBossGUID = m_pInstance->GetData64(DATA_XEVOZZ);
+                    if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_XEVOZZ))))
+                        DoScriptText(SAY_XEVOZZ_SPAWN, pTemp);
+                    m_uiDoorGUID = m_pInstance->GetData64(DATA_XEVOZZ_DOOR);
+                    break;
+                case 0: // No boss
+                    m_uiBossType = 0;
+                    break;
+            }
+            m_pInstance->SetData(TYPE_LASTBOSS_ID, m_uiBossType);
+            if (m_uiBossType != 0)  m_creature->GetMotionMaster()->MovePoint(0, BossLoc[m_uiBossID].x,  BossLoc[m_uiBossID].y,  BossLoc[m_uiBossID].z);
+            else  m_creature->GetMotionMaster()->MovePoint(0, 1827.960f, 804.208f, 44.364f);
+        }
+    }
+
+    void MovementInform(uint32 uiType, uint32 uiPointId)
+    {
+        if(uiType != POINT_MOTION_TYPE)
+                return;
+
+        switch(uiPointId)
+        {
+            case 0:
+                m_bIsActiving = true;
+                break;
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_bIsActiving)
+            if (m_uiDisruption_Timer < uiDiff)
+            {
+                if (m_uiDisruptionCounter < 3) {
+                    DoCast(m_creature, SPELL_SHIELD_DISRUPTION);
+                ++m_uiDisruptionsCount;
+                m_pInstance->SetData(TYPE_DISRUPTIONS, m_uiDisruptionsCount);}
+                else if (m_uiDisruptionCounter == 3)
+                {
+                    m_pInstance->DoUseDoorOrButton(m_uiDoorGUID);
+                    if (m_uiBossType == TYPE_EREKEM) {
+                        m_pInstance->DoUseDoorOrButton(m_pInstance->GetData64(DATA_EREKEM_DOOR_L));
+                        m_pInstance->DoUseDoorOrButton(m_pInstance->GetData64(DATA_EREKEM_DOOR_R));
+                        }
+                }
+                else {
+                    m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                    if (m_pInstance->GetData(TYPE_LASTBOSS_ID) != 0) m_pInstance->SetData(m_pInstance->GetData(TYPE_LASTBOSS_ID), SPECIAL);
+                    m_bIsActiving = false;
+                    }
+
+                ++m_uiDisruptionCounter;
+                m_uiDisruption_Timer = 1000;
+            }
+            else m_uiDisruption_Timer -= uiDiff;
+    }
+};
+
+CreatureAI* GetAI_npc_azure_saboteur(Creature* pCreature)
+{
+    return new npc_azure_saboteurAI (pCreature);
+}
+CreatureAI* GetAI_mob_vh_dragons(Creature* pCreature)
+{
+    return new mob_vh_dragonsAI(pCreature);
+}
+CreatureAI* GetAI_npc_sinclari(Creature* pCreature)
+{
+    return new npc_sinclariAI (pCreature);
+}
+CreatureAI* GetAI_npc_violet_portal(Creature* pCreature)
+{
+    return new npc_violet_portalAI (pCreature);
+}
+CreatureAI* GetAI_npc_door_seal(Creature* pCreature)
+{
+    return new npc_door_sealAI(pCreature);
 }
 
 void AddSC_violet_hold()
@@ -364,25 +1108,29 @@ void AddSC_violet_hold()
     Script *newscript;
 
     newscript = new Script;
-    newscript->Name = "go_activation_crystal";
-    newscript->pGOHello = &GOHello_go_activation_crystal;
+    newscript->Name = "npc_sinclari";
+    newscript->GetAI = &GetAI_npc_sinclari;
+    newscript->pGossipHello =  &GossipHello_npc_sinclari;
+    newscript->pGossipSelect = &GossipSelect_npc_sinclari;
     newscript->RegisterSelf();
 
     newscript = new Script;
-    newscript->Name = "npc_door_seal";
-    newscript->pEffectDummyCreature = &EffectDummyCreature_npc_door_seal;
+    newscript->Name = "npc_violet_portal";
+    newscript->GetAI = &GetAI_npc_violet_portal;
     newscript->RegisterSelf();
 
     newscript = new Script;
-    newscript->Name = "npc_sinclari";
-    newscript->GetAI = &GetAI_npc_sinclari;
-    newscript->pGossipHello = &GossipHello_npc_sinclari;
-    newscript->pGossipSelect = &GossipSelect_npc_sinclari;
+    newscript->Name = "npc_door_seal_vh";
+    newscript->GetAI = &GetAI_npc_door_seal;
     newscript->RegisterSelf();
 
     newscript = new Script;
-    newscript->Name = "npc_teleportation_portal";
-    newscript->GetAI = &GetAI_npc_teleportation_portal;
-    newscript->pEffectDummyCreature = &EffectDummyCreature_npc_teleportation_portal;
+    newscript->Name = "npc_azure_saboteur";
+    newscript->GetAI = &GetAI_npc_azure_saboteur;
+    newscript->RegisterSelf();
+ 
+    newscript = new Script;
+    newscript->Name = "mob_vh_dragons";
+    newscript->GetAI = &GetAI_mob_vh_dragons;
     newscript->RegisterSelf();
 }
diff --git a/scripts/northrend/violet_hold/violet_hold.h b/scripts/northrend/violet_hold/violet_hold.h
index b8f4a8b..1a9a365 100644
--- a/scripts/northrend/violet_hold/violet_hold.h
+++ b/scripts/northrend/violet_hold/violet_hold.h
@@ -1,229 +1,177 @@
-/* Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
  * This program is free software licensed under GPL version 2
  * Please see the included DOCS/LICENSE.TXT for more information */
 
-#ifndef DEF_VIOLET_H
-#define DEF_VIOLET_H
+#ifndef DEF_VIOLET_HOLD_H
+#define DEF_VIOLET_HOLD_H
 
 enum
 {
-    MAX_ENCOUNTER               = 3,
-
-    TYPE_MAIN                   = 1,
-    TYPE_SEAL                   = 2,
-    TYPE_PORTAL                 = 3,
-
-    WORLD_STATE_ID              = 3816,
-    WORLD_STATE_SEAL            = 3815,
-    WORLD_STATE_PORTALS         = 3810,
-
-    GO_INTRO_CRYSTAL            = 193615,
-    GO_PRISON_SEAL_DOOR         = 191723,
-
-    GO_CELL_LAVANTHOR           = 191566,
-    GO_CELL_MORAGG              = 191606,
-    GO_CELL_ZURAMAT             = 191565,
-    GO_CELL_EREKEM              = 191564,
-    GO_CELL_EREKEM_GUARD_L      = 191563,
-    GO_CELL_EREKEM_GUARD_R      = 191562,
-    GO_CELL_XEVOZZ              = 191556,
-    GO_CELL_ICHORON             = 191722,
-
-    NPC_EVENT_CONTROLLER        = 30883,
-    NPC_PORTAL_INTRO            = 31011,
-    NPC_PORTAL                  = 30679,
-    NPC_PORTAL_ELITE            = 32174,
-    NPC_DOOR_SEAL               = 30896,
-
-    NPC_SINCLARI                = 30658,
-    NPC_SINCLARI_ALT            = 32204,                    // yeller for seal weakening and summoner for portals
-    NPC_HOLD_GUARD              = 30659,
-
-    NPC_EREKEM                  = 29315,
-    NPC_EREKEM_GUARD            = 29395,
-    NPC_MORAGG                  = 29316,
-    NPC_ICHORON                 = 29313,
-    NPC_XEVOZZ                  = 29266,
-    NPC_LAVANTHOR               = 29312,
-    NPC_ZURAMAT                 = 29314,
-    NPC_CYANIGOSA               = 31134,
-
-    NPC_PORTAL_GUARDIAN         = 30660,
-    NPC_PORTAL_KEEPER           = 30695,
-
-    NPC_AZURE_INVADER           = 30661,
-    NPC_AZURE_SPELLBREAKER      = 30662,
-    NPC_AZURE_BINDER            = 30663,
-    NPC_AZURE_MAGE_SLAYER       = 30664,
-    NPC_MAGE_HUNTER             = 30665,
-    NPC_AZURE_CAPTAIN           = 30666,
-    NPC_AZURE_SORCEROR          = 30667,
-    NPC_AZURE_RAIDER            = 30668,
-    NPC_AZURE_STALKER           = 32191,
-
-    // used for intro
-    NPC_AZURE_BINDER_INTRO      = 31007,
-    NPC_AZURE_INVADER_INTRO     = 31008,
-    NPC_AZURE_SPELLBREAKER_INTRO= 31009,
-    NPC_AZURE_MAGE_SLAYER_INTRO = 31010,
-
-    NPC_AZURE_SABOTEUR          = 31079,
-
-    NPC_DEFENSE_SYSTEM          = 30837,
-    NPC_DEFENSE_DUMMY_TARGET    = 30857,
-
-    NPC_ARAKKOA                 = 32226,
-    NPC_VOID_LORD               = 32230,
-    NPC_ETHERAL                 = 32231,
-    NPC_SWIRLING                = 32234,
-    NPC_WATCHER                 = 32235,
-    NPC_LAVA_HOUND              = 32237,
-
-    SPELL_DEFENSE_SYSTEM_VISUAL = 57887,
-    SPELL_DEFENSE_SYSTEM_SPAWN  = 57886,
-
-    SPELL_DESTROY_DOOR_SEAL     = 58040,                    // spell periodic cast by misc
-    SPELL_TELEPORTATION_PORTAL  = 57687,                    // visual aura, but possibly not used? creature_template model for portals are same
-
-    SPELL_SHIELD_DISRUPTION     = 58291,                    // dummy when opening a cell
-
-    SPELL_PORTAL_PERIODIC       = 58008,                    // most likely the tick for each summon (tick each 15 seconds)
-    SPELL_PORTAL_CHANNEL        = 58012,                    // the blue "stream" between portal and guardian/keeper
-    SPELL_PORTAL_BEAM           = 56046,                    // large beam, unsure if really used here (or possible for something different)
-
-    SPELL_PORTAL_VISUAL_1       = 57872,                    // no idea, but is possibly related based on it's visual appearence
-    SPELL_PORTAL_VISUAL_2       = 57630,
-
-    SAY_SEAL_75                 = -1608002,
-    SAY_SEAL_50                 = -1608003,
-    SAY_SEAL_5                  = -1608004,
-
-    EMOTE_GUARDIAN_PORTAL       = -1608005,
-    EMOTE_DRAGONFLIGHT_PORTAL   = -1608006,
-    EMOTE_KEEPER_PORTAL         = -1608007,
-
-    MAX_NORMAL_PORTAL           = 8
+    MAX_ENCOUNTER           = 9,
+
+    TYPE_EVENT              = 0,
+    TYPE_RIFT               = 1,
+    TYPE_EREKEM             = 2,
+    TYPE_MORAGG             = 3,
+    TYPE_ICHORON            = 4,
+    TYPE_XEVOZZ             = 5,
+    TYPE_LAVANTHOR          = 6,
+    TYPE_ZURAMAT            = 7,
+    TYPE_CYANIGOSA          = 8,
+
+
+    WORLD_STATE_VH          = 3816,
+    WORLD_STATE_VH_PRISON   = 3815,
+    WORLD_STATE_VH_PORTALS  = 3810,
+
+    TYPE_LASTBOSS           = 19,
+    TYPE_DOOR               = 21,
+    TYPE_PORTAL_TIME        = 22,
+
+    TYPE_DISRUPTIONS        = 101,
+    TYPE_LASTBOSS_ID        = 102,
+
+    DATA_EREKEM             = 23,
+    DATA_MORAGG             = 24,
+    DATA_ICHORON            = 25,
+    DATA_XEVOZZ             = 26,
+    DATA_LAVANTHOR          = 27,
+    DATA_ZURAMAT            = 28,
+    DATA_SINCLARI           = 29,
+    DATA_BOSSTIME           = 30,
+    DATA_NPC_SEAL_DOOR      = 31,
+
+    DATA_SEAL_DOOR          = 32,
+    DATA_EREKEM_DOOR        = 33,
+    DATA_MORAGG_DOOR        = 34,
+    DATA_ICHORON_DOOR       = 35,
+    DATA_XEVOZZ_DOOR        = 36,
+    DATA_LAVANTHOR_DOOR     = 37,
+    DATA_ZURAMAT_DOOR       = 38,
+    DATA_EREKEM_DOOR_L      = 39,
+    DATA_EREKEM_DOOR_R      = 40,
+
+    NPC_EREKEM             = 29315,
+    NPC_EREKEM_GUARD       = 29395,
+    NPC_MORAGG             = 29316,
+    NPC_ICHORON            = 29313,
+    NPC_XEVOZZ             = 29266,
+    NPC_LAVANTHOR          = 29312,
+    NPC_ZURAMAT            = 29314,
+    NPC_CYANIGOSA          = 31134,
+
+    NPC_AZURE_SABOTEUR     = 31079, // Open boss's cell
+
+    NPC_AZURE_CAPTAIN      = 30666, //Melee, 40k - 60k hp, 3 for 1-11, 4 for 13-17
+    NPC_AZURE_RAIDER       = 30668, //Melee, 40k - 60k hp
+    NPC_AZURE_SORCEROR     = 30667, //Caster, 40k - 60k hp
+    NPC_AZURE_STALKER      = 32191, //Melee, 40k - 60k hp
+    NPC_GUARDIAN           = 30660, 
+    NPC_KEEPER             = 30695, 
+    NPC_AZURE_BINDER       = 30663, //Caster, 7k - 10k hp
+    NPC_AZURE_INVADER      = 30661, //Melee, 8k - 12k hp
+    NPC_AZURE_MAGE_SLAYER  = 30664, //Melee, 10k - 15k hp
+    NPC_AZURE_SPELLBREAKER = 30662, //Caster, 10k - 15k hp
+
+    NPC_SINCLARI           = 30658,
+    NPC_GUARD              = 30659,
+    NPC_PORTAL             = 31011,
+    NPC_DOOR_SEAL          = 30896,
+
+    GO_DOOR_SEAL           = 191723,
+    GO_DOOR_EREKEM         = 191564,
+    GO_DOOR_EREKEM_RIGHT   = 191563,
+    GO_DOOR_EREKEM_LEFT    = 191562,
+    GO_DOOR_MORAGG         = 191606,
+    GO_DOOR_ICHORON        = 191722,
+    GO_DOOR_XEVOZZ         = 191556,
+    GO_DOOR_LAVANTHOR      = 191566,
+    GO_DOOR_ZURAMAT        = 191565,
+
+    SPELL_PORTAL_CHANNEL   = 58012,
+    SPELL_CORRUPT          = 58040
 };
 
-static float fDefenseSystemLoc[4] = {1888.146f, 803.382f, 58.604f, 3.072f};
-
-enum ePortalType
+struct Locations
 {
-    PORTAL_TYPE_NORM = 0,
-    PORTAL_TYPE_SQUAD,
-    PORTAL_TYPE_BOSS,
+    float x, y, z;
+    uint32 id;
 };
-
-struct sPortalData
+struct WayPoints
 {
-    ePortalType pPortalType;
-    float fX, fY, fZ, fOrient;
+    WayPoints(uint32 _id, float _x, float _y, float _z)
+    {
+        id = _id;
+        x = _x;
+        y = _y;
+        z = _z;
+    }
+    uint32 id;
+    float x, y, z;
 };
 
-static sPortalData afPortalLocation[]=
+static Locations PortalLoc[]=
 {
-    {PORTAL_TYPE_NORM, 1936.07f, 803.198f, 53.3749f, 3.1241f},  //balcony
-    {PORTAL_TYPE_NORM, 1877.51f, 850.104f, 44.6599f, 4.7822f},  //erekem
-    {PORTAL_TYPE_NORM, 1890.64f, 753.471f, 48.7224f, 1.7104f},  //moragg
-    {PORTAL_TYPE_SQUAD, 1911.06f, 802.103f, 38.6465f, 2.8908f}, //below balcony
-    {PORTAL_TYPE_SQUAD, 1928.06f, 763.256f, 51.3167f, 2.3905f}, //bridge
-    {PORTAL_TYPE_SQUAD, 1924.26f, 847.661f, 47.1591f, 4.0202f}, //zuramat
-    {PORTAL_TYPE_NORM, 1914.16f, 832.527f, 38.6441f, 3.5160f},  //xevozz
-    {PORTAL_TYPE_NORM, 1857.30f, 764.145f, 38.6543f, 0.8339f},  //lavanthor
-    {PORTAL_TYPE_BOSS, 1890.73f, 803.309f, 38.4001f, 2.4139f},  //center
+    {1888.271f, 810.781f, 38.441f}, // 0 center
+    {1857.125f, 763.295f, 38.654f}, // 1 Lavanthor
+    {1925.480f, 849.981f, 47.174f}, // 2 Zuramat
+    {1892.737f, 744.589f, 47.666f}, // 3 Moragg
+    {1878.198f, 850.005f, 43.333f}, // 4 Portal in front of Erekem
+    {1909.381f, 806.796f, 38.645f}, // 5 Portal outside of Ichoron
+    {1936.101f, 802.950f, 52.417f}, // 6 at the highest platform
 };
 
-class MANGOS_DLL_DECL instance_violet_hold : public ScriptedInstance
+static Locations BossLoc[]=
 {
-    public:
-        instance_violet_hold(Map* pMap);
-        ~instance_violet_hold() {}
-
-        void Initialize();
-        void ResetAll();
-        void ResetVariables();
-
-        void OnCreatureCreate(Creature* pCreature);
-        void OnObjectCreate(GameObject* pGo);
-
-        void UpdateCellForBoss(uint32 uiBossEntry);
-        void UpdateWorldState(bool bEnable = true);
-
-        void SetIntroPortals(bool bDeactivate);
-        void SpawnPortal();
-
-        void SetPortalId();
-
-        void CallGuards(bool bRespawn);
-
-        uint32 GetRandomPortalEliteEntry();
-        uint32 GetRandomMobForNormalPortal();
-
-        uint32 GetCurrentPortalNumber() { return m_uiWorldStatePortalCount; }
-
-        sPortalData const* GetPortalData() { return &afPortalLocation[m_uiPortalId]; }
-
-        bool IsCurrentPortalForTrash()
-        {
-            if (m_uiWorldStatePortalCount % 6)
-                return true;
-
-            return false;
-        }
-
-        bool IsNextPortalForTrash()
-        {
-            if ((m_uiWorldStatePortalCount+1) % 6)
-                return true;
-
-            return false;
-        }
-
-        void ProcessActivationCrystal(Unit* pUser, bool bIsIntro = false);
-
-        void SetRandomBosses();
-
-        void OnPlayerEnter(Player* pPlayer);
-
-        void SetData(uint32 uiType, uint32 uiData);
-        uint64 GetData64(uint32 uiData);
-
-        void Update(uint32 uiDiff);
-
-        typedef std::multimap<uint32, uint64> BossToCellMap;
-
-    protected:
-
-        uint32 m_auiEncounter[MAX_ENCOUNTER];
-        std::string strInstData;
-
-        uint64 m_uiSinclariGUID;
-        uint64 m_uiSinclariAltGUID;
-        uint64 m_uiErekemGUID;
-        uint64 m_uiMoraggGUID;
-        uint64 m_uiIchoronGUID;
-        uint64 m_uiXevozzGUID;
-        uint64 m_uiLavanthorGUID;
-        uint64 m_uiZuramatGUID;
-
-        uint64 m_uiCellErekemGuard_LGUID;
-        uint64 m_uiCellErekemGuard_RGUID;
-        uint64 m_uiIntroCrystalGUID;
-        uint64 m_uiDoorSealGUID;
-
-        uint32 m_uiWorldState;
-        uint32 m_uiWorldStateSealCount;
-        uint32 m_uiWorldStatePortalCount;
-
-        uint8 m_uiPortalId;
-        uint32 m_uiPortalTimer;
-        uint32 m_uiMaxCountPortalLoc;
-
-        BossToCellMap m_mBossToCellMap;
-
-        std::list<uint64> m_lIntroPortalList;
-        std::list<uint64> m_lGuardsList;
-        std::list<uint32> m_lRandomBossList;
+    {0,0,0},
+    {0,0,0},
+    {1876.100f, 857.079f, 43.333f}, // Erekem
+    {1892.737f, 744.589f, 47.666f}, // Moragg
+    {1908.863f, 785.647f, 37.435f}, // Ichoron
+    {1905.364f, 840.607f, 38.670f}, // Xevozz
+    {1857.125f, 763.295f, 38.654f}, // Lavanthor
+    {1925.480f, 849.981f, 47.174f}, // Zuramat
+};
+static Locations DragonsWP[]=
+{
+    //center, ichoron
+    {1869.393f, 803.902f, 38.768f}, // 0 
+    {1859.843f, 804.222f, 44.008f}, // 1 
+    {1827.960f, 804.208f, 44.364f}, // 2 
+
+    //From left side (lavanthor)
+    {1861.016f, 789.717f, 38.908f}, // 3 
+    {1856.217f, 796.705f, 44.008f}, // 4 
+    {1827.960f, 804.208f, 44.364f}, // 5 
+
+    //From Zuramat
+    {1931.446f, 826.734f, 47.556f}, // 6 
+    {1913.049f, 823.930f, 38.792f}, // 7 
+    {1827.960f, 804.208f, 44.364f}, // 8 
+    {1869.393f, 803.902f, 38.768f}, // 9 
+    {1859.843f, 804.222f, 44.008f}, // 10 
+    {1827.960f, 804.208f, 44.364f}, // 11 
+
+    //From Morag
+    {1887.500f, 763.096f, 47.666f}, // 12 
+    {1880.837f, 775.769f, 38.796f}, // 13 
+    {1861.016f, 789.717f, 38.908f}, // 14 
+    {1856.217f, 796.705f, 44.008f}, // 15 
+    {1827.960f, 804.208f, 44.364f}, // 16 
+
+    //From erekem
+    {1878.280f, 843.267f, 43.333f}, // 17 
+    {1872.311f, 835.531f, 38.780f}, // 18 
+    {1861.997f, 818.766f, 38.650f}, // 19 
+    {1857.348f, 811.230f, 44.008f}, // 20
+    {1827.960f, 804.208f, 44.364f}, // 21 
+
+    //From Highest platform
+    {1937.298f, 824.557f, 52.332f}, // 22
+    {1913.049f, 823.930f, 38.792f}, // 23
+    {1869.393f, 803.902f, 38.768f}, // 24
+    {1859.843f, 804.222f, 44.008f}, // 25
+    {1827.960f, 804.208f, 44.364f}, // 26
 };
 
 #endif
diff --git a/sql/Custom_Updates/Mangos/Northrend/VioletHold_Mangos.sql b/sql/Custom_Updates/Mangos/Northrend/VioletHold_Mangos.sql
new file mode 100644
index 0000000..3f13086
--- /dev/null
+++ b/sql/Custom_Updates/Mangos/Northrend/VioletHold_Mangos.sql
@@ -0,0 +1,54 @@
+/* VIOLET HOLD */
+UPDATE `instance_template` SET `script`='instance_violet_hold' WHERE `map`=608;
+UPDATE `creature_template` SET `ScriptName`='npc_sinclari', npcflag='1',flags_extra = 1 WHERE `entry`='30658'; -- 64
+UPDATE `creature_template` SET `ScriptName`='npc_azure_saboteur' WHERE `entry`='31079';
+UPDATE `creature_template` SET `ScriptName`='boss_cyanigosa' WHERE `entry`='31134';
+UPDATE `creature_template` SET `ScriptName`='boss_erekem' WHERE `entry`='29315';
+UPDATE `creature_template` SET `ScriptName`='mob_erekem_guard' WHERE `entry`='29395';
+UPDATE `creature_template` SET `ScriptName`='boss_ichoron' WHERE `entry`='29313';
+UPDATE `creature_template` SET `ScriptName`='mob_ichor_globule',`modelid_A`=5492, `modelid_H`=5492 WHERE `entry`='29321';
+UPDATE `creature_template` SET `modelid_A`=5492, `modelid_H`=5492 WHERE `entry`='31515'; -- heroic
+UPDATE `creature_template` SET `ScriptName`='boss_lavanthor' WHERE `entry`='29312';
+UPDATE `creature_template` SET `ScriptName`='boss_moragg' WHERE `entry`='29316';
+UPDATE `creature_template` SET `ScriptName`='boss_xevozz' WHERE `entry`='29266';
+UPDATE `creature_template` SET `ScriptName`='mob_ethereal_sphere' WHERE `entry`='29271';
+UPDATE `creature_template` SET `ScriptName`='boss_zuramat' WHERE `entry`='29314';
+UPDATE `creature_template` SET `ScriptName`='mob_zuramat_sentry' WHERE `entry`='29364';
+UPDATE `creature_template` SET `ScriptName`='npc_violet_portal' WHERE `entry`='31011';
+
+DELETE FROM `creature` WHERE map = 608 AND `id`='31011';
+DELETE FROM `creature` WHERE map = 608 AND `id`='31134';
+insert into creature VALUES ('7392', '31134', '608', '3', '1', '0', '0', '1888.271', '810.781', '38.441', '3.11684', '43200', '0', '0', '284475', '37250', '0', '0');
+UPDATE `gameobject_template` SET `flags`=`flags`|4 WHERE `entry` IN (191723,191564,191563,191562,191606,191722,191556,191566,191565); -- door untargetable
+
+UPDATE `creature_template` SET AIName='EventAI',`ScriptName`='' WHERE `entry` IN ('30660','30695','30666','30668','30667','32191');
+DELETE FROM creature_ai_scripts WHERE creature_id IN ('30660','30695','30666','30668','30667','32191');
+INSERT INTO `creature_ai_scripts` VALUES
+('3066001', '30660', '0', '0', '100', '1', '5000', '10000', '30000', '32000', '11', '58504', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Agonizing Strike'),
+('3066002', '30660', '0', '0', '100', '1', '12000', '15000', '24000', '30000', '11', '58508', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Side Swipe'),
+('3069501', '30695', '0', '0', '100', '3', '5000', '10000', '30000', '32000', '11', '58531', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Arcane Missiles'),
+('3069502', '30695', '0', '0', '100', '1', '12000', '15000', '24000', '30000', '11', '58534', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Deep Freeze'),
+('3069503', '30695', '0', '0', '100', '3', '12000', '15000', '24000', '30000', '11', '58532', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Frostbolt Volley'),
+('3069504', '30695', '0', '0', '100', '5', '5000', '10000', '30000', '32000', '11', '61593', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Arcane Missiles'),
+('3069505', '30695', '0', '0', '100', '5', '12000', '15000', '24000', '30000', '11', '61594', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Frostbolt Volley'),
+('3066601', '30666', '0', '0', '100', '1', '12000', '15000', '24000', '30000', '11', '32736', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Mortal Strike'),
+('3066602', '30666', '0', '0', '100', '3', '12000', '15000', '24000', '30000', '11', '41057', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Whirlwind'),
+('3066603', '30666', '0', '0', '100', '5', '5000', '10000', '30000', '32000', '11', '41056', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Whirlwind'),
+('3066801', '30668', '0', '0', '100', '1', '12000', '15000', '24000', '30000', '11', '60158', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Magic Reflection'),
+('3066802', '30668', '0', '0', '100', '1', '12000', '15000', '24000', '30000', '11', '52719', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Concussion Blow'),
+('3066701', '30667', '0', '0', '100', '3', '5000', '10000', '30000', '32000', '11', '60181', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Arcane Stream'),
+('3066702', '30667', '0', '0', '100', '3', '12000', '15000', '24000', '30000', '11', '60182', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Mana Detonation'),
+('3066703', '30667', '0', '0', '100', '5', '5000', '10000', '30000', '32000', '11', '60204', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Arcane Stream'),
+('3066704', '30667', '0', '0', '100', '5', '12000', '15000', '24000', '30000', '11', '60205', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Mana Detonation'),
+('3219101', '32191', '0', '0', '100', '1', '11000', '11000', '15000', '15000', '11', '58471', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Backstab'),
+('3219102', '32191', '0', '0', '100', '1', '10000', '10000', '15000', '15000', '11', '58470', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'Tactical Blink');
+DELETE FROM `spell_script_target` WHERE `entry` IN (54160,59474);
+INSERT INTO spell_script_target VALUES (54160, 1, 29266);
+INSERT INTO spell_script_target VALUES (59474, 1, 29266);
+
+UPDATE `creature_template` SET `ScriptName`='npc_door_seal_vh', unit_flags=33816580 WHERE entry=30896;
+UPDATE `creature_template` SET `faction_A`=35, faction_H=35 WHERE entry=30658;
+UPDATE `creature_template` SET ScriptName='mob_vh_dragons' WHERE entry IN (30660, 30661, 30662, 30663, 30664, 30666, 30667, 30668, 32191, 30695);
+delete from spell_target_position where id = 62139;
+insert into spell_target_position VALUES (62139, 608, 1831.821, 804.025, 44.321, 6.217);
+update creature set spawntimesecs = 604800 where id = 30658;
\ No newline at end of file
diff --git a/sql/Custom_Updates/ScriptDev2/Northrend/VioletHold_Script.sql b/sql/Custom_Updates/ScriptDev2/Northrend/VioletHold_Script.sql
new file mode 100644
index 0000000..9182b3c
--- /dev/null
+++ b/sql/Custom_Updates/ScriptDev2/Northrend/VioletHold_Script.sql
@@ -0,0 +1,53 @@
+/* VIOLET HOLD */
+delete from script_texts where entry between -1608059 and -1608010;
+INSERT IGNORE INTO `script_texts` (`entry`,`content_default`,`sound`,`type`,`language`,`comment`) VALUES
+-- Cyanigosa
+   (-1608050, 'We finish this now, champions of Kirin Tor!', 13947, 1, 0, 'cyanigosa SAY_AGGRO'),
+   (-1608051, 'I will end the Kirin Tor!', 13952, 1, 0, 'cyanigosa SAY_SLAY_1'),
+   (-1608052, 'Dalaran will fall!', 13953, 1, 0, 'cyanigosa SAY_SLAY_2'),
+   (-1608053, 'So ends your defiance of the Spell-Weaver!', 13954, 1, 0, 'cyanigosa SAY_SLAY_3'),
+   (-1608054, 'Perhaps... we have... underestimated... you.', 13955, 1, 0, 'cyanigosa SAY_DEATH'),
+   (-1608055, 'A valiant defense, but this city must be razed. I will fulfill Malygos\'s wishes myself!', 13946, 1, 0, 'cyanigosa SAY_SPAWN'),
+   (-1608056, 'Am I interrupting?', 13951, 1, 0, 'cyanigosa SAY_DISRUPTION'),
+   (-1608057, 'Shiver and die!', 13948, 1, 0, 'cyanigosa SAY_BREATH_ATTACK'),
+   (-1608058, 'The world has forgotten what true magic is! Let this be a reminder!', 13949, 1, 0, 'cyanigosa SAY_SPECIAL_ATTACK_1'),
+   (-1608059, 'Who among you can withstand my power?', 13950, 1, 0, 'cyanigosa SAY_SPECIAL_ATTACK_2'),
+-- Erekem
+   (-1608010, 'Notcawwget in way ofrrak-rrakflee!', 14219, 1, 0, 'erekem SAY_AGGRO'),
+   (-1608011, '...', 14222, 1, 0, 'erekem SAY_SLAY_1'),
+   (-1608012, 'Precious life ... wasted.', 14223, 1, 0, 'erekem SAY_SLAY_2'),
+   (-1608013, 'Only strong ... survive.', 14224, 1, 0, 'erekem SAY_SLAY_3'),
+   (-1608014, 'Nokaw, kawflee...', 14225, 1, 0, 'erekem SAY_DEATH'),
+   (-1608015, 'Free tommfly onw. Ra-aak... Not find usekh-ekh! Escape!', 14218, 1, 0, 'erekem SAY_SPAWN'),
+   (-1608016, 'My-raaakfavorite! Awk awk awk! Raa-kaa!', 14220, 1, 0, 'erekem SAY_ADD_KILLED'),
+   (-1608017, 'Nasty little...A-ak, kaw! Kill! Yes, kill you!', 14221, 1, 0, 'erekem SAY_BOTH_ADDS_KILLED'),
+-- Ichoron
+   (-1608018, 'Stand aside, mortals!', 14230, 1, 0, 'ichoron SAY_AGGRO'),
+   (-1608019, 'I am a force of nature!', 14234, 1, 0, 'ichoron SAY_SLAY_1'),
+   (-1608020, 'I shall pass!', 14235, 1, 0, 'ichoron SAY_SLAY_2'),
+   (-1608021, 'You can not stop the tide!', 14236, 1, 0, 'ichoron SAY_SLAY_3'),
+   (-1608022, 'I... recede.', 14237, 1, 0, 'ichoron SAY_DEATH'),
+   (-1608023, 'I... am fury... unrestrained!', 14239, 1, 0, 'ichoron SAY_SPAWN'),
+   (-1608024, 'I shall consume, decimate, devastate, and destroy! Yield now to the wrath of the pounding sea!', 14231, 1, 0, 'ichoron SAY_ENRAGE'),
+   (-1608025, 'I will not be contained! Ngyah!!', 14233, 1, 0, 'ichoron SAY_SHATTER'),
+   (-1608026, 'Water can hold any form, take any shape... overcome any obstacle.', 14232, 1, 0, 'ichoron SAY_BUBBLE'),
+-- Xevozz
+   (-1608027, 'It seems my freedom must be bought with blood...', 14499, 1, 0, 'xevozz SAY_AGGRO'),
+   (-1608028, 'Nothing personal.', 14504, 1, 0, 'xevozz SAY_SLAY_1'),
+   (-1608029, 'Business concluded.', 14505, 1, 0, 'xevozz SAY_SLAY_2'),
+   (-1608030, 'Profit!', 14506, 1, 0, 'xevozz SAY_SLAY_3'),
+   (-1608031, 'This is an... unrecoverable... loss.', 14507, 1, 0, 'xevozz SAY_DEATH'),
+   (-1608032, 'Back in business! Now to execute an exit strategy.', 14498, 1, 0, 'xevozz SAY_SPAWNED'),
+   (-1608033, 'It would seem that a renegotiation is in order.', 14503, 1, 0, 'xevozz SAY_CHARGED'),
+   (-1608034, 'The air teems with latent energy... quite the harvest!', 14501, 1, 0, 'xevozz SAY_REPEAT_SUMMON_1'),
+   (-1608035, 'Plentiful, exploitable resources... primed for acquisition!', 14502, 1, 0, 'xevozz SAY_REPEAT_SUMMON_2'),
+   (-1608036, 'Intriguing... a high quantity of arcane energy is near. Time for some prospecting...', 14500, 1, 0, 'xevozz SAY_SUMMON_ENERGY'),
+-- Zuramat
+   (-1608037, 'Eradicate.', 13996, 1, 0, 'zuramat SAY_AGGRO'),
+   (-1608038, 'More... energy.', 13999, 1, 0, 'zuramat SAY_SLAY_1'),
+   (-1608039, 'Relinquish.', 14000, 1, 0, 'zuramat SAY_SLAY_2'),
+   (-1608040, 'Fall... to shadow.', 14001, 1, 0, 'zuramat SAY_SLAY_3'),
+   (-1608041, 'Disperse.', 14002, 1, 0, 'zuramat SAY_DEATH'),
+   (-1608042, 'I am... renewed.', 13995, 1, 0, 'zuramat SAY_SPAWN'),
+   (-1608043, 'Know... my... pain.', 13997, 1, 0, 'zuramat SAY_SHIELD'),
+   (-1608044, 'Gaze... into the void.', 13998, 1, 0, 'zuramat SAY_WHISPER');
\ No newline at end of file
diff --git a/system/ScriptLoader.cpp b/system/ScriptLoader.cpp
index 5343503..4e7955f 100644
--- a/system/ScriptLoader.cpp
+++ b/system/ScriptLoader.cpp
@@ -355,7 +355,14 @@ extern void AddSC_boss_skadi();
 extern void AddSC_boss_svala();
 extern void AddSC_boss_ymiron();
 extern void AddSC_instance_pinnacle();
-extern void AddSC_instance_violet_hold();                   //violet_hold
+extern void AddSC_boss_cyanigosa();                        // Violet hold
+extern void AddSC_boss_erekem();
+extern void AddSC_boss_ichoron();
+extern void AddSC_boss_lavanthor();
+extern void AddSC_boss_moragg();
+extern void AddSC_boss_xevozz();
+extern void AddSC_boss_zuramat();
+extern void AddSC_instance_violet_hold();                   
 extern void AddSC_violet_hold();
 
 extern void AddSC_borean_tundra();
@@ -799,7 +806,14 @@ void AddScripts()
     AddSC_boss_svala();
     AddSC_boss_ymiron();
     AddSC_instance_pinnacle();
-    AddSC_instance_violet_hold();                           //violet_hold
+    AddSC_boss_cyanigosa();                                 // Violet hold
+    AddSC_boss_erekem();
+    AddSC_boss_ichoron();
+    AddSC_boss_lavanthor();
+    AddSC_boss_moragg();
+    AddSC_boss_xevozz();
+    AddSC_boss_zuramat();
+    AddSC_instance_violet_hold();                           
     AddSC_violet_hold();
 
     AddSC_borean_tundra();
